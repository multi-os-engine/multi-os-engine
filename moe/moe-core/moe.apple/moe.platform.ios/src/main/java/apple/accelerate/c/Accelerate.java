/*
Copyright 2014-2016 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package apple.accelerate.c;

import apple.NSObject;
import apple.accelerate.opaque.FFTSetup;
import apple.accelerate.opaque.FFTSetupD;
import apple.accelerate.opaque.sparse_matrix_double;
import apple.accelerate.opaque.sparse_matrix_float;
import apple.accelerate.opaque.vDSP_DFT_Interleaved_Setup;
import apple.accelerate.opaque.vDSP_DFT_Interleaved_SetupD;
import apple.accelerate.opaque.vDSP_DFT_Setup;
import apple.accelerate.opaque.vDSP_DFT_SetupD;
import apple.accelerate.opaque.vDSP_biquad_Setup;
import apple.accelerate.opaque.vDSP_biquad_SetupD;
import apple.accelerate.opaque.vDSP_biquadm_Setup;
import apple.accelerate.opaque.vDSP_biquadm_SetupD;
import apple.accelerate.opaque.vImageCVImageFormatRef;
import apple.accelerate.opaque.vImageConstCVImageFormatRef;
import apple.accelerate.opaque.vImageConverterRef;
import apple.accelerate.opaque.vImage_MultidimensionalTable;
import apple.accelerate.struct.*;
import apple.corefoundation.opaque.CFStringRef;
import apple.coregraphics.opaque.CGColorConversionInfoRef;
import apple.coregraphics.opaque.CGColorSpaceRef;
import apple.coregraphics.opaque.CGImageRef;
import apple.coregraphics.struct.CGSize;
import apple.corevideo.opaque.CVBufferRef;
import org.moe.natj.c.CRuntime;
import org.moe.natj.c.ann.CFunction;
import org.moe.natj.c.ann.CVariable;
import org.moe.natj.c.ann.FunctionPtr;
import org.moe.natj.c.ann.Variadic;
import org.moe.natj.general.NatJ;
import org.moe.natj.general.ann.ByValue;
import org.moe.natj.general.ann.Generated;
import org.moe.natj.general.ann.Library;
import org.moe.natj.general.ann.NInt;
import org.moe.natj.general.ann.NUInt;
import org.moe.natj.general.ann.Runtime;
import org.moe.natj.general.ann.UncertainArgument;
import org.moe.natj.general.ann.UncertainReturn;
import org.moe.natj.general.ptr.BytePtr;
import org.moe.natj.general.ptr.CharPtr;
import org.moe.natj.general.ptr.ConstBoolPtr;
import org.moe.natj.general.ptr.ConstBytePtr;
import org.moe.natj.general.ptr.ConstCharPtr;
import org.moe.natj.general.ptr.ConstDoublePtr;
import org.moe.natj.general.ptr.ConstFloatPtr;
import org.moe.natj.general.ptr.ConstIntPtr;
import org.moe.natj.general.ptr.ConstLongPtr;
import org.moe.natj.general.ptr.ConstNFloatPtr;
import org.moe.natj.general.ptr.ConstNUIntPtr;
import org.moe.natj.general.ptr.ConstPtr;
import org.moe.natj.general.ptr.ConstShortPtr;
import org.moe.natj.general.ptr.ConstVoidPtr;
import org.moe.natj.general.ptr.DoublePtr;
import org.moe.natj.general.ptr.FloatPtr;
import org.moe.natj.general.ptr.IntPtr;
import org.moe.natj.general.ptr.LongPtr;
import org.moe.natj.general.ptr.NIntPtr;
import org.moe.natj.general.ptr.NUIntPtr;
import org.moe.natj.general.ptr.Ptr;
import org.moe.natj.general.ptr.ShortPtr;
import org.moe.natj.general.ptr.VoidPtr;

@Generated
@Library("Accelerate")
@Runtime(CRuntime.class)
public final class Accelerate {
    static {
        NatJ.register();
    }

    @Generated
    private Accelerate() {
    }

    /**
     * vDSP_create_fftsetup and vDSP_create_ffsetupD allocate memory and prepare
     * constants used by single- and double-precision FFT routines, respectively.
     * <p>
     * vDSP_destroy_fftsetup and vDSP_destroy_fftsetupD free the memory.  They
     * may be passed a null pointer, in which case they have no effect.
     */
    @Generated
    @CFunction
    public static native FFTSetup vDSP_create_fftsetup(@NUInt long __Log2n, int __Radix);

    @Generated
    @CFunction
    public static native void vDSP_destroy_fftsetup(FFTSetup __setup);

    @Generated
    @CFunction
    public static native FFTSetupD vDSP_create_fftsetupD(@NUInt long __Log2n, int __Radix);

    @Generated
    @CFunction
    public static native void vDSP_destroy_fftsetupD(FFTSetupD __setup);

    /**
     * vDSP_biquad_CreateSetup allocates memory and prepares the coefficients for
     * processing a cascaded biquad IIR filter.
     * <p>
     * vDSP_biquad_DestroySetup frees the memory allocated by
     * vDSP_biquad_CreateSetup.
     */
    @Generated
    @CFunction
    public static native vDSP_biquad_Setup vDSP_biquad_CreateSetup(ConstDoublePtr __Coefficients, @NUInt long __M);

    @Generated
    @CFunction
    public static native vDSP_biquad_SetupD vDSP_biquad_CreateSetupD(ConstDoublePtr __Coefficients, @NUInt long __M);

    @Generated
    @CFunction
    public static native void vDSP_biquad_DestroySetup(vDSP_biquad_Setup __setup);

    @Generated
    @CFunction
    public static native void vDSP_biquad_DestroySetupD(vDSP_biquad_SetupD __setup);

    /**
     * vDSP_biquadm_CreateSetup (for float) or vDSP_biquadm_CreateSetupD (for
     * double) allocates memory and prepares the coefficients for processing a
     * multi-channel cascaded biquad IIR filter.  Delay values are set to zero.
     * <p>
     * Unlike some other setup objects in vDSP, a vDSP_biquadm_Setup or
     * vDSP_biquadm_SetupD contains data that is modified during a vDSP_biquadm or
     * vDSP_biquadmD call, and it therefore may not be used more than once
     * simultaneously, as in multiple threads.
     * <p>
     * vDSP_biquadm_DestroySetup (for single) or vDSP_biquadm_DestroySetupD (for
     * double) frees the memory allocated by the corresponding create-setup
     * routine.
     */
    @Generated
    @CFunction
    public static native vDSP_biquadm_Setup vDSP_biquadm_CreateSetup(ConstDoublePtr __coeffs, @NUInt long __M,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native vDSP_biquadm_SetupD vDSP_biquadm_CreateSetupD(ConstDoublePtr __coeffs, @NUInt long __M,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_biquadm_DestroySetup(vDSP_biquadm_Setup __setup);

    @Generated
    @CFunction
    public static native void vDSP_biquadm_DestroySetupD(vDSP_biquadm_SetupD __setup);

    /**
     * vDSP_biquadm_CopyState (for float) or vDSP_biquadm_CopyStateD (for double)
     * copies the current state between two biquadm setup objects.  The two
     * objects must have been created with the same number of channels and
     * sections.
     * <p>
     * vDSP_biquadm_ResetState (for float) or vDSP_biquadm_ResetStateD (for
     * double) sets the delay values of a biquadm setup object to zero.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquadm_CopyState(vDSP_biquadm_Setup __dest, VoidPtr __src);

    @Generated
    @CFunction
    public static native void vDSP_biquadm_CopyStateD(vDSP_biquadm_SetupD __dest, VoidPtr __src);

    @Generated
    @CFunction
    public static native void vDSP_biquadm_ResetState(vDSP_biquadm_Setup __setup);

    @Generated
    @CFunction
    public static native void vDSP_biquadm_ResetStateD(vDSP_biquadm_SetupD __setup);

    /**
     * vDSP_biquadm_SetCoefficientsDouble will
     * update the filter coefficients within a valid vDSP_biquadm_Setup object.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquadm_SetCoefficientsDouble(vDSP_biquadm_Setup __setup, ConstDoublePtr __coeffs,
            @NUInt long __start_sec, @NUInt long __start_chn, @NUInt long __nsec, @NUInt long __nchn);

    /**
     * vDSP_biquadm_SetTargetsDouble will
     * set the target coefficients within a valid vDSP_biquadm_Setup object.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquadm_SetTargetsDouble(vDSP_biquadm_Setup __setup, ConstDoublePtr __targets,
            float __interp_rate, float __interp_threshold, @NUInt long __start_sec, @NUInt long __start_chn,
            @NUInt long __nsec, @NUInt long __nchn);

    /**
     * vDSP_biquadm_SetCoefficientsSingle will
     * update the filter coefficients within a valid vDSP_biquadm_Setup object.
     * <p>
     * Coefficients are specified in single precision.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquadm_SetCoefficientsSingle(vDSP_biquadm_Setup __setup, ConstFloatPtr __coeffs,
            @NUInt long __start_sec, @NUInt long __start_chn, @NUInt long __nsec, @NUInt long __nchn);

    /**
     * vDSP_biquadm_SetTargetsSingle will
     * set the target coefficients within a valid vDSP_biquadm_Setup object.
     * The target values are specified in single precision.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquadm_SetTargetsSingle(vDSP_biquadm_Setup __setup, ConstFloatPtr __targets,
            float __interp_rate, float __interp_threshold, @NUInt long __start_sec, @NUInt long __start_chn,
            @NUInt long __nsec, @NUInt long __nchn);

    /**
     * vDSP_biquadm_SetActiveFilters will set the overall active/inactive filter
     * state of a valid vDSP_biquadm_Setup object.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquadm_SetActiveFilters(vDSP_biquadm_Setup __setup, ConstBoolPtr __filter_states);

    /**
     * Convert a complex array to a complex-split array.
     */
    @Generated
    @CFunction
    public static native void vDSP_ctoz(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Z, @NInt long __IZ,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_ctozD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Z,
            @NInt long __IZ, @NUInt long __N);

    /**
     * Convert a complex-split array to a complex array.
     */
    @Generated
    @CFunction
    public static native void vDSP_ztoc(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Z, @NInt long __IZ,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_ztocD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Z,
            @NInt long __IZ, @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * In-place complex Discrete Fourier Transform routines, with and without
     * temporary memory.  We suggest you use the DFT routines instead of these.
     */
    @Generated
    @CFunction
    public static native void vDSP_fft_zip(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zipD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zipt(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_ziptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N, int __Direction);

    /**
     * Out-of-place complex Discrete Fourier Transform routines, with and without
     * temporary memory.  We suggest you use the DFT routines instead of these.
     */
    @Generated
    @CFunction
    public static native void vDSP_fft_zop(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zopt(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zopD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zoptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N, int __Direction);

    /**
     * In-place real-to-complex Discrete Fourier Transform routines, with and
     * without temporary memory.  We suggest you use the DFT routines instead of
     * these.
     */
    @Generated
    @CFunction
    public static native void vDSP_fft_zrip(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zripD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zript(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zriptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N, int __Direction);

    /**
     * Out-of-place real-to-complex Discrete Fourier Transform routines, with and
     * without temporary memory.  We suggest you use the DFT routines instead of
     * these.
     */
    @Generated
    @CFunction
    public static native void vDSP_fft_zrop(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zropD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zropt(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft_zroptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N, int __Direction);

    /**
     * In-place two-dimensional complex Discrete Fourier Transform routines, with
     * and without temporary memory.
     */
    @Generated
    @CFunction
    public static native void vDSP_fft2d_zip(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC0,
            @NInt long __IC1, @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zipD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1, @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zipt(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC1,
            @NInt long __IC0,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_ziptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    /**
     * Out-of-place two-dimensional complex Discrete Fourier Transform routines,
     * with and without temporary memory.
     */
    @Generated
    @CFunction
    public static native void vDSP_fft2d_zop(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA0,
            @NInt long __IA1, @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1, @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zopD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA0, @NInt long __IA1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1, @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zopt(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA0,
            @NInt long __IA1, @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zoptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA0, @NInt long __IA1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    /**
     * In-place two-dimensional real-to-complex Discrete Fourier Transform
     * routines, with and without temporary memory.
     */
    @Generated
    @CFunction
    public static native void vDSP_fft2d_zrip(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC0,
            @NInt long __IC1, @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zripD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1, @NUInt long __Log2N0, @NUInt long __Log2N1, int __flag);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zript(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC0,
            @NInt long __IC1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zriptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N0, @NUInt long __Log2N1, int __flag);

    /**
     * Out-of-place two-dimensional real-to-complex Discrete Fourier Transform
     * routines, with and without temporary memory.
     */
    @Generated
    @CFunction
    public static native void vDSP_fft2d_zrop(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA0,
            @NInt long __IA1, @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1, @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zropt(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA0,
            @NInt long __IA1, @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zropD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA0, @NInt long __IA1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1, @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fft2d_zroptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA0, @NInt long __IA1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC0, @NInt long __IC1,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N0, @NUInt long __Log2N1, int __Direction);

    /**
     * In-place multiple complex Discrete Fourier Transform routines, with and
     * without temporary memory.
     */
    @Generated
    @CFunction
    public static native void vDSP_fftm_zip(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NInt long __IM, @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zipD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NInt long __IM, @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zipt(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NInt long __IM,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_ziptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NInt long __IM,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N, @NUInt long __M, int __Direction);

    /**
     * Out-of-place multiple complex Discrete Fourier Transform routines, with and
     * without temporary memory.
     */
    @Generated
    @CFunction
    public static native void vDSP_fftm_zop(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @NInt long __IMA, @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C,
            @NInt long __IC, @NInt long __IMC, @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zopD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, @NInt long __IMA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NInt long __IMC, @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zopt(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @NInt long __IMA, @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C,
            @NInt long __IC, @NInt long __IMC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zoptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, @NInt long __IMA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NInt long __IMC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N, @NUInt long __M, int __Direction);

    /**
     * In-place multiple real-to-complex Discrete Fourier Transform routines, with
     * and without temporary memory.  We suggest you use the DFT routines instead
     * of these.
     */
    @Generated
    @CFunction
    public static native void vDSP_fftm_zrip(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NInt long __IM, @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zripD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NInt long __IM, @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zript(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NInt long __IM,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zriptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NInt long __IM,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N, @NUInt long __M, int __Direction);

    /**
     * Out-of-place multiple real-to-complex Discrete Fourier Transform routines,
     * with and without temporary memory.  We suggest you use the DFT routines
     * instead of these.
     */
    @Generated
    @CFunction
    public static native void vDSP_fftm_zrop(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @NInt long __IMA, @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C,
            @NInt long __IC, @NInt long __IMC, @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zropt(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @NInt long __IMA, @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C,
            @NInt long __IC, @NInt long __IMC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __Buffer,
            @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zropD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, @NInt long __IMA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NInt long __IMC, @NUInt long __Log2N, @NUInt long __M, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_fftm_zroptD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, @NInt long __IMA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NInt long __IMC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __Buffer,
            @NUInt long __Log2N, @NUInt long __M, int __Direction);

    /**
     * Non-power-of-two out-of-place complex Discrete Fourier Transform routines.
     * We suggest you use the DFT routines instead of these.
     */
    @Generated
    @Deprecated
    @CFunction
    public static native void vDSP_fft3_zop(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @Deprecated
    @CFunction
    public static native void vDSP_fft3_zopD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __Log2N, int __Direction);

    @Generated
    @Deprecated
    @CFunction
    public static native void vDSP_fft5_zop(FFTSetup __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __Log2N, int __Direction);

    @Generated
    @Deprecated
    @CFunction
    public static native void vDSP_fft5_zopD(FFTSetupD __Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __Log2N, int __Direction);

    /**
     * Cascade biquadratic IIR filters.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquad(VoidPtr __Setup, FloatPtr __Delay, ConstFloatPtr __X, @NInt long __IX,
            FloatPtr __Y, @NInt long __IY, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_biquadD(VoidPtr __Setup, DoublePtr __Delay, ConstDoublePtr __X, @NInt long __IX,
            DoublePtr __Y, @NInt long __IY, @NUInt long __N);

    /**
     * vDSP_biquadm (for float) or vDSP_biquadmD (for double) applies a
     * multi-channel biquadm IIR filter created with vDSP_biquadm_CreateSetup or
     * vDSP_biquadm_CreateSetupD, respectively.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquadm(vDSP_biquadm_Setup __Setup, Ptr<ConstFloatPtr> __X, @NInt long __IX,
            Ptr<FloatPtr> __Y, @NInt long __IY, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_biquadmD(vDSP_biquadm_SetupD __Setup, Ptr<ConstDoublePtr> __X, @NInt long __IX,
            Ptr<DoublePtr> __Y, @NInt long __IY, @NUInt long __N);

    /**
     * Convolution and correlation.
     */
    @Generated
    @CFunction
    public static native void vDSP_conv(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __F, @NInt long __IF,
            FloatPtr __C, @NInt long __IC, @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_convD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __F, @NInt long __IF,
            DoublePtr __C, @NInt long __IC, @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_zconv(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __F, @NInt long __IF,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_zconvD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __F,
            @NInt long __IF,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N, @NUInt long __P);

    /**
     * 3*3 and 5*5 convolutions.
     */
    @Generated
    @CFunction
    public static native void vDSP_f3x3(ConstFloatPtr __A, @NUInt long __NR, @NUInt long __NC, ConstFloatPtr __F,
            FloatPtr __C);

    @Generated
    @CFunction
    public static native void vDSP_f3x3D(ConstDoublePtr __A, @NUInt long __NR, @NUInt long __NC, ConstDoublePtr __F,
            DoublePtr __C);

    @Generated
    @CFunction
    public static native void vDSP_f5x5(ConstFloatPtr __A, @NUInt long __NR, @NUInt long __NC, ConstFloatPtr __F,
            FloatPtr __C);

    @Generated
    @CFunction
    public static native void vDSP_f5x5D(ConstDoublePtr __A, @NUInt long __NR, @NUInt long __NC, ConstDoublePtr __F,
            DoublePtr __C);

    /**
     * Two-dimensional (image) convolution.
     */
    @Generated
    @CFunction
    public static native void vDSP_imgfir(ConstFloatPtr __A, @NUInt long __NR, @NUInt long __NC, ConstFloatPtr __F,
            FloatPtr __C, @NUInt long __P, @NUInt long __Q);

    @Generated
    @CFunction
    public static native void vDSP_imgfirD(ConstDoublePtr __A, @NUInt long __NR, @NUInt long __NC, ConstDoublePtr __F,
            DoublePtr __C, @NUInt long __P, @NUInt long __Q);

    /**
     * Maps:
     * <p>
     * This routine does not have strides.
     * <p>
     * A and C are regarded as two-dimensional matrices with dimensions
     * [NR][NC].  F is regarded as a two-dimensional matrix with
     * dimensions [P][Q].
     * <p>
     * A and C are regarded as two-dimensional matrices with dimensions
     * [NR][NC].  F is regarded as a two-dimensional matrix with
     * dimensions [P][P]:
     * <p>
     * Pseudocode:     Memory:
     * A[j][k]         A[j*NC + k]
     * C[j][k]         C[j*NC + k]
     * F[j][k]         F[j*Q  + k]
     * <p>
     * These compute:
     * <p>
     * P and Q must be odd.  "P/2" and "Q/2" are evaluated with integer
     * arithmetic, so, if P is 3, P/2 is 1, not 1.5.
     * <p>
     * for (r = P/2; r < NR-P/2; ++r)
     * for (c = Q/2; c < NC-Q/2; ++c)
     * C[r][c] = sum(A[r+j][c+k] * F[j+P/2][k+Q/2],
     * -P/2 <= j < P/2, -Q/2 <= k < Q/2);
     * <p>
     * All other elements of C (borders of P/2 elements at the top and
     * bottom and Q/2 elements at the left and right) are set to zero.
     */
    @Generated
    @CFunction
    public static native void vDSP_mtrans(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __M, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_mtransD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __M, @NUInt long __N);

    /**
     * Matrix multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_mmul(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __M, @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_mmulD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __M, @NUInt long __N, @NUInt long __P);

    /**
     * Split-complex matrix multiply and add.
     */
    @Generated
    @CFunction
    public static native void vDSP_zmma(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __D, @NInt long __ID,
            @NUInt long __M, @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_zmmaD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __D,
            @NInt long __ID, @NUInt long __M, @NUInt long __N, @NUInt long __P);

    /**
     * Split-complex matrix multiply and subtract.
     */
    @Generated
    @CFunction
    public static native void vDSP_zmms(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __D, @NInt long __ID,
            @NUInt long __M, @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_zmmsD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __D,
            @NInt long __ID, @NUInt long __M, @NUInt long __N, @NUInt long __P);

    /**
     * Vector multiply, multiply, add, and add.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvmmaa(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __D, @NInt long __ID,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __E, @NInt long __IE,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __F, @NInt long __IF,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvmmaaD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __D,
            @NInt long __ID,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __E,
            @NInt long __IE,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __F,
            @NInt long __IF, @NUInt long __N);

    /**
     * Split-complex matrix multiply and reverse subtract.
     */
    @Generated
    @CFunction
    public static native void vDSP_zmsm(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __D, @NInt long __ID,
            @NUInt long __M, @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_zmsmD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __D,
            @NInt long __ID, @NUInt long __M, @NUInt long __N, @NUInt long __P);

    /**
     * Split-complex matrix multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_zmmul(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __M, @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_zmmulD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __M, @NUInt long __N, @NUInt long __P);

    /**
     * Vector add.
     */
    @Generated
    @CFunction
    public static native void vDSP_vadd(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vaddD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vaddi(ConstIntPtr __A, @NInt long __IA, ConstIntPtr __B, @NInt long __IB, IntPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvadd(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvaddD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zrvadd(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            ConstFloatPtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zrvaddD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector subtract.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsub(ConstFloatPtr __B, @NInt long __IB, ConstFloatPtr __A, @NInt long __IA,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsubD(ConstDoublePtr __B, @NInt long __IB, ConstDoublePtr __A, @NInt long __IA,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvsub(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvsubD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_vmul(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vmulD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zrvmul(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            ConstFloatPtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zrvmulD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector divide.
     */
    @Generated
    @CFunction
    public static native void vDSP_vdiv(ConstFloatPtr __B, @NInt long __IB, ConstFloatPtr __A, @NInt long __IA,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vdivD(ConstDoublePtr __B, @NInt long __IB, ConstDoublePtr __A, @NInt long __IA,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vdivi(ConstIntPtr __B, @NInt long __IB, ConstIntPtr __A, @NInt long __IA, IntPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvdiv(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvdivD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zrvdiv(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            ConstFloatPtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zrvdivD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector-scalar multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsmul(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsmulD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector square.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsq(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsqD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector signed square.
     */
    @Generated
    @CFunction
    public static native void vDSP_vssq(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vssqD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Euclidean distance, squared.
     */
    @Generated
    @CFunction
    public static native void vDSP_distancesq(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_distancesqD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NUInt long __N);

    /**
     * Dot product.
     */
    @Generated
    @CFunction
    public static native void vDSP_dotpr(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_dotprD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zdotpr(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zdotprD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zrdotpr(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            ConstFloatPtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zrdotprD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NUInt long __N);

    /**
     * Vector add and multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_vam(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vamD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, DoublePtr __D, @NInt long __IDD, @NUInt long __N);

    /**
     * Vector multiply and add.
     */
    @Generated
    @CFunction
    public static native void vDSP_vma(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vmaD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvma(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __D, @NInt long __ID,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvmaD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __D,
            @NInt long __ID, @NUInt long __N);

    /**
     * Complex multiplication with optional conjugation.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvmul(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N, int __Conjugate);

    @Generated
    @CFunction
    public static native void vDSP_zvmulD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N, int __Conjugate);

    /**
     * Complex-split inner (conjugate) dot product.
     */
    @Generated
    @CFunction
    public static native void vDSP_zidotpr(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zidotprD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NUInt long __N);

    /**
     * Complex-split conjugate multiply and add.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvcma(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __D, @NInt long __ID,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvcmaD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __D,
            @NInt long __ID, @NUInt long __N);

    /**
     * Subtract real from complex-split.
     */
    @Generated
    @CFunction
    public static native void vDSP_zrvsub(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            ConstFloatPtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zrvsubD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector convert between double precision and single precision.
     */
    @Generated
    @CFunction
    public static native void vDSP_vdpsp(ConstDoublePtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vspdp(ConstFloatPtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector absolute value.
     */
    @Generated
    @CFunction
    public static native void vDSP_vabs(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vabsD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vabsi(ConstIntPtr __A, @NInt long __IA, IntPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvabs(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvabsD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector bit-wise equivalence, NOT (A XOR B).
     */
    @Generated
    @CFunction
    public static native void vDSP_veqvi(ConstIntPtr __A, @NInt long __IA, ConstIntPtr __B, @NInt long __IB, IntPtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector fill.
     */
    @Generated
    @CFunction
    public static native void vDSP_vfill(ConstFloatPtr __A, FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfillD(ConstDoublePtr __A, DoublePtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfilli(ConstIntPtr __A, IntPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvfill(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvfillD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector-scalar add.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsadd(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsaddD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsaddi(ConstIntPtr __A, @NInt long __IA, ConstIntPtr __B, IntPtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector-scalar divide.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsdiv(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsdivD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsdivi(ConstIntPtr __A, @NInt long __IA, ConstIntPtr __B, IntPtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Complex-split accumulating autospectrum.
     */
    @Generated
    @CFunction
    public static native void vDSP_zaspec(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, FloatPtr __C,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zaspecD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            DoublePtr __C, @NUInt long __N);

    /**
     * Create Blackman window.
     */
    @Generated
    @CFunction
    public static native void vDSP_blkman_window(FloatPtr __C, @NUInt long __N, int __Flag);

    @Generated
    @CFunction
    public static native void vDSP_blkman_windowD(DoublePtr __C, @NUInt long __N, int __Flag);

    /**
     * Coherence function.
     */
    @Generated
    @CFunction
    public static native void vDSP_zcoher(ConstFloatPtr __A, ConstFloatPtr __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, FloatPtr __D,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zcoherD(ConstDoublePtr __A, ConstDoublePtr __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            DoublePtr __D, @NUInt long __N);

    /**
     * Anti-aliasing down-sample with real filter.
     */
    @Generated
    @CFunction
    public static native void vDSP_desamp(ConstFloatPtr __A, @NInt long __DF, ConstFloatPtr __F, FloatPtr __C,
            @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_desampD(ConstDoublePtr __A, @NInt long __DF, ConstDoublePtr __F, DoublePtr __C,
            @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_zrdesamp(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __DF,
            ConstFloatPtr __F, @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C,
            @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_zrdesampD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __DF, ConstDoublePtr __F,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NUInt long __N, @NUInt long __P);

    /**
     * Transfer function, B/A.
     */
    @Generated
    @CFunction
    public static native void vDSP_ztrans(ConstFloatPtr __A,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_ztransD(ConstDoublePtr __A,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NUInt long __N);

    /**
     * Accumulating cross-spectrum.
     */
    @Generated
    @CFunction
    public static native void vDSP_zcspec(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zcspecD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NUInt long __N);

    /**
     * Vector conjugate and multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvcmul(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B, @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvcmulD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @NInt long __IB,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __iC, @NUInt long __N);

    /**
     * Vector conjugate.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvconj(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvconjD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector multiply with scalar.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvzsml(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvzsmlD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector magnitudes squared.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvmags(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvmagsD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector magnitudes square and add.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvmgsa(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            ConstFloatPtr __B, @NInt long __IB, FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvmgsaD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, ConstDoublePtr __B, @NInt long __IB, DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Complex-split vector move.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvmov(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvmovD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector negate.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvneg(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvnegD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector phasea.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvphas(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvphasD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA, DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector multiply by scalar and add.
     */
    @Generated
    @CFunction
    public static native void vDSP_zvsma(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __A, @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __C, @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPSplitComplex __D, @NInt long __ID,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_zvsmaD(
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __A,
            @NInt long __IA,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __B,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __C,
            @NInt long __IC,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleSplitComplex __D,
            @NInt long __ID, @NUInt long __N);

    /**
     * Difference equation, 2 poles, 2 zeros.
     */
    @Generated
    @CFunction
    public static native void vDSP_deq22(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_deq22D(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Create Hamming window.
     */
    @Generated
    @CFunction
    public static native void vDSP_hamm_window(FloatPtr __C, @NUInt long __N, int __Flag);

    @Generated
    @CFunction
    public static native void vDSP_hamm_windowD(DoublePtr __C, @NUInt long __N, int __Flag);

    /**
     * Create Hanning window.
     */
    @Generated
    @CFunction
    public static native void vDSP_hann_window(FloatPtr __C, @NUInt long __N, int __Flag);

    @Generated
    @CFunction
    public static native void vDSP_hann_windowD(DoublePtr __C, @NUInt long __N, int __Flag);

    /**
     * Maximum magnitude of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_maxmgv(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_maxmgvD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Maximum magnitude of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_maxmgvi(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, NUIntPtr __I,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_maxmgviD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, NUIntPtr __I,
            @NUInt long __N);

    /**
     * Maximum value of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_maxv(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_maxvD(ConstDoublePtr __A, @NInt long __I, DoublePtr __C, @NUInt long __N);

    /**
     * Maximum value of vector, with index.
     */
    @Generated
    @CFunction
    public static native void vDSP_maxvi(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, NUIntPtr __I,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_maxviD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, NUIntPtr __I,
            @NUInt long __N);

    /**
     * Mean magnitude of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_meamgv(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_meamgvD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Mean of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_meanv(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_meanvD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Mean square of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_measqv(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_measqvD(ConstDoublePtr __A, @NInt long __I, DoublePtr __C, @NUInt long __N);

    /**
     * Minimum magnitude of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_minmgv(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_minmgvD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Minimum magnitude of vector, with index.
     */
    @Generated
    @CFunction
    public static native void vDSP_minmgvi(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, NUIntPtr __I,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_minmgviD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, NUIntPtr __I,
            @NUInt long __N);

    /**
     * Minimum value of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_minv(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_minvD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Minimum value of vector, with index.
     */
    @Generated
    @CFunction
    public static native void vDSP_minvi(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, NUIntPtr __I,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_minviD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, NUIntPtr __I,
            @NUInt long __N);

    /**
     * Matrix move.
     */
    @Generated
    @CFunction
    public static native void vDSP_mmov(ConstFloatPtr __A, FloatPtr __C, @NUInt long __M, @NUInt long __N,
            @NUInt long __TA, @NUInt long __TC);

    @Generated
    @CFunction
    public static native void vDSP_mmovD(ConstDoublePtr __A, DoublePtr __C, @NUInt long __M, @NUInt long __N,
            @NUInt long __TA, @NUInt long __TC);

    /**
     * Mean of signed squares of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_mvessq(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_mvessqD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Find zero crossing.
     */
    @Generated
    @CFunction
    public static native void vDSP_nzcros(ConstFloatPtr __A, @NInt long __IA, @NUInt long __B, NUIntPtr __C,
            NUIntPtr __D, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_nzcrosD(ConstDoublePtr __A, @NInt long __IA, @NUInt long __B, NUIntPtr __C,
            NUIntPtr __D, @NUInt long __N);

    /**
     * Convert rectangular to polar.
     */
    @Generated
    @CFunction
    public static native void vDSP_polar(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_polarD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Convert polar to rectangular.
     */
    @Generated
    @CFunction
    public static native void vDSP_rect(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_rectD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Root-mean-square of vector.
     */
    @Generated
    @CFunction
    public static native void vDSP_rmsqv(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_rmsqvD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Scalar-vector divide.
     */
    @Generated
    @CFunction
    public static native void vDSP_svdiv(ConstFloatPtr __A, ConstFloatPtr __B, @NInt long __IB, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_svdivD(ConstDoublePtr __A, ConstDoublePtr __B, @NInt long __IB, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Sum of vector elements.
     */
    @Generated
    @CFunction
    public static native void vDSP_sve(ConstFloatPtr __A, @NInt long __I, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_sveD(ConstDoublePtr __A, @NInt long __I, DoublePtr __C, @NUInt long __N);

    /**
     * Sum of vector elements magnitudes.
     */
    @Generated
    @CFunction
    public static native void vDSP_svemg(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_svemgD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Sum of vector elements' squares.
     */
    @Generated
    @CFunction
    public static native void vDSP_svesq(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_svesqD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Sum of vector elements and sum of vector elements' squares.
     */
    @Generated
    @CFunction
    public static native void vDSP_sve_svesq(ConstFloatPtr __A, @NInt long __IA, FloatPtr __Sum,
            FloatPtr __SumOfSquares, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_sve_svesqD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __Sum,
            DoublePtr __SumOfSquares, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_normalize(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            FloatPtr __Mean, FloatPtr __StandardDeviation, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_normalizeD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            DoublePtr __Mean, DoublePtr __StandardDeviation, @NUInt long __N);

    /**
     * Sum of vector elements' signed squares.
     */
    @Generated
    @CFunction
    public static native void vDSP_svs(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_svsD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NUInt long __N);

    /**
     * Vector add, add, and multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_vaam(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, ConstFloatPtr __D, @NInt long __ID, FloatPtr __E, @NInt long __IE,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vaamD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, ConstDoublePtr __D, @NInt long __ID, DoublePtr __E, @NInt long __IE,
            @NUInt long __N);

    /**
     * Vector add, subtract, and multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_vasbm(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, ConstFloatPtr __D, @NInt long __ID, FloatPtr __E, @NInt long __IE,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vasbmD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, ConstDoublePtr __D, @NInt long __ID, DoublePtr __E, @NInt long __IE,
            @NUInt long __N);

    /**
     * Vector add and scalar multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_vasm(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vasmD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector linear average.
     */
    @Generated
    @CFunction
    public static native void vDSP_vavlin(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vavlinD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector clip.
     */
    @Generated
    @CFunction
    public static native void vDSP_vclip(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, ConstFloatPtr __C,
            FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vclipD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, ConstDoublePtr __C,
            DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector clip and count.
     */
    @Generated
    @CFunction
    public static native void vDSP_vclipc(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, ConstFloatPtr __C,
            FloatPtr __D, @NInt long __ID, @NUInt long __N, NUIntPtr __NLow, NUIntPtr __NHigh);

    @Generated
    @CFunction
    public static native void vDSP_vclipcD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, ConstDoublePtr __C,
            DoublePtr __D, @NInt long __ID, @NUInt long __N, NUIntPtr __NLow, NUIntPtr __NHigh);

    /**
     * Vector clear.
     */
    @Generated
    @CFunction
    public static native void vDSP_vclr(FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vclrD(DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector compress.
     */
    @Generated
    @CFunction
    public static native void vDSP_vcmprs(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vcmprsD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector convert to decibels, power, or amplitude.
     */
    @Generated
    @CFunction
    public static native void vDSP_vdbcon(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N, int __F);

    @Generated
    @CFunction
    public static native void vDSP_vdbconD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N, int __F);

    /**
     * Vector distance.
     */
    @Generated
    @CFunction
    public static native void vDSP_vdist(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vdistD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector envelope.
     */
    @Generated
    @CFunction
    public static native void vDSP_venvlp(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_venvlpD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector convert to integer, round toward zero.
     */
    @Generated
    @CFunction
    public static native void vDSP_vfix8(ConstFloatPtr __A, @NInt long __IA, BytePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfix8D(ConstDoublePtr __A, @NInt long __IA, BytePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfix16(ConstFloatPtr __A, @NInt long __IA, ShortPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfix16D(ConstDoublePtr __A, @NInt long __IA, ShortPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfix32(ConstFloatPtr __A, @NInt long __IA, IntPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfix32D(ConstDoublePtr __A, @NInt long __IA, IntPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixu8(ConstFloatPtr __A, @NInt long __IA, BytePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixu8D(ConstDoublePtr __A, @NInt long __IA, BytePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixu16(ConstFloatPtr __A, @NInt long __IA, CharPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixu16D(ConstDoublePtr __A, @NInt long __IA, CharPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixu32(ConstFloatPtr __A, @NInt long __IA, IntPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixu32D(ConstDoublePtr __A, @NInt long __IA, IntPtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector convert single precision to 24-bit integer with pre-scaling.
     * The scaled value is rounded toward zero.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsmfixu24(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B,
            @UncertainArgument("Options: reference, array Fallback: reference") vDSP_uint24 __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector convert single precision to 24-bit unsigned integer with pre-scaling.
     * The scaled value is rounded toward zero.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsmfix24(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B,
            @UncertainArgument("Options: reference, array Fallback: reference") vDSP_int24 __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector convert 24-bit integer to single-precision float.
     */
    @Generated
    @CFunction
    public static native void vDSP_vfltu24(
            @UncertainArgument("Options: reference, array Fallback: reference") vDSP_uint24 __A, @NInt long __IA,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vflt24(
            @UncertainArgument("Options: reference, array Fallback: reference") vDSP_int24 __A, @NInt long __IA,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector convert 24-bit integer to single-precision float and scale.
     */
    @Generated
    @CFunction
    public static native void vDSP_vfltsmu24(
            @UncertainArgument("Options: reference, array Fallback: reference") vDSP_uint24 __A, @NInt long __IA,
            ConstFloatPtr __B, FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfltsm24(
            @UncertainArgument("Options: reference, array Fallback: reference") vDSP_int24 __A, @NInt long __IA,
            ConstFloatPtr __B, FloatPtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector convert to integer, round to nearest.
     */
    @Generated
    @CFunction
    public static native void vDSP_vfixr8(ConstFloatPtr __A, @NInt long __IA, BytePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixr8D(ConstDoublePtr __A, @NInt long __IA, BytePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixr16(ConstFloatPtr __A, @NInt long __IA, ShortPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixr16D(ConstDoublePtr __A, @NInt long __IA, ShortPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixr32(ConstFloatPtr __A, @NInt long __IA, IntPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixr32D(ConstDoublePtr __A, @NInt long __IA, IntPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixru8(ConstFloatPtr __A, @NInt long __IA, BytePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixru8D(ConstDoublePtr __A, @NInt long __IA, BytePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixru16(ConstFloatPtr __A, @NInt long __IA, CharPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixru16D(ConstDoublePtr __A, @NInt long __IA, CharPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixru32(ConstFloatPtr __A, @NInt long __IA, IntPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfixru32D(ConstDoublePtr __A, @NInt long __IA, IntPtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector convert to floating-point from integer.
     */
    @Generated
    @CFunction
    public static native void vDSP_vflt8(
            @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String __A,
            @NInt long __IA, FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vflt8D(
            @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String __A,
            @NInt long __IA, DoublePtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vflt16(ConstShortPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vflt16D(ConstShortPtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vflt32(ConstIntPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vflt32D(ConstIntPtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfltu8(
            @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String __A,
            @NInt long __IA, FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfltu8D(
            @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String __A,
            @NInt long __IA, DoublePtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfltu16(ConstCharPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfltu16D(ConstCharPtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfltu32(ConstIntPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfltu32D(ConstIntPtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector fraction part (subtract integer toward zero).
     */
    @Generated
    @CFunction
    public static native void vDSP_vfrac(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vfracD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector gather.
     */
    @Generated
    @CFunction
    public static native void vDSP_vgathr(ConstFloatPtr __A, ConstNUIntPtr __B, @NInt long __IB, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vgathrD(ConstDoublePtr __A, ConstNUIntPtr __B, @NInt long __IB, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector gather, absolute pointers.
     */
    @Generated
    @CFunction
    public static native void vDSP_vgathra(ConstPtr<ConstFloatPtr> __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vgathraD(ConstPtr<ConstDoublePtr> __A, @NInt long __IA, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector generate tapered ramp.
     */
    @Generated
    @CFunction
    public static native void vDSP_vgen(ConstFloatPtr __A, ConstFloatPtr __B, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vgenD(ConstDoublePtr __A, ConstDoublePtr __B, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector generate by extrapolation and interpolation.
     */
    @Generated
    @CFunction
    public static native void vDSP_vgenp(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N, @NUInt long __M);

    @Generated
    @CFunction
    public static native void vDSP_vgenpD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N, @NUInt long __M);

    /**
     * Vector inverted clip.
     */
    @Generated
    @CFunction
    public static native void vDSP_viclip(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, ConstFloatPtr __C,
            FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_viclipD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, ConstDoublePtr __C,
            DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector index, C[i] = A[truncate[B[i]].
     */
    @Generated
    @CFunction
    public static native void vDSP_vindex(ConstFloatPtr __A, ConstFloatPtr __B, @NInt long __IB, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vindexD(ConstDoublePtr __A, ConstDoublePtr __B, @NInt long __IB, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector interpolation between vectors.
     */
    @Generated
    @CFunction
    public static native void vDSP_vintb(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vintbD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector test limit.
     */
    @Generated
    @CFunction
    public static native void vDSP_vlim(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, ConstFloatPtr __C,
            FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vlimD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, ConstDoublePtr __C,
            DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector linear interpolation.
     */
    @Generated
    @CFunction
    public static native void vDSP_vlint(ConstFloatPtr __A, ConstFloatPtr __B, @NInt long __IB, FloatPtr __C,
            @NInt long __IC, @NUInt long __N, @NUInt long __M);

    @Generated
    @CFunction
    public static native void vDSP_vlintD(ConstDoublePtr __A, ConstDoublePtr __B, @NInt long __IB, DoublePtr __C,
            @NInt long __IC, @NUInt long __N, @NUInt long __M);

    /**
     * Vector maxima.
     */
    @Generated
    @CFunction
    public static native void vDSP_vmax(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vmaxD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector maximum magnitude.
     */
    @Generated
    @CFunction
    public static native void vDSP_vmaxmg(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vmaxmgD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector sliding window maxima.
     */
    @Generated
    @CFunction
    public static native void vDSP_vswmax(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N, @NUInt long __WindowLength);

    @Generated
    @CFunction
    public static native void vDSP_vswmaxD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N, @NUInt long __WindowLength);

    /**
     * Vector minima.
     */
    @Generated
    @CFunction
    public static native void vDSP_vmin(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vminD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector minimum magnitude.
     */
    @Generated
    @CFunction
    public static native void vDSP_vminmg(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vminmgD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector multiply, multiply, and add.
     */
    @Generated
    @CFunction
    public static native void vDSP_vmma(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, ConstFloatPtr __D, @NInt long __ID, FloatPtr __E, @NInt long __IE,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vmmaD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, ConstDoublePtr __D, @NInt long __ID, DoublePtr __E, @NInt long __IE,
            @NUInt long __N);

    /**
     * Vector multiply, multiply, and subtract.
     */
    @Generated
    @CFunction
    public static native void vDSP_vmmsb(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, ConstFloatPtr __D, @NInt long __ID, FloatPtr __E, @NInt long __IE,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vmmsbD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, ConstDoublePtr __D, @NInt long __ID, DoublePtr __E, @NInt long __IE,
            @NUInt long __N);

    /**
     * Vector multiply and scalar add.
     */
    @Generated
    @CFunction
    public static native void vDSP_vmsa(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vmsaD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector multiply and subtract.
     */
    @Generated
    @CFunction
    public static native void vDSP_vmsb(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vmsbD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector negative absolute value.
     */
    @Generated
    @CFunction
    public static native void vDSP_vnabs(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vnabsD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector negate.
     */
    @Generated
    @CFunction
    public static native void vDSP_vneg(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vnegD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector polynomial.
     */
    @Generated
    @CFunction
    public static native void vDSP_vpoly(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_vpolyD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N, @NUInt long __P);

    /**
     * Vector Pythagoras.
     */
    @Generated
    @CFunction
    public static native void vDSP_vpythg(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, ConstFloatPtr __D, @NInt long __ID, FloatPtr __E, @NInt long __IE,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vpythgD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, ConstDoublePtr __D, @NInt long __ID, DoublePtr __E, @NInt long __IE,
            @NUInt long __N);

    /**
     * Vector quadratic interpolation.
     */
    @Generated
    @CFunction
    public static native void vDSP_vqint(ConstFloatPtr __A, ConstFloatPtr __B, @NInt long __IB, FloatPtr __C,
            @NInt long __IC, @NUInt long __N, @NUInt long __M);

    @Generated
    @CFunction
    public static native void vDSP_vqintD(ConstDoublePtr __A, ConstDoublePtr __B, @NInt long __IB, DoublePtr __C,
            @NInt long __IC, @NUInt long __N, @NUInt long __M);

    /**
     * Vector build ramp.
     */
    @Generated
    @CFunction
    public static native void vDSP_vramp(ConstFloatPtr __A, ConstFloatPtr __B, FloatPtr __C, @NInt long __IC,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vrampD(ConstDoublePtr __A, ConstDoublePtr __B, DoublePtr __C, @NInt long __IC,
            @NUInt long __N);

    /**
     * Vector running sum integration.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrsum(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __S, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vrsumD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __S, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector reverse order, in-place.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrvrs(FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vrvrsD(DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector subtract and multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsbm(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsbmD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector subtract, subtract, and multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsbsbm(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, @NInt long __IC, ConstFloatPtr __D, @NInt long __ID, FloatPtr __E, @NInt long __IE,
            @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsbsbmD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, @NInt long __IC, ConstDoublePtr __D, @NInt long __ID, DoublePtr __E, @NInt long __IE,
            @NUInt long __N);

    /**
     * Vector subtract and scalar multiply.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsbsm(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            ConstFloatPtr __C, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsbsmD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            ConstDoublePtr __C, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector Simpson integration.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsimps(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsimpsD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector-scalar multiply and vector add.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsma(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, ConstFloatPtr __C,
            @NInt long __IC, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsmaD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, ConstDoublePtr __C,
            @NInt long __IC, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector-scalar multiply and scalar add.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsmsa(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, ConstFloatPtr __C,
            FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsmsaD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, ConstDoublePtr __C,
            DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector scalar multiply and vector subtract.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsmsb(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, ConstFloatPtr __C,
            @NInt long __IC, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsmsbD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, ConstDoublePtr __C,
            @NInt long __IC, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector-scalar multiply, vector-scalar multiply and vector add.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsmsma(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, ConstFloatPtr __C,
            @NInt long __IC, ConstFloatPtr __D, FloatPtr __E, @NInt long __IE, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vsmsmaD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, ConstDoublePtr __C,
            @NInt long __IC, ConstDoublePtr __D, DoublePtr __E, @NInt long __IE, @NUInt long __N);

    /**
     * Vector sort, in-place.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsort(FloatPtr __C, @NUInt long __N, int __Order);

    @Generated
    @CFunction
    public static native void vDSP_vsortD(DoublePtr __C, @NUInt long __N, int __Order);

    /**
     * Vector sort indices, in-place.
     */
    @Generated
    @CFunction
    public static native void vDSP_vsorti(ConstFloatPtr __C, NUIntPtr __I, NUIntPtr __Temporary, @NUInt long __N,
            int __Order);

    @Generated
    @CFunction
    public static native void vDSP_vsortiD(ConstDoublePtr __C, NUIntPtr __I, NUIntPtr __Temporary, @NUInt long __N,
            int __Order);

    /**
     * Vector swap.
     */
    @Generated
    @CFunction
    public static native void vDSP_vswap(FloatPtr __A, @NInt long __IA, FloatPtr __B, @NInt long __IB, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vswapD(DoublePtr __A, @NInt long __IA, DoublePtr __B, @NInt long __IB,
            @NUInt long __N);

    /**
     * Vector sliding window sum.
     */
    @Generated
    @CFunction
    public static native void vDSP_vswsum(ConstFloatPtr __A, @NInt long __IA, FloatPtr __C, @NInt long __IC,
            @NUInt long __N, @NUInt long __P);

    @Generated
    @CFunction
    public static native void vDSP_vswsumD(ConstDoublePtr __A, @NInt long __IA, DoublePtr __C, @NInt long __IC,
            @NUInt long __N, @NUInt long __P);

    /**
     * Vector table lookup and interpolation.
     */
    @Generated
    @CFunction
    public static native void vDSP_vtabi(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __S1, ConstFloatPtr __S2,
            ConstFloatPtr __C, @NUInt long __M, FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vtabiD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __S1, ConstDoublePtr __S2,
            ConstDoublePtr __C, @NUInt long __M, DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector threshold.
     */
    @Generated
    @CFunction
    public static native void vDSP_vthr(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vthrD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector threshold with zero fill.
     */
    @Generated
    @CFunction
    public static native void vDSP_vthres(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vthresD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Vector threshold with signed constant.
     */
    @Generated
    @CFunction
    public static native void vDSP_vthrsc(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, ConstFloatPtr __C,
            FloatPtr __D, @NInt long __ID, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vthrscD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, ConstDoublePtr __C,
            DoublePtr __D, @NInt long __ID, @NUInt long __N);

    /**
     * Vector tapered merge.
     */
    @Generated
    @CFunction
    public static native void vDSP_vtmerg(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, @NInt long __IB,
            FloatPtr __C, @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vtmergD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, @NInt long __IB,
            DoublePtr __C, @NInt long __IC, @NUInt long __N);

    /**
     * Vector trapezoidal integration.
     */
    @Generated
    @CFunction
    public static native void vDSP_vtrapz(ConstFloatPtr __A, @NInt long __IA, ConstFloatPtr __B, FloatPtr __C,
            @NInt long __IC, @NUInt long __N);

    @Generated
    @CFunction
    public static native void vDSP_vtrapzD(ConstDoublePtr __A, @NInt long __IA, ConstDoublePtr __B, DoublePtr __C,
            @NInt long __IC, @NUInt long __N);

    /**
     * Wiener Levinson.
     */
    @Generated
    @CFunction
    public static native void vDSP_wiener(@NUInt long __L, ConstFloatPtr __A, ConstFloatPtr __C, FloatPtr __F,
            FloatPtr __P, int __Flag, IntPtr __Error);

    @Generated
    @CFunction
    public static native void vDSP_wienerD(@NUInt long __L, ConstDoublePtr __A, ConstDoublePtr __C, DoublePtr __F,
            DoublePtr __P, int __Flag, IntPtr __Error);

    /**
     * vDSP_FFT16_copv and vDSP_FFT32_copv perform 16- and 32-element FFTs on
     * interleaved complex unit-stride vector-block-aligned data.
     * <p>
     * Parameters:
     * <p>
     * float *Output
     * <p>
     * Pointer to space for output data (interleaved complex).  This
     * address must be vector-block aligned.
     * <p>
     * const float *Input
     * <p>
     * Pointer to input data (interleaved complex).  This address must be
     * vector-block aligned.
     * <p>
     * FFT_Direction Direction
     * <p>
     * Transform direction, FFT_FORWARD or FFT_INVERSE.
     * <p>
     * These routines calculate:
     * <p>
     * For 0 <= k < N,
     * <p>
     * H[k] = sum(1**(S * j*k/N) * h[j], 0 <= j < N),
     * <p>
     * where:
     * <p>
     * N is 16 or 32, as specified by the routine name,
     * <p>
     * h[j] is Input[2*j+0] + i * Input[2*j+1] at routine entry,
     * <p>
     * H[j] is Output[2*j+0] + i * Output[2*j+1] at routine exit,
     * <p>
     * S is -1 if Direction is FFT_FORWARD and +1 if Direction is FFT_INVERSE,
     * and
     * <p>
     * 1**x is e**(2*pi*i*x).
     * <p>
     * Input and Output may be equal but may not otherwise overlap.
     */
    @Generated
    @CFunction
    public static native void vDSP_FFT16_copv(FloatPtr __Output, ConstFloatPtr __Input, int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_FFT32_copv(FloatPtr __Output, ConstFloatPtr __Input, int __Direction);

    /**
     * vDSP_FFT16_zopv and vDSP_FFT32_zopv perform 16- and 32-element FFTs on
     * separated complex unit-stride vector-block-aligned data.
     * <p>
     * Parameters:
     * <p>
     * float *Or, float *Oi
     * <p>
     * Pointers to space for real and imaginary output data.  These
     * addresses must be vector-block aligned.
     * <p>
     * const float *Ir, *Ii
     * <p>
     * Pointers to real and imaginary input data.  These addresses must be
     * vector-block aligned.
     * <p>
     * FFT_Direction Direction
     * <p>
     * Transform direction, FFT_FORWARD or FFT_INVERSE.
     * <p>
     * These routines calculate:
     * <p>
     * For 0 <= k < N,
     * <p>
     * H[k] = sum(1**(S * j*k/N) * h[j], 0 <= j < N),
     * <p>
     * where:
     * <p>
     * N is 16 or 32, as specified by the routine name,
     * <p>
     * h[j] is Ir[j] + i * Ii[j] at routine entry,
     * <p>
     * H[j] is Or[j] + i * Oi[j] at routine exit,
     * <p>
     * S is -1 if Direction is FFT_FORWARD and +1 if Direction is FFT_INVERSE,
     * and
     * <p>
     * 1**x is e**(2*pi*i*x).
     * <p>
     * Or may equal Ir or Ii, and Oi may equal Ii or Ir, but the ararys may not
     * otherwise overlap.
     */
    @Generated
    @CFunction
    public static native void vDSP_FFT16_zopv(FloatPtr __Or, FloatPtr __Oi, ConstFloatPtr __Ir, ConstFloatPtr __Ii,
            int __Direction);

    @Generated
    @CFunction
    public static native void vDSP_FFT32_zopv(FloatPtr __Or, FloatPtr __Oi, ConstFloatPtr __Ir, ConstFloatPtr __Ii,
            int __Direction);

    /**
     * vDSP_DFT_CreateSetup is a DFT setup routine.  It creates a setup object
     * for use with the vDSP_DFT_zop execution routine.  We recommend you use
     * vDSP_DFT_zop_CreateSetup instead of this routine.
     * <p>
     * Parameters:
     * <p>
     * vDSP_DFT_Setup Previous
     * <p>
     * Previous is either zero or a previous DFT or DCT setup.  If a
     * previous setup is passed, the new setup will share data with the
     * previous setup, if feasible (and with any other setups the previous
     * setup shares with).  If zero is passed, the routine will allocate
     * and initialize new memory.
     * <p>
     * vDSP_Length Length
     * <p>
     * Length is the number of complex elements to be transformed.
     * <p>
     * Return value:
     * <p>
     * Zero is returned if memory is unavailable.
     * <p>
     * The returned setup object may be used only with vDSP_DFT_zop for the length
     * given during setup.  Unlike previous vDSP FFT routines, the setup may not
     * be used to execute transforms with shorter lengths.
     * <p>
     * Do not call this routine while any DFT routine sharing setup data might be
     * executing.
     */
    @Generated
    @CFunction
    public static native vDSP_DFT_Setup vDSP_DFT_CreateSetup(vDSP_DFT_Setup __Previous, @NUInt long __Length);

    /**
     * vDSP_DFT_zop_CreateSetup is a DFT setup routine.  It creates a setup object
     * for use with the vDSP_DFT_Execute execution routine, to perform a
     * complex-to-complex DFT.
     * <p>
     * Parameters:
     * <p>
     * vDSP_DFT_Setup Previous
     * <p>
     * Previous is either zero or a previous DFT or DCT setup.  If a
     * previous setup is passed, the new setup will share data with the
     * previous setup, if feasible (and with any other setups the previous
     * setup shares with).  If zero is passed, the routine will allocate
     * and initialize new memory.
     * <p>
     * vDSP_Length Length
     * <p>
     * Length is the number of complex elements to be transformed.
     * <p>
     * vDSP_DFT_Direction Direction
     * <p>
     * Transform direction, vDSP_DFT_FORWARD or vDSP_DFT_INVERSE.
     * <p>
     * Return value:
     * <p>
     * Zero is returned if memory is unavailable or if there is no
     * implementation for the requested case.  Currently, the implemented
     * cases are:
     * <p>
     * Length = 2**n.
     * <p>
     * Length = f * 2**n, where f is 3, 5, or 15 and 3 <= n.
     * <p>
     * Additionally, it is recommended that the array addresses (passed to
     * vDSP_DFT_Execute) be 16-byte aligned.  For other cases, performance may
     * be slightly or greatly worse, depending on transform length and
     * processor model.
     * <p>
     * Function:
     * <p>
     * When vDSP_DFT_Execute is called with a setup returned from this
     * routine, it calculates:
     * <p>
     * For 0 <= k < N,
     * <p>
     * H[k] = sum(1**(S * j*k/N) * h[j], 0 <= j < N),
     * <p>
     * where:
     * <p>
     * N is the length given in the setup;
     * <p>
     * h is the array of complex numbers specified by Ir and Ii when
     * vDSP_DFT_Execute is called:
     * <p>
     * for 0 <= j < N,
     * h[j] = Ir[j] + i * Ii[j];
     * <p>
     * H is the array of complex numbers specified by Or and Oi when
     * vDSP_DFT_Execute returns:
     * <p>
     * for 0 <= k < N,
     * H[k] = Or[k] + i * Oi[k];
     * <p>
     * S is -1 if Direction is vDSP_DFT_FORWARD and +1 if Direction is
     * vDSP_DFT_INVERSE; and
     * <p>
     * 1**x is e**(2*pi*i*x).
     * <p>
     * Performance:
     * <p>
     * Performance is good when the array addresses (passed to
     * vDSP_DFT_Execute) are 16-byte aligned.  Other alignments are supported,
     * but performance may be significantly worse in some cases, depending on
     * the processor model or the transform length (because different
     * algorithms are used for different forms of transform length).
     * <p>
     * In-Place Operation:
     * <p>
     * Or may equal Ir and Oi may equal Ii (in the call to vDSP_DFT_Execute).
     * Otherwise, no overlap of Or, Oi, Ir, and Ii is supported.
     * <p>
     * The returned setup object may be used only with vDSP_DFT_Execute for the
     * length given during setup.  Unlike previous vDSP FFT routines, the setup
     * may not be used to execute transforms with shorter lengths.
     * <p>
     * Do not call this routine while any DFT or DCT routine sharing setup data
     * might be executing.
     */
    @Generated
    @CFunction
    public static native vDSP_DFT_Setup vDSP_DFT_zop_CreateSetup(vDSP_DFT_Setup __Previous, @NUInt long __Length,
            int __Direction);

    @Generated
    @CFunction
    public static native vDSP_DFT_SetupD vDSP_DFT_zop_CreateSetupD(vDSP_DFT_SetupD __Previous, @NUInt long __Length,
            int __Direction);

    /**
     * vDSP_DFT_zrop_CreateSetup and vDSP_DFT_zrop_CreateSetupD are DFT setup
     * routines.  Each creates a setup object for use with the corresponding
     * execution routine, vDSP_DFT_Execute or vDSP_DFT_ExecuteD, to perform a
     * real-to-complex DFT or a complex-to-real DFT.  Documentation below is
     * written for vDSP_DFT_zrop_CreateSetup.  vDSP_DFT_CreateSetupD behaves the
     * same way, with corresponding changes of the types, objects, and routines to
     * the double-precision versions.
     * <p>
     * Parameters:
     * <p>
     * vDSP_DFT_Setup Previous
     * <p>
     * Previous is either zero or a previous DFT or DCT setup.  If a
     * previous setup is passed, the new setup will share data with the
     * previous setup, if feasible (and with any other setups the previous
     * setup shares with).  If zero is passed, the routine will allocate
     * and initialize new memory.
     * <p>
     * vDSP_Length Length
     * <p>
     * Length is the number of real elements to be transformed (in a a
     * forward, real-to-complex transform) or produced (in a reverse,
     * complex-to-real transform).  Length must be even.
     * <p>
     * vDSP_DFT_Direction Direction
     * <p>
     * Transform direction, vDSP_DFT_FORWARD or vDSP_DFT_INVERSE.
     * <p>
     * Return value:
     * <p>
     * Zero is returned if memory is unavailable or if there is no
     * implementation for the requested case.  Currently, the implemented
     * cases are:
     * <p>
     * Length = 2**n.
     * <p>
     * Length = f * 2**n, where f is 3, 5, or 15 and 4 <= n.
     * <p>
     * Additionally, it is recommended that the array addresses (passed to
     * vDSP_DFT_Execute) be 16-byte aligned.  For other cases, performance may
     * be slightly or greatly worse, depending on transform length and
     * processor model.
     * <p>
     * Function:
     * <p>
     * When vDSP_DFT_Execute is called with a setup returned from this
     * routine, it calculates:
     * <p>
     * For 0 <= k < N,
     * <p>
     * H[k] = C * sum(1**(S * j*k/N) * h[j], 0 <= j < N),
     * <p>
     * where:
     * <p>
     * N is the Length given in the setup;
     * <p>
     * h is the array of numbers specified by Ir and Ii when
     * vDSP_DFT_Execute is called (see "Data Layout" below);
     * <p>
     * H is the array of numbers specified by Or and Oi when
     * vDSP_DFT_Execute returns (see "Data Layout" below);
     * <p>
     * C is 2 if Direction is vDSP_DFT_FORWARD and 1 if Direction is
     * vDSP_DFT_INVERSE;
     * <p>
     * S is -1 if Direction is vDSP_DFT_FORWARD and +1 if Direction is
     * vDSP_DFT_INVERSE; and
     * <p>
     * 1**x is e**(2*pi*i*x).
     * <p>
     * Data Layout:
     * <p>
     * If Direction is vDSP_DFT_FORWARD, then:
     * <p>
     * h is an array of real numbers, with its even-index elements
     * stored in Ir and its odd-index elements stored in Ii:
     * <p>
     * For 0 <= j < N/2,
     * h[2*j+0] = Ir[j], and
     * h[2*j+1] = Ii[j].
     * <p>
     * H is an array of complex numbers, stored in Or and Oi:
     * <p>
     * H[0  ] = Or[0].  (H[0  ] is pure real.)
     * H[N/2] = Oi[0].  (H[N/2] is pure real.)
     * For 1 < k < N/2,
     * H[k] = Or[k] + i * Oi[k].
     * <p>
     * For N/2 < k < N, H[k] is not explicitly stored in memory but is
     * known because it necessarily equals the conjugate of H[N-k],
     * which is stored as described above.
     * <p>
     * If Direction is vDSP_DFT_INVERSE, then the layouts of the input and
     * output arrays are swapped.  Ir and Ii describe an input array with
     * complex elements laid out as described above for Or and Oi.  When
     * vDSP_DFT_Execute returns, Or and Oi contain a pure real array, with
     * its even-index elements stored in Or and its odd-index elements in
     * Oi.
     * <p>
     * Performance:
     * <p>
     * Performance is good when the array addresses (passed to
     * vDSP_DFT_Execute) are 16-byte aligned.  Other alignments are supported,
     * but performance may be significantly worse in some cases, depending on
     * the processor model or the transform length (because different
     * algorithms are used for different forms of transform length).
     * <p>
     * In-Place Operation:
     * <p>
     * Or may equal Ir and Oi may equal Ii (in the call to vDSP_DFT_Execute).
     * Otherwise, no overlap of Or, Oi, Ir, and Ii is supported.
     * <p>
     * The returned setup object may be used only with vDSP_DFT_Execute for the
     * length given during setup.  Unlike previous vDSP FFT routines, the setup
     * may not be used to execute transforms with shorter lengths.
     * <p>
     * Do not call this routine while any DFT routine sharing setup data might be
     * executing.
     */
    @Generated
    @CFunction
    public static native vDSP_DFT_Setup vDSP_DFT_zrop_CreateSetup(vDSP_DFT_Setup __Previous, @NUInt long __Length,
            int __Direction);

    @Generated
    @CFunction
    public static native vDSP_DFT_SetupD vDSP_DFT_zrop_CreateSetupD(vDSP_DFT_SetupD __Previous, @NUInt long __Length,
            int __Direction);

    /**
     * vDSP_DFT_DestroySetup and vDSP_DFT_DestroySetupD are DFT destroy routines.
     * They release the memory used by a setup object.  Documentation below is
     * written for vDSP_DFT_DestroySetup.  vDSP_DFT_DestroySetupD behaves the same
     * way, with corresponding changes of the types, objects, and routines to the
     * double-precision versions.
     * <p>
     * Parameters:
     * <p>
     * vDSP_DFT_Setup Setup
     * <p>
     * Setup is the setup object to be released.  The object may have
     * been previously allocated with any DFT or DCT setup routine, such
     * as vDSP_DFT_zop_CreateSetup, vDSP_DFT_zrop_CreateSetup, or
     * vDSP_DCT_CreateSetup.
     * <p>
     * Setup may be a null pointer, in which case the call has no effect.
     * <p>
     * Destroying a setup with shared data is safe; it will release only memory
     * not needed by other undestroyed setups.  Memory (and the data it contains)
     * is freed only when all setup objects using it have been destroyed.
     * <p>
     * Do not call this routine while any DFT or DCT routine sharing setup data
     * might be executing.
     */
    @Generated
    @CFunction
    public static native void vDSP_DFT_DestroySetup(vDSP_DFT_Setup __Setup);

    @Generated
    @CFunction
    public static native void vDSP_DFT_DestroySetupD(vDSP_DFT_SetupD __Setup);

    /**
     * vDSP_DFT_zop is a DFT execution routine.  It performs a DFT, with the aid
     * of previously created setup data.
     * <p>
     * Parameters:
     * <p>
     * vDSP_DFT_Setup Setup
     * <p>
     * A setup object returned by a previous call to
     * vDSP_DFT_zop_CreateSetup.
     * <p>
     * const float *Ir
     * const float *Ii
     * <p>
     * Pointers to real and imaginary components of input data.
     * <p>
     * vDSP_Stride Is
     * <p>
     * The number of physical elements from one logical input element to
     * the next.
     * <p>
     * float *Or
     * float *Oi
     * <p>
     * Pointers to space for real and imaginary components of output
     * data.
     * <p>
     * The input and output arrays may not overlap except as specified
     * in "In-Place Operation", below.
     * <p>
     * vDSP_Stride Os
     * <p>
     * The number of physical elements from one logical output element to
     * the next.
     * <p>
     * vDSP_DFT_Direction Direction
     * <p>
     * Transform direction, vDSP_DFT_FORWARD or vDSP_DFT_INVERSE.
     * <p>
     * Observe there is no separate length parameter.  The length is passed via
     * the setup object.
     * <p>
     * Performance:
     * <p>
     * Performance is good for these cases:
     * <p>
     * All addresses are 16-byte aligned, all strides are one, and the
     * length is f * 2**n, where f is 3, 5, or 15 and 3 <= n.
     * <p>
     * Performance is extremely slow for all other cases.
     * <p>
     * In-Place Operation:
     * <p>
     * For cases where the length is f * 2**n, where f is 3, 5, or 15 and 3 <=
     * n, Or may equal Ir and Oi may equal Ii.  Otherwise, no overlap of Or,
     * Oi, Ir, and Ii is supported.
     * <p>
     * This routine calculates:
     * <p>
     * For 0 <= k < N,
     * <p>
     * H[k] = sum(1**(S * j*k/N) * h[j], 0 <= j < N),
     * <p>
     * where:
     * <p>
     * N is the length given in the setup,
     * <p>
     * h is the array of complex numbers specified by Ir, Ii, and Is at
     * routine entry:
     * <p>
     * h[j] = Ir[j*Is] + i * Ii[j*Is],
     * for 0 <= j < N,
     * <p>
     * H is the array of complex numbers stored as specified by Or, Oi, and Os
     * at routine exit:
     * <p>
     * H[k] = Or[k*Os] + i * Oi[k*Os],
     * for 0 <= k < N,
     * <p>
     * S is -1 if Direction is vDSP_DFT_FORWARD and +1 if Direction is
     * vDSP_DFT_INVERSE, and
     * <p>
     * 1**x is e**(2*pi*i*x).
     * <p>
     * Do not call this routine while any DFT setup or destroy routine sharing
     * setup data might be executing.
     */
    @Generated
    @CFunction
    public static native void vDSP_DFT_zop(VoidPtr __Setup, ConstFloatPtr __Ir, ConstFloatPtr __Ii, @NInt long __Is,
            FloatPtr __Or, FloatPtr __Oi, @NInt long __Os, int __Direction);

    /**
     * vDSP_DFT_Execute and vDSP_DFT_ExecuteD are DFT execution routines.  They
     * perform a DFT, with the aid of previously created setup data.
     * Documentation below is written for vDSP_DFT_Execute.  vDSP_DFT_ExecuteD
     * behaves the same way, with corresponding changes of the types, objects, and
     * routines to the double-precision versions.
     * <p>
     * Parameters:
     * <p>
     * vDSP_DFT_Setup Setup
     * <p>
     * A setup object returned by a previous call to
     * vDSP_DFT_zop_CreateSetup or vDSP_DFT_zrop_CreateSetup.
     * <p>
     * const float *Ir
     * const float *Ii
     * <p>
     * Pointers to input data.
     * <p>
     * float *Or
     * float *Oi
     * <p>
     * Pointers to output data.
     * <p>
     * The input and output arrays may not overlap except as specified
     * in "In-Place Operation", below.
     * <p>
     * Performance and In-Place Operation:
     * <p>
     * See notes for the setup routine for the operation being executed.
     * <p>
     * Function:
     * <p>
     * The function performed by this routine is determined by the setup
     * passed to it.  The documentation for the routine used to create the
     * setup describes the function.
     * <p>
     * Note that different numbers of elements are required when this routine
     * is called, depending on the setup used:
     * <p>
     * When the setup is from vDSP_zop_CreateSetup, each array (Ir, Ii,
     * Or, and Oi) must have Length elements.
     * <p>
     * When the setup is from vDSP_zrop_CreateSetup, each array (Ir, Ii,
     * Or, and Oi) must have Length/2 elements.
     * <p>
     * Do not call this routine while any DFT setup or destroy routine sharing
     * setup data might be executing.
     */
    @Generated
    @CFunction
    public static native void vDSP_DFT_Execute(VoidPtr __Setup, ConstFloatPtr __Ir, ConstFloatPtr __Ii, FloatPtr __Or,
            FloatPtr __Oi);

    @Generated
    @CFunction
    public static native void vDSP_DFT_ExecuteD(VoidPtr __Setup, ConstDoublePtr __Ir, ConstDoublePtr __Ii,
            DoublePtr __Or, DoublePtr __Oi);

    @Generated
    @CFunction
    public static native vDSP_DFT_Setup vDSP_DCT_CreateSetup(vDSP_DFT_Setup __Previous, @NUInt long __Length,
            int __Type);

    /**
     * vDSP_DCT_Execute is a DCT execution routine.  It performs a DCT, with the
     * aid of previously created setup data.  See additional information above, at
     * "How to use the Discrete Fourier Transform (DFT) and Discrete Cosine
     * Transform (DCT) interfaces."
     * <p>
     * Parameters:
     * <p>
     * vDSP_DFT_Setup Setup
     * <p>
     * A setup object returned by a previous call to vDSP_DCT_CreateSetup.
     * <p>
     * const float *Input
     * <p>
     * Pointer to the input buffer.
     * <p>
     * float *Output
     * <p>
     * Pointer to the output buffer.
     * <p>
     * Observe there are no separate length or type parameters.  They are
     * specified at the time that the Setup is created.
     * <p>
     * Because the DCT is real-to-real, the parameters for vDSP_DCT_Execute
     * are different from those used for a DFT.
     */
    @Generated
    @CFunction
    public static native void vDSP_DCT_Execute(VoidPtr __Setup, ConstFloatPtr __Input, FloatPtr __Output);

    /**
     * vDSP_dotpr2, vector single-precision stereo dot product.
     * <p>
     * Function:
     * <p>
     * This routine calculates the dot product of A0 with B and the dot
     * product of A1 with B.  This is functionally equivalent to calculating
     * two dot products but might execute faster.
     * <p>
     * In pseudocode, the operation is:
     * <p>
     * sum0 = 0;
     * sum1 = 0;
     * for (i = 0; i < Length; ++i)
     * {
     * sum0 += A0[i*A0Stride] * B[i*BStride];
     * sum1 += A1[i*A1Stride] * B[i*BStride];
     * }
     * *C0 = sum0;
     * *C1 = sum1;
     * <p>
     * Input:
     * <p>
     * const float *A0, vDSP_Stride A0Stride.
     * <p>
     * Starting address and stride for input vector A0.
     * <p>
     * const float *A1, vDSP_Stride A1Stride.
     * <p>
     * Starting address and stride for input vector A1.
     * <p>
     * const float *B,  vDSP_Stride BStride.
     * <p>
     * Starting address and stride for input vector B.
     * <p>
     * float *C0.
     * <p>
     * Address for dot product of A0 and B.
     * <p>
     * float *C1.
     * <p>
     * Address for dot product of A1 and B.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to *C0 and *C1.
     */
    @Generated
    @CFunction
    public static native void vDSP_dotpr2(ConstFloatPtr __A0, @NInt long __IA0, ConstFloatPtr __A1, @NInt long __IA1,
            ConstFloatPtr __B, @NInt long __IB, FloatPtr __C0, FloatPtr __C1, @NUInt long __N);

    /**
     * vDSP_dotpr2D, vector double-precision stereo dot product.
     * <p>
     * Function:
     * <p>
     * This routine calculates the dot product of A0 with B and the dot
     * product of A1 with B.  This is functionally equivalent to calculating
     * two dot products but might execute faster.
     * <p>
     * In pseudocode, the operation is:
     * <p>
     * sum0 = 0;
     * sum1 = 0;
     * for (i = 0; i < Length; ++i)
     * {
     * sum0 += A0[i*A0Stride] * B[i*BStride];
     * sum1 += A1[i*A1Stride] * B[i*BStride];
     * }
     * *C0 = sum0;
     * *C1 = sum1;
     * <p>
     * Input:
     * <p>
     * const double *A0, vDSP_Stride A0Stride.
     * <p>
     * Starting address and stride for input vector A0.
     * <p>
     * const double *A1, vDSP_Stride A1Stride.
     * <p>
     * Starting address and stride for input vector A1.
     * <p>
     * const double *B,  vDSP_Stride BStride.
     * <p>
     * Starting address and stride for input vector B.
     * <p>
     * double *C0.
     * <p>
     * Address for dot product of A0 and B.
     * <p>
     * double *C1.
     * <p>
     * Address for dot product of A1 and B.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to *C0 and *C1.
     */
    @Generated
    @CFunction
    public static native void vDSP_dotpr2D(ConstDoublePtr __A0, @NInt long __IA0, ConstDoublePtr __A1, @NInt long __IA1,
            ConstDoublePtr __B, @NInt long __IB, DoublePtr __C0, DoublePtr __C1, @NUInt long __N);

    /**
     * vDSP_dotpr_s1_15, vector integer 1.15 format dot product.
     * <p>
     * Function:
     * <p>
     * This routine calculates the dot product of A with B.
     * <p>
     * In pseudocode, the operation is:
     * <p>
     * sum = 0;
     * for (i = 0; i < N; ++i)
     * {
     * sum0 += A[i*AStride] * B[i*BStride];
     * }
     * *C = sum;
     * <p>
     * The elements are fixed-point numbers, each with one sign bit and 15
     * fraction bits.  Where the value of the short int is normally x, it is
     * x/32768 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const short int *A, vDSP_Stride AStride.
     * <p>
     * Starting address and stride for input vector A.
     * <p>
     * const short int *B,  vDSP_Stride BStride.
     * <p>
     * Starting address and stride for input vector B.
     * <p>
     * short int *C.
     * <p>
     * Address for dot product of A and B.
     * <p>
     * vDSP_Length N.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The result is written to *C.
     */
    @Generated
    @CFunction
    public static native void vDSP_dotpr_s1_15(ConstShortPtr __A, @NInt long __IA, ConstShortPtr __B, @NInt long __IB,
            ShortPtr __C, @NUInt long __N);

    /**
     * vDSP_dotpr2_s1_15, vector integer 1.15 format stereo dot product.
     * <p>
     * Function:
     * <p>
     * This routine calculates the dot product of A0 with B and the dot
     * product of A1 with B.  This is functionally equivalent to calculating
     * two dot products but might execute faster.
     * <p>
     * In pseudocode, the operation is:
     * <p>
     * sum0 = 0;
     * sum1 = 0;
     * for (i = 0; i < N; ++i)
     * {
     * sum0 += A0[i*A0Stride] * B[i*BStride];
     * sum1 += A1[i*A1Stride] * B[i*BStride];
     * }
     * *C0 = sum0;
     * *C1 = sum1;
     * <p>
     * The elements are fixed-point numbers, each with one sign bit and 15
     * fraction bits.  Where the value of the short int is normally x, it is
     * x/32768 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const short int *A0, vDSP_Stride A0Stride.
     * <p>
     * Starting address and stride for input vector A0.
     * <p>
     * const short int *A1, vDSP_Stride A1Stride.
     * <p>
     * Starting address and stride for input vector A1.
     * <p>
     * const short int *B,  vDSP_Stride BStride.
     * <p>
     * Starting address and stride for input vector B.
     * <p>
     * short int *C0.
     * <p>
     * Address for dot product of A0 and B.
     * <p>
     * short int *C1.
     * <p>
     * Address for dot product of A1 and B.
     * <p>
     * vDSP_Length N.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to *C0 and *C1.
     */
    @Generated
    @CFunction
    public static native void vDSP_dotpr2_s1_15(ConstShortPtr __A0, @NInt long __IA0, ConstShortPtr __A1,
            @NInt long __IA1, ConstShortPtr __B, @NInt long __IB, ShortPtr __C0, ShortPtr __C1, @NUInt long __N);

    /**
     * vDSP_dotpr_s8_24, vector integer 8.24 format dot product.
     * <p>
     * Function:
     * <p>
     * This routine calculates the dot product of A with B.
     * <p>
     * In pseudocode, the operation is:
     * <p>
     * sum = 0;
     * for (i = 0; i < N; ++i)
     * {
     * sum0 += A[i*AStride] * B[i*BStride];
     * }
     * *C = sum;
     * <p>
     * The elements are fixed-point numbers, each with eight integer bits
     * (including sign) and 24 fraction bits.  Where the value of the int is
     * normally x, it is x/16777216 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const int *A, vDSP_Stride AStride.
     * <p>
     * Starting address and stride for input vector A.
     * <p>
     * const int *B,  vDSP_Stride BStride.
     * <p>
     * Starting address and stride for input vector B.
     * <p>
     * int *C.
     * <p>
     * Address for dot product of A and B.
     * <p>
     * vDSP_Length N.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The result is written to *C.
     */
    @Generated
    @CFunction
    public static native void vDSP_dotpr_s8_24(ConstIntPtr __A, @NInt long __IA, ConstIntPtr __B, @NInt long __IB,
            IntPtr __C, @NUInt long __N);

    /**
     * vDSP_dotpr2_s8_24, vector integer 8.24 format stereo dot product.
     * <p>
     * Function:
     * <p>
     * This routine calculates the dot product of A0 with B and the dot
     * product of A1 with B.  This is functionally equivalent to calculating
     * two dot products but might execute faster.
     * <p>
     * In pseudocode, the operation is:
     * <p>
     * sum0 = 0;
     * sum1 = 0;
     * for (i = 0; i < N; ++i)
     * {
     * sum0 += A0[i*A0Stride] * B[i*BStride];
     * sum1 += A1[i*A1Stride] * B[i*BStride];
     * }
     * *C0 = sum0;
     * *C1 = sum1;
     * <p>
     * The elements are fixed-point numbers, each with eight integer bits
     * (including sign) and 24 fraction bits.  Where the value of the int is
     * normally x, it is x/16777216 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const int *A0, vDSP_Stride A0Stride.
     * <p>
     * Starting address and stride for input vector A0.
     * <p>
     * const int *A1, vDSP_Stride A1Stride.
     * <p>
     * Starting address and stride for input vector A1.
     * <p>
     * const int *B,  vDSP_Stride BStride.
     * <p>
     * Starting address and stride for input vector B.
     * <p>
     * int *C0.
     * <p>
     * Address for dot product of A0 and B.
     * <p>
     * int *C1.
     * <p>
     * Address for dot product of A1 and B.
     * <p>
     * vDSP_Length N.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to *C0 and *C1.
     */
    @Generated
    @CFunction
    public static native void vDSP_dotpr2_s8_24(ConstIntPtr __A0, @NInt long __IA0, ConstIntPtr __A1, @NInt long __IA1,
            ConstIntPtr __B, @NInt long __IB, IntPtr __C0, IntPtr __C1, @NUInt long __N);

    /**
     * vDSP_vaddsub, vector single-precision add and subtract.
     * <p>
     * Adds vector I0 to vector I1 and leaves the result in vector O0.
     * Subtracts vector I0 from vector I1 and leaves the result in vector O1.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * float i1 = I1[i*I1S], i0 = I0[i*I0S];
     * O0[i*O0S] = i1 + i0;
     * O1[i*O1S] = i1 - i0;
     * }
     * <p>
     * Input:
     * <p>
     * const float *I0, const float *I1, vDSP_Stride I0S, vDSP_Stride I1S.
     * <p>
     * Starting addresses of both inputs and strides for the input vectors.
     * <p>
     * float *O0, float *O1, vDSP_Stride O0S, vDSP_Stride O1S.
     * <p>
     * Starting addresses of both outputs and strides for the output vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O0 and O1.
     * <p>
     * In-Place Operation:
     * <p>
     * Either of O0 and/or O1 may equal I0 and/or I1, but O0 may not equal
     * O1.  Otherwise, no overlap is permitted between any of the buffers.
     */
    @Generated
    @CFunction
    public static native void vDSP_vaddsub(ConstFloatPtr __I0, @NInt long __I0S, ConstFloatPtr __I1, @NInt long __I1S,
            FloatPtr __O0, @NInt long __O0S, FloatPtr __O1, @NInt long __O1S, @NUInt long __N);

    /**
     * vDSP_vaddsubD, vector double-precision add and subtract.
     * <p>
     * Adds vector I0 to vector I1 and leaves the result in vector O0.
     * Subtracts vector I0 from vector I1 and leaves the result in vector O1.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * double i1 = I1[i*I1S], i0 = I0[i*I0S];
     * O0[i*O0S] = i1 + i0;
     * O1[i*O1S] = i1 - i0;
     * }
     * <p>
     * Input:
     * <p>
     * const double *I0, const double *I1, vDSP_Stride I0S, vDSP_Stride I1S.
     * <p>
     * Starting addresses of both inputs and strides for the input vectors.
     * <p>
     * double *O0, double *O1, vDSP_Stride O0S, vDSP_Stride O1S.
     * <p>
     * Starting addresses of both outputs and strides for the output vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O0 and O1.
     * <p>
     * In-Place Operation:
     * <p>
     * Either of O0 and/or O1 may equal I0 and/or I1, but O0 may not equal
     * O1.  Otherwise, no overlap is permitted between any of the buffers.
     */
    @Generated
    @CFunction
    public static native void vDSP_vaddsubD(ConstDoublePtr __I0, @NInt long __I0S, ConstDoublePtr __I1,
            @NInt long __I1S, DoublePtr __O0, @NInt long __O0S, DoublePtr __O1, @NInt long __O1S, @NUInt long __N);

    /**
     * vDSP_vrampmul, vector single-precision vramp and multiply.
     * <p>
     * This routine puts into O the product of I and a ramp function with initial
     * value *Start and slope *Step.  *Start is updated to continue the ramp
     * in a consecutive call.  To continue the ramp smoothly, the new value of
     * *Step includes rounding errors accumulated during the routine rather than
     * being calculated directly as *Start + N * *Step.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O[i*OS] = *Start * I[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * Input:
     * <p>
     * const float *I, vDSP_Stride IS.
     * <p>
     * Starting address and stride for the input vector.
     * <p>
     * float *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const float *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * float *O, vDSP_Stride OS.
     * <p>
     * Starting address and stride for the output vector.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmul(ConstFloatPtr __I, @NInt long __IS, FloatPtr __Start, ConstFloatPtr __Step,
            FloatPtr __O, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmulD, vector double-precision vramp and multiply.
     * <p>
     * This routine puts into O the product of I and a ramp function with initial
     * value *Start and slope *Step.  *Start is updated to continue the ramp
     * in a consecutive call.  To continue the ramp smoothly, the new value of
     * *Step includes rounding errors accumulated during the routine rather than
     * being calculated directly as *Start + N * *Step.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O[i*OS] = *Start * I[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * Input:
     * <p>
     * const double *I, vDSP_Stride IS.
     * <p>
     * Starting address and stride for the input vector.
     * <p>
     * double *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const double *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * double *O, vDSP_Stride OS.
     * <p>
     * Starting address and stride for the output vector.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmulD(ConstDoublePtr __I, @NInt long __IS, DoublePtr __Start,
            ConstDoublePtr __Step, DoublePtr __O, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmuladd, vector single-precision vramp, multiply and add.
     * <p>
     * This routine adds to O the product of I and a ramp function with initial
     * value *Start and slope *Step.  *Start is updated to continue the ramp in a
     * consecutive call.  To continue the ramp smoothly, the new value of *Step
     * includes rounding errors accumulated during the routine rather than being
     * calculated directly as *Start + N * *Step.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O[i*OS] += *Start * I[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * Input:
     * <p>
     * const float *I, vDSP_Stride IS.
     * <p>
     * Starting address and stride for the input vector.
     * <p>
     * float *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const float *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * float *O, vDSP_Stride OS.
     * <p>
     * Starting address and stride for the output vector.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are added to O.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmuladd(ConstFloatPtr __I, @NInt long __IS, FloatPtr __Start,
            ConstFloatPtr __Step, FloatPtr __O, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmuladdD, vector double-precision vramp, multiply and add.
     * <p>
     * This routine adds to O the product of I and a ramp function with initial
     * value *Start and slope *Step.  *Start is updated to continue the ramp in a
     * consecutive call.  To continue the ramp smoothly, the new value of *Step
     * includes rounding errors accumulated during the routine rather than being
     * calculated directly as *Start + N * *Step.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O[i*OS] += *Start * I[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * Input:
     * <p>
     * const double *I, vDSP_Stride IS.
     * <p>
     * Starting address and stride for the input vector.
     * <p>
     * double *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const double *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * double *O, vDSP_Stride OS.
     * <p>
     * Starting address and stride for the output vector.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are added to O.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmuladdD(ConstDoublePtr __I, @NInt long __IS, DoublePtr __Start,
            ConstDoublePtr __Step, DoublePtr __O, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmul2, stereo vector single-precision vramp and multiply.
     * <p>
     * This routine:
     * <p>
     * Puts into O0 the product of I0 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * Puts into O1 the product of I1 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * *Start is updated to continue the ramp in a consecutive call.  To continue
     * the ramp smoothly, the new value of *Step includes rounding errors
     * accumulated during the routine rather than being calculated directly as
     * *Start + N * *Step.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O0[i*OS] = *Start * I0[i*IS];
     * O1[i*OS] = *Start * I1[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * Input:
     * <p>
     * const float *I0, const float *I1, vDSP_Stride IS.
     * <p>
     * Starting addresses of both inputs and stride for the input vectors.
     * <p>
     * float *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const float *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * float *O0, float *O1, vDSP_Stride OS.
     * <p>
     * Starting addresses of both outputs and stride for the output vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O0 and O1.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmul2(ConstFloatPtr __I0, ConstFloatPtr __I1, @NInt long __IS, FloatPtr __Start,
            ConstFloatPtr __Step, FloatPtr __O0, FloatPtr __O1, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmul2D, stereo vector double-precision vramp and multiply.
     * <p>
     * This routine:
     * <p>
     * Puts into O0 the product of I0 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * Puts into O1 the product of I1 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * *Start is updated to continue the ramp in a consecutive call.  To continue
     * the ramp smoothly, the new value of *Step includes rounding errors
     * accumulated during the routine rather than being calculated directly as
     * *Start + N * *Step.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O0[i*OS] = *Start * I0[i*IS];
     * O1[i*OS] = *Start * I1[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * Input:
     * <p>
     * const double *I0, const double *I1, vDSP_Stride IS.
     * <p>
     * Starting addresses of both inputs and stride for the input vectors.
     * <p>
     * double *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const double *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * double *O0, double *O1, vDSP_Stride OS.
     * <p>
     * Starting addresses of both outputs and stride for the output vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O0 and O1.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmul2D(ConstDoublePtr __I0, ConstDoublePtr __I1, @NInt long __IS,
            DoublePtr __Start, ConstDoublePtr __Step, DoublePtr __O0, DoublePtr __O1, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmuladd2, stereo vector single-precision vramp, multiply and add.
     * <p>
     * This routine:
     * <p>
     * Adds to O0 the product of I0 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * Adds to O1 the product of I1 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * *Start is updated to continue the ramp in a consecutive call.  To continue
     * the ramp smoothly, the new value of *Step includes rounding errors
     * accumulated during the routine rather than being calculated directly as
     * *Start + N * *Step.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O0[i*OS] += *Start * I0[i*IS];
     * O1[i*OS] += *Start * I1[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * Input:
     * <p>
     * const float *I0, const float *I1, vDSP_Stride IS.
     * <p>
     * Starting addresses of both inputs and stride for the input vectors.
     * <p>
     * float *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const float *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * float *O0, float *O1, vDSP_Stride OS.
     * <p>
     * Starting addresses of both outputs and stride for the output vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O0 and O1.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmuladd2(ConstFloatPtr __I0, ConstFloatPtr __I1, @NInt long __IS,
            FloatPtr __Start, ConstFloatPtr __Step, FloatPtr __O0, FloatPtr __O1, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmuladd2D, stereo vector double-precision vramp, multiply and add.
     * <p>
     * This routine:
     * <p>
     * Adds to O0 the product of I0 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * Adds to O1 the product of I1 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * *Start is updated to continue the ramp in a consecutive call.  To continue
     * the ramp smoothly, the new value of *Step includes rounding errors
     * accumulated during the routine rather than being calculated directly as
     * *Start + N * *Step.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O0[i*OS] += *Start * I0[i*IS];
     * O1[i*OS] += *Start * I1[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * Input:
     * <p>
     * const double *I0, const double *I1, vDSP_Stride IS.
     * <p>
     * Starting addresses of both inputs and stride for the input vectors.
     * <p>
     * double *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const double *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * double *O0, double *O1, vDSP_Stride OS.
     * <p>
     * Starting addresses of both outputs and stride for the output vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O0 and O1.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmuladd2D(ConstDoublePtr __I0, ConstDoublePtr __I1, @NInt long __IS,
            DoublePtr __Start, ConstDoublePtr __Step, DoublePtr __O0, DoublePtr __O1, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmul_s1_15, vector integer 1.15 format vramp and multiply.
     * <p>
     * This routine puts into O the product of I and a ramp function with initial
     * value *Start and slope *Step.  *Start is updated to continue the ramp
     * in a consecutive call.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O[i*OS] = *Start * I[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * The elements are fixed-point numbers, each with one sign bit and 15
     * fraction bits.  Where the value of the short int is normally x, it is
     * x/32768 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const short int *I, vDSP_Stride IS.
     * <p>
     * Starting address and stride for the input vector.
     * <p>
     * short int *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const short int *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * short int *O, vDSP_Stride OS.
     * <p>
     * Starting address and stride for the output vector.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmul_s1_15(ConstShortPtr __I, @NInt long __IS, ShortPtr __Start,
            ConstShortPtr __Step, ShortPtr __O, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmuladd_s1_15, vector integer 1.15 format vramp, multiply and add.
     * <p>
     * This routine adds to O the product of I and a ramp function with initial
     * value *Start and slope *Step.  *Start is updated to continue the ramp in a
     * consecutive call.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O[i*OS] += *Start * I[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * The elements are fixed-point numbers, each with one sign bit and 15
     * fraction bits.  Where the value of the short int is normally x, it is
     * x/32768 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const short int *I, vDSP_Stride IS.
     * <p>
     * Starting address and stride for the input vector.
     * <p>
     * short int *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const short int *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * short int *O, vDSP_Stride OS.
     * <p>
     * Starting address and stride for the output vector.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are added to O.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmuladd_s1_15(ConstShortPtr __I, @NInt long __IS, ShortPtr __Start,
            ConstShortPtr __Step, ShortPtr __O, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmul2_s1_15, stereo vector integer 1.15 format vramp and multiply.
     * <p>
     * This routine:
     * <p>
     * Puts into O0 the product of I0 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * Puts into O1 the product of I1 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * *Start is updated to continue the ramp in a consecutive call.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O0[i*OS] = *Start * I0[i*IS];
     * O1[i*OS] = *Start * I1[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * The elements are fixed-point numbers, each with one sign bit and 15
     * fraction bits.  Where the value of the short int is normally x, it is
     * x/32768 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const short int *I0, const short int *I1, vDSP_Stride IS.
     * <p>
     * Starting addresses of both inputs and stride for the input vectors.
     * <p>
     * short int *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const short int *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * short int *O0, short int *O1, vDSP_Stride OS.
     * <p>
     * Starting addresses of both outputs and stride for the output
     * vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O0 and O1.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmul2_s1_15(ConstShortPtr __I0, ConstShortPtr __I1, @NInt long __IS,
            ShortPtr __Start, ConstShortPtr __Step, ShortPtr __O0, ShortPtr __O1, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmuladd2_s1_15, stereo vector integer 1.15 format vramp, multiply
     * and add.
     * <p>
     * This routine:
     * <p>
     * Adds to O0 the product of I0 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * Adds to O1 the product of I1 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * *Start is updated to continue the ramp in a consecutive call.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O0[i*OS] += *Start * I0[i*IS];
     * O1[i*OS] += *Start * I1[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * The elements are fixed-point numbers, each with one sign bit and 15
     * fraction bits.  Where the value of the short int is normally x, it is
     * x/32768 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const short int *I0, const short int *I1, vDSP_Stride IS.
     * <p>
     * Starting addresses of both inputs and stride for the input vectors.
     * <p>
     * short int *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const short int *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * short int *O0, short int *O1, vDSP_Stride OS.
     * <p>
     * Starting addresses of both outputs and stride for the output
     * vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are added to O0 and O1.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmuladd2_s1_15(ConstShortPtr __I0, ConstShortPtr __I1, @NInt long __IS,
            ShortPtr __Start, ConstShortPtr __Step, ShortPtr __O0, ShortPtr __O1, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmul_s8_24, vector integer 8.24 format vramp and multiply.
     * <p>
     * This routine puts into O the product of I and a ramp function with initial
     * value *Start and slope *Step.  *Start is updated to continue the ramp
     * in a consecutive call.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O[i*OS] = *Start * I[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * The elements are fixed-point numbers, each with eight integer bits
     * (including sign) and 24 fraction bits.  Where the value of the int is
     * normally x, it is x/16777216 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const int *I, vDSP_Stride IS.
     * <p>
     * Starting address and stride for the input vector.
     * <p>
     * int *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const int *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * int *O, vDSP_Stride OS.
     * <p>
     * Starting address and stride for the output vector.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmul_s8_24(ConstIntPtr __I, @NInt long __IS, IntPtr __Start, ConstIntPtr __Step,
            IntPtr __O, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmuladd_s8_24, vector integer 8.24 format vramp, multiply and add.
     * <p>
     * This routine adds to O the product of I and a ramp function with initial
     * value *Start and slope *Step.  *Start is updated to continue the ramp in a
     * consecutive call.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O[i*OS] += *Start * I[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * The elements are fixed-point numbers, each with eight integer bits
     * (including sign) and 24 fraction bits.  Where the value of the int is
     * normally x, it is x/16777216 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const int *I, vDSP_Stride IS.
     * <p>
     * Starting address and stride for the input vector.
     * <p>
     * int *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const int *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * int *O, vDSP_Stride OS.
     * <p>
     * Starting address and stride for the output vector.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are added to O.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmuladd_s8_24(ConstIntPtr __I, @NInt long __IS, IntPtr __Start,
            ConstIntPtr __Step, IntPtr __O, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmul2_s8_24, stereo vector integer 8.24 format vramp and multiply.
     * <p>
     * This routine:
     * <p>
     * Puts into O0 the product of I0 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * Puts into O1 the product of I1 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * *Start is updated to continue the ramp in a consecutive call.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O0[i*OS] = *Start * I0[i*IS];
     * O1[i*OS] = *Start * I1[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * The elements are fixed-point numbers, each with eight integer bits
     * (including sign) and 24 fraction bits.  Where the value of the int is
     * normally x, it is x/16777216 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const int *I0, const int *I1, vDSP_Stride IS.
     * <p>
     * Starting addresses of both inputs and stride for the input vectors.
     * <p>
     * int *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const int *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * int *O0, int *O1, vDSP_Stride OS.
     * <p>
     * Starting addresses of both outputs and stride for the output
     * vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O0 and O1.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmul2_s8_24(ConstIntPtr __I0, ConstIntPtr __I1, @NInt long __IS, IntPtr __Start,
            ConstIntPtr __Step, IntPtr __O0, IntPtr __O1, @NInt long __OS, @NUInt long __N);

    /**
     * vDSP_vrampmuladd2_s8_24, stereo vector integer 8.24 format vramp, multiply
     * and add.
     * <p>
     * This routine:
     * <p>
     * Adds to O0 the product of I0 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * Adds to O1 the product of I1 and a ramp function with initial value
     * *Start and slope *Step.
     * <p>
     * *Start is updated to continue the ramp in a consecutive call.
     * <p>
     * This routine calculates:
     * <p>
     * for (i = 0; i < N; ++i)
     * {
     * O0[i*OS] += *Start * I0[i*IS];
     * O1[i*OS] += *Start * I1[i*IS];
     * *Start += *Step;
     * }
     * <p>
     * The elements are fixed-point numbers, each with eight integer bits
     * (including sign) and 24 fraction bits.  Where the value of the int is
     * normally x, it is x/16777216 for the purposes of this routine.
     * <p>
     * Input:
     * <p>
     * const int *I0, const int *I1, vDSP_Stride IS.
     * <p>
     * Starting addresses of both inputs and stride for the input vectors.
     * <p>
     * int *Start.
     * <p>
     * Starting value for the ramp.
     * <p>
     * const int *Step.
     * <p>
     * Value of the step for the ramp.
     * <p>
     * int *O0, int *O1, vDSP_Stride OS.
     * <p>
     * Starting addresses of both outputs and stride for the output
     * vectors.
     * <p>
     * vDSP_Length Length.
     * <p>
     * Number of elements in each vector.
     * <p>
     * Output:
     * <p>
     * The results are written to O0 and O1.
     * <p>
     * On return, *Start contains initial *Start + N * *Step.
     */
    @Generated
    @CFunction
    public static native void vDSP_vrampmuladd2_s8_24(ConstIntPtr __I0, ConstIntPtr __I1, @NInt long __IS,
            IntPtr __Start, ConstIntPtr __Step, IntPtr __O0, IntPtr __O1, @NInt long __OS, @NUInt long __N);

    @Generated
    @Variadic()
    @CFunction
    public static native int cblas_errprn(int __ierr, int __info, BytePtr __form, Object... varargs);

    @Generated
    @Variadic()
    @CFunction
    public static native void cblas_xerbla(int __p, BytePtr __rout, BytePtr __form, Object... varargs);

    /**
     * ===========================================================================
     * Prototypes for level 1 BLAS functions (complex are recast as routines)
     * ===========================================================================
     */
    @Generated
    @CFunction
    public static native float cblas_sdsdot(int __N, float __alpha, ConstFloatPtr __X, int __incX, ConstFloatPtr __Y,
            int __incY);

    @Generated
    @CFunction
    public static native double cblas_dsdot(int __N, ConstFloatPtr __X, int __incX, ConstFloatPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native float cblas_sdot(int __N, ConstFloatPtr __X, int __incX, ConstFloatPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native double cblas_ddot(int __N, ConstDoublePtr __X, int __incX, ConstDoublePtr __Y, int __incY);

    /**
     * Functions having prefixes Z and C only
     */
    @Generated
    @CFunction
    public static native void cblas_cdotu_sub(int __N, ConstVoidPtr __X, int __incX, ConstVoidPtr __Y, int __incY,
            VoidPtr __dotu);

    @Generated
    @CFunction
    public static native void cblas_cdotc_sub(int __N, ConstVoidPtr __X, int __incX, ConstVoidPtr __Y, int __incY,
            VoidPtr __dotc);

    @Generated
    @CFunction
    public static native void cblas_zdotu_sub(int __N, ConstVoidPtr __X, int __incX, ConstVoidPtr __Y, int __incY,
            VoidPtr __dotu);

    @Generated
    @CFunction
    public static native void cblas_zdotc_sub(int __N, ConstVoidPtr __X, int __incX, ConstVoidPtr __Y, int __incY,
            VoidPtr __dotc);

    /**
     * Functions having prefixes S D SC DZ
     */
    @Generated
    @CFunction
    public static native float cblas_snrm2(int __N, ConstFloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native float cblas_sasum(int __N, ConstFloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native double cblas_dnrm2(int __N, ConstDoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native double cblas_dasum(int __N, ConstDoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native float cblas_scnrm2(int __N, ConstVoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native float cblas_scasum(int __N, ConstVoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native double cblas_dznrm2(int __N, ConstVoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native double cblas_dzasum(int __N, ConstVoidPtr __X, int __incX);

    /**
     * Functions having standard 4 prefixes (S D C Z)
     */
    @Generated
    @CFunction
    public static native int cblas_isamax(int __N, ConstFloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native int cblas_idamax(int __N, ConstDoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native int cblas_icamax(int __N, ConstVoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native int cblas_izamax(int __N, ConstVoidPtr __X, int __incX);

    /**
     * Routines with standard 4 prefixes (s, d, c, z)
     */
    @Generated
    @CFunction
    public static native void cblas_sswap(int __N, FloatPtr __X, int __incX, FloatPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_scopy(int __N, ConstFloatPtr __X, int __incX, FloatPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_saxpy(int __N, float __alpha, ConstFloatPtr __X, int __incX, FloatPtr __Y,
            int __incY);

    @Generated
    @CFunction
    public static native void catlas_saxpby(int __N, float __alpha, ConstFloatPtr __X, int __incX, float __beta,
            FloatPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void catlas_sset(int __N, float __alpha, FloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_dswap(int __N, DoublePtr __X, int __incX, DoublePtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_dcopy(int __N, ConstDoublePtr __X, int __incX, DoublePtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_daxpy(int __N, double __alpha, ConstDoublePtr __X, int __incX, DoublePtr __Y,
            int __incY);

    @Generated
    @CFunction
    public static native void catlas_daxpby(int __N, double __alpha, ConstDoublePtr __X, int __incX, double __beta,
            DoublePtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void catlas_dset(int __N, double __alpha, DoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_cswap(int __N, VoidPtr __X, int __incX, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_ccopy(int __N, ConstVoidPtr __X, int __incX, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_caxpy(int __N, ConstVoidPtr __alpha, ConstVoidPtr __X, int __incX, VoidPtr __Y,
            int __incY);

    @Generated
    @CFunction
    public static native void catlas_caxpby(int __N, ConstVoidPtr __alpha, ConstVoidPtr __X, int __incX,
            ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void catlas_cset(int __N, ConstVoidPtr __alpha, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_zswap(int __N, VoidPtr __X, int __incX, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_zcopy(int __N, ConstVoidPtr __X, int __incX, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_zaxpy(int __N, ConstVoidPtr __alpha, ConstVoidPtr __X, int __incX, VoidPtr __Y,
            int __incY);

    @Generated
    @CFunction
    public static native void catlas_zaxpby(int __N, ConstVoidPtr __alpha, ConstVoidPtr __X, int __incX,
            ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void catlas_zset(int __N, ConstVoidPtr __alpha, VoidPtr __X, int __incX);

    /**
     * Routines with S and D prefix only
     */
    @Generated
    @CFunction
    public static native void cblas_srotg(FloatPtr __a, FloatPtr __b, FloatPtr __c, FloatPtr __s);

    @Generated
    @CFunction
    public static native void cblas_srotmg(FloatPtr __d1, FloatPtr __d2, FloatPtr __b1, float __b2, FloatPtr __P);

    @Generated
    @CFunction
    public static native void cblas_srot(int __N, FloatPtr __X, int __incX, FloatPtr __Y, int __incY, float __c,
            float __s);

    @Generated
    @CFunction
    public static native void cblas_srotm(int __N, FloatPtr __X, int __incX, FloatPtr __Y, int __incY,
            ConstFloatPtr __P);

    @Generated
    @CFunction
    public static native void cblas_drotg(DoublePtr __a, DoublePtr __b, DoublePtr __c, DoublePtr __s);

    @Generated
    @CFunction
    public static native void cblas_drotmg(DoublePtr __d1, DoublePtr __d2, DoublePtr __b1, double __b2, DoublePtr __P);

    @Generated
    @CFunction
    public static native void cblas_drot(int __N, DoublePtr __X, int __incX, DoublePtr __Y, int __incY, double __c,
            double __s);

    @Generated
    @CFunction
    public static native void cblas_drotm(int __N, DoublePtr __X, int __incX, DoublePtr __Y, int __incY,
            ConstDoublePtr __P);

    /**
     * Routines with S D C Z CS and ZD prefixes
     */
    @Generated
    @CFunction
    public static native void cblas_sscal(int __N, float __alpha, FloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_dscal(int __N, double __alpha, DoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_cscal(int __N, ConstVoidPtr __alpha, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_zscal(int __N, ConstVoidPtr __alpha, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_csscal(int __N, float __alpha, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_zdscal(int __N, double __alpha, VoidPtr __X, int __incX);

    /**
     * Extra reference routines provided by ATLAS, but not mandated by the standard
     */
    @Generated
    @CFunction
    public static native void cblas_crotg(VoidPtr __a, VoidPtr __b, VoidPtr __c, VoidPtr __s);

    @Generated
    @CFunction
    public static native void cblas_zrotg(VoidPtr __a, VoidPtr __b, VoidPtr __c, VoidPtr __s);

    @Generated
    @CFunction
    public static native void cblas_csrot(int __N, VoidPtr __X, int __incX, VoidPtr __Y, int __incY, float __c,
            float __s);

    @Generated
    @CFunction
    public static native void cblas_zdrot(int __N, VoidPtr __X, int __incX, VoidPtr __Y, int __incY, double __c,
            double __s);

    /**
     * Routines with standard 4 prefixes (S, D, C, Z)
     */
    @Generated
    @CFunction
    public static native void cblas_sgemv(int __Order, int __TransA, int __M, int __N, float __alpha, ConstFloatPtr __A,
            int __lda, ConstFloatPtr __X, int __incX, float __beta, FloatPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_sgbmv(int __Order, int __TransA, int __M, int __N, int __KL, int __KU,
            float __alpha, ConstFloatPtr __A, int __lda, ConstFloatPtr __X, int __incX, float __beta, FloatPtr __Y,
            int __incY);

    @Generated
    @CFunction
    public static native void cblas_strmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstFloatPtr __A,
            int __lda, FloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_stbmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, int __K,
            ConstFloatPtr __A, int __lda, FloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_stpmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N,
            ConstFloatPtr __Ap, FloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_strsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstFloatPtr __A,
            int __lda, FloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_stbsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, int __K,
            ConstFloatPtr __A, int __lda, FloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_stpsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N,
            ConstFloatPtr __Ap, FloatPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_dgemv(int __Order, int __TransA, int __M, int __N, double __alpha,
            ConstDoublePtr __A, int __lda, ConstDoublePtr __X, int __incX, double __beta, DoublePtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_dgbmv(int __Order, int __TransA, int __M, int __N, int __KL, int __KU,
            double __alpha, ConstDoublePtr __A, int __lda, ConstDoublePtr __X, int __incX, double __beta, DoublePtr __Y,
            int __incY);

    @Generated
    @CFunction
    public static native void cblas_dtrmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N,
            ConstDoublePtr __A, int __lda, DoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_dtbmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, int __K,
            ConstDoublePtr __A, int __lda, DoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_dtpmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N,
            ConstDoublePtr __Ap, DoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_dtrsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N,
            ConstDoublePtr __A, int __lda, DoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_dtbsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, int __K,
            ConstDoublePtr __A, int __lda, DoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_dtpsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N,
            ConstDoublePtr __Ap, DoublePtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_cgemv(int __Order, int __TransA, int __M, int __N, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __X, int __incX, ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_cgbmv(int __Order, int __TransA, int __M, int __N, int __KL, int __KU,
            ConstVoidPtr __alpha, ConstVoidPtr __A, int __lda, ConstVoidPtr __X, int __incX, ConstVoidPtr __beta,
            VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_ctrmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstVoidPtr __A,
            int __lda, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ctbmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, int __K,
            ConstVoidPtr __A, int __lda, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ctpmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstVoidPtr __Ap,
            VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ctrsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstVoidPtr __A,
            int __lda, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ctbsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, int __K,
            ConstVoidPtr __A, int __lda, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ctpsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstVoidPtr __Ap,
            VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_zgemv(int __Order, int __TransA, int __M, int __N, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __X, int __incX, ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_zgbmv(int __Order, int __TransA, int __M, int __N, int __KL, int __KU,
            ConstVoidPtr __alpha, ConstVoidPtr __A, int __lda, ConstVoidPtr __X, int __incX, ConstVoidPtr __beta,
            VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_ztrmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstVoidPtr __A,
            int __lda, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ztbmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, int __K,
            ConstVoidPtr __A, int __lda, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ztpmv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstVoidPtr __Ap,
            VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ztrsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstVoidPtr __A,
            int __lda, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ztbsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, int __K,
            ConstVoidPtr __A, int __lda, VoidPtr __X, int __incX);

    @Generated
    @CFunction
    public static native void cblas_ztpsv(int __Order, int __Uplo, int __TransA, int __Diag, int __N, ConstVoidPtr __Ap,
            VoidPtr __X, int __incX);

    /**
     * Routines with S and D prefixes only
     */
    @Generated
    @CFunction
    public static native void cblas_ssymv(int __Order, int __Uplo, int __N, float __alpha, ConstFloatPtr __A, int __lda,
            ConstFloatPtr __X, int __incX, float __beta, FloatPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_ssbmv(int __Order, int __Uplo, int __N, int __K, float __alpha, ConstFloatPtr __A,
            int __lda, ConstFloatPtr __X, int __incX, float __beta, FloatPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_sspmv(int __Order, int __Uplo, int __N, float __alpha, ConstFloatPtr __Ap,
            ConstFloatPtr __X, int __incX, float __beta, FloatPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_sger(int __Order, int __M, int __N, float __alpha, ConstFloatPtr __X, int __incX,
            ConstFloatPtr __Y, int __incY, FloatPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_ssyr(int __Order, int __Uplo, int __N, float __alpha, ConstFloatPtr __X, int __incX,
            FloatPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_sspr(int __Order, int __Uplo, int __N, float __alpha, ConstFloatPtr __X, int __incX,
            FloatPtr __Ap);

    @Generated
    @CFunction
    public static native void cblas_ssyr2(int __Order, int __Uplo, int __N, float __alpha, ConstFloatPtr __X,
            int __incX, ConstFloatPtr __Y, int __incY, FloatPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_sspr2(int __Order, int __Uplo, int __N, float __alpha, ConstFloatPtr __X,
            int __incX, ConstFloatPtr __Y, int __incY, FloatPtr __A);

    @Generated
    @CFunction
    public static native void cblas_dsymv(int __Order, int __Uplo, int __N, double __alpha, ConstDoublePtr __A,
            int __lda, ConstDoublePtr __X, int __incX, double __beta, DoublePtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_dsbmv(int __Order, int __Uplo, int __N, int __K, double __alpha, ConstDoublePtr __A,
            int __lda, ConstDoublePtr __X, int __incX, double __beta, DoublePtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_dspmv(int __Order, int __Uplo, int __N, double __alpha, ConstDoublePtr __Ap,
            ConstDoublePtr __X, int __incX, double __beta, DoublePtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_dger(int __Order, int __M, int __N, double __alpha, ConstDoublePtr __X, int __incX,
            ConstDoublePtr __Y, int __incY, DoublePtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_dsyr(int __Order, int __Uplo, int __N, double __alpha, ConstDoublePtr __X,
            int __incX, DoublePtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_dspr(int __Order, int __Uplo, int __N, double __alpha, ConstDoublePtr __X,
            int __incX, DoublePtr __Ap);

    @Generated
    @CFunction
    public static native void cblas_dsyr2(int __Order, int __Uplo, int __N, double __alpha, ConstDoublePtr __X,
            int __incX, ConstDoublePtr __Y, int __incY, DoublePtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_dspr2(int __Order, int __Uplo, int __N, double __alpha, ConstDoublePtr __X,
            int __incX, ConstDoublePtr __Y, int __incY, DoublePtr __A);

    /**
     * Routines with C and Z prefixes only
     */
    @Generated
    @CFunction
    public static native void cblas_chemv(int __Order, int __Uplo, int __N, ConstVoidPtr __alpha, ConstVoidPtr __A,
            int __lda, ConstVoidPtr __X, int __incX, ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_chbmv(int __Order, int __Uplo, int __N, int __K, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __X, int __incX, ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_chpmv(int __Order, int __Uplo, int __N, ConstVoidPtr __alpha, ConstVoidPtr __Ap,
            ConstVoidPtr __X, int __incX, ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_cgeru(int __Order, int __M, int __N, ConstVoidPtr __alpha, ConstVoidPtr __X,
            int __incX, ConstVoidPtr __Y, int __incY, VoidPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_cgerc(int __Order, int __M, int __N, ConstVoidPtr __alpha, ConstVoidPtr __X,
            int __incX, ConstVoidPtr __Y, int __incY, VoidPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_cher(int __Order, int __Uplo, int __N, float __alpha, ConstVoidPtr __X, int __incX,
            VoidPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_chpr(int __Order, int __Uplo, int __N, float __alpha, ConstVoidPtr __X, int __incX,
            VoidPtr __A);

    @Generated
    @CFunction
    public static native void cblas_cher2(int __Order, int __Uplo, int __N, ConstVoidPtr __alpha, ConstVoidPtr __X,
            int __incX, ConstVoidPtr __Y, int __incY, VoidPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_chpr2(int __Order, int __Uplo, int __N, ConstVoidPtr __alpha, ConstVoidPtr __X,
            int __incX, ConstVoidPtr __Y, int __incY, VoidPtr __Ap);

    @Generated
    @CFunction
    public static native void cblas_zhemv(int __Order, int __Uplo, int __N, ConstVoidPtr __alpha, ConstVoidPtr __A,
            int __lda, ConstVoidPtr __X, int __incX, ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_zhbmv(int __Order, int __Uplo, int __N, int __K, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __X, int __incX, ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_zhpmv(int __Order, int __Uplo, int __N, ConstVoidPtr __alpha, ConstVoidPtr __Ap,
            ConstVoidPtr __X, int __incX, ConstVoidPtr __beta, VoidPtr __Y, int __incY);

    @Generated
    @CFunction
    public static native void cblas_zgeru(int __Order, int __M, int __N, ConstVoidPtr __alpha, ConstVoidPtr __X,
            int __incX, ConstVoidPtr __Y, int __incY, VoidPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_zgerc(int __Order, int __M, int __N, ConstVoidPtr __alpha, ConstVoidPtr __X,
            int __incX, ConstVoidPtr __Y, int __incY, VoidPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_zher(int __Order, int __Uplo, int __N, double __alpha, ConstVoidPtr __X, int __incX,
            VoidPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_zhpr(int __Order, int __Uplo, int __N, double __alpha, ConstVoidPtr __X, int __incX,
            VoidPtr __A);

    @Generated
    @CFunction
    public static native void cblas_zher2(int __Order, int __Uplo, int __N, ConstVoidPtr __alpha, ConstVoidPtr __X,
            int __incX, ConstVoidPtr __Y, int __incY, VoidPtr __A, int __lda);

    @Generated
    @CFunction
    public static native void cblas_zhpr2(int __Order, int __Uplo, int __N, ConstVoidPtr __alpha, ConstVoidPtr __X,
            int __incX, ConstVoidPtr __Y, int __incY, VoidPtr __Ap);

    /**
     * Routines with standard 4 prefixes (S, D, C, Z)
     */
    @Generated
    @CFunction
    public static native void cblas_sgemm(int __Order, int __TransA, int __TransB, int __M, int __N, int __K,
            float __alpha, ConstFloatPtr __A, int __lda, ConstFloatPtr __B, int __ldb, float __beta, FloatPtr __C,
            int __ldc);

    @Generated
    @CFunction
    public static native void cblas_ssymm(int __Order, int __Side, int __Uplo, int __M, int __N, float __alpha,
            ConstFloatPtr __A, int __lda, ConstFloatPtr __B, int __ldb, float __beta, FloatPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_ssyrk(int __Order, int __Uplo, int __Trans, int __N, int __K, float __alpha,
            ConstFloatPtr __A, int __lda, float __beta, FloatPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_ssyr2k(int __Order, int __Uplo, int __Trans, int __N, int __K, float __alpha,
            ConstFloatPtr __A, int __lda, ConstFloatPtr __B, int __ldb, float __beta, FloatPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_strmm(int __Order, int __Side, int __Uplo, int __TransA, int __Diag, int __M,
            int __N, float __alpha, ConstFloatPtr __A, int __lda, FloatPtr __B, int __ldb);

    @Generated
    @CFunction
    public static native void cblas_strsm(int __Order, int __Side, int __Uplo, int __TransA, int __Diag, int __M,
            int __N, float __alpha, ConstFloatPtr __A, int __lda, FloatPtr __B, int __ldb);

    @Generated
    @CFunction
    public static native void cblas_dgemm(int __Order, int __TransA, int __TransB, int __M, int __N, int __K,
            double __alpha, ConstDoublePtr __A, int __lda, ConstDoublePtr __B, int __ldb, double __beta, DoublePtr __C,
            int __ldc);

    @Generated
    @CFunction
    public static native void cblas_dsymm(int __Order, int __Side, int __Uplo, int __M, int __N, double __alpha,
            ConstDoublePtr __A, int __lda, ConstDoublePtr __B, int __ldb, double __beta, DoublePtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_dsyrk(int __Order, int __Uplo, int __Trans, int __N, int __K, double __alpha,
            ConstDoublePtr __A, int __lda, double __beta, DoublePtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_dsyr2k(int __Order, int __Uplo, int __Trans, int __N, int __K, double __alpha,
            ConstDoublePtr __A, int __lda, ConstDoublePtr __B, int __ldb, double __beta, DoublePtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_dtrmm(int __Order, int __Side, int __Uplo, int __TransA, int __Diag, int __M,
            int __N, double __alpha, ConstDoublePtr __A, int __lda, DoublePtr __B, int __ldb);

    @Generated
    @CFunction
    public static native void cblas_dtrsm(int __Order, int __Side, int __Uplo, int __TransA, int __Diag, int __M,
            int __N, double __alpha, ConstDoublePtr __A, int __lda, DoublePtr __B, int __ldb);

    @Generated
    @CFunction
    public static native void cblas_cgemm(int __Order, int __TransA, int __TransB, int __M, int __N, int __K,
            ConstVoidPtr __alpha, ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, ConstVoidPtr __beta,
            VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_csymm(int __Order, int __Side, int __Uplo, int __M, int __N, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, ConstVoidPtr __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_csyrk(int __Order, int __Uplo, int __Trans, int __N, int __K, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_csyr2k(int __Order, int __Uplo, int __Trans, int __N, int __K, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, ConstVoidPtr __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_ctrmm(int __Order, int __Side, int __Uplo, int __TransA, int __Diag, int __M,
            int __N, ConstVoidPtr __alpha, ConstVoidPtr __A, int __lda, VoidPtr __B, int __ldb);

    @Generated
    @CFunction
    public static native void cblas_ctrsm(int __Order, int __Side, int __Uplo, int __TransA, int __Diag, int __M,
            int __N, ConstVoidPtr __alpha, ConstVoidPtr __A, int __lda, VoidPtr __B, int __ldb);

    @Generated
    @CFunction
    public static native void cblas_zgemm(int __Order, int __TransA, int __TransB, int __M, int __N, int __K,
            ConstVoidPtr __alpha, ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, ConstVoidPtr __beta,
            VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_zsymm(int __Order, int __Side, int __Uplo, int __M, int __N, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, ConstVoidPtr __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_zsyrk(int __Order, int __Uplo, int __Trans, int __N, int __K, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_zsyr2k(int __Order, int __Uplo, int __Trans, int __N, int __K, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, ConstVoidPtr __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_ztrmm(int __Order, int __Side, int __Uplo, int __TransA, int __Diag, int __M,
            int __N, ConstVoidPtr __alpha, ConstVoidPtr __A, int __lda, VoidPtr __B, int __ldb);

    @Generated
    @CFunction
    public static native void cblas_ztrsm(int __Order, int __Side, int __Uplo, int __TransA, int __Diag, int __M,
            int __N, ConstVoidPtr __alpha, ConstVoidPtr __A, int __lda, VoidPtr __B, int __ldb);

    /**
     * Routines with prefixes C and Z only
     */
    @Generated
    @CFunction
    public static native void cblas_chemm(int __Order, int __Side, int __Uplo, int __M, int __N, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, ConstVoidPtr __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_cherk(int __Order, int __Uplo, int __Trans, int __N, int __K, float __alpha,
            ConstVoidPtr __A, int __lda, float __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_cher2k(int __Order, int __Uplo, int __Trans, int __N, int __K, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, float __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_zhemm(int __Order, int __Side, int __Uplo, int __M, int __N, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, ConstVoidPtr __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_zherk(int __Order, int __Uplo, int __Trans, int __N, int __K, double __alpha,
            ConstVoidPtr __A, int __lda, double __beta, VoidPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void cblas_zher2k(int __Order, int __Uplo, int __Trans, int __N, int __K, ConstVoidPtr __alpha,
            ConstVoidPtr __A, int __lda, ConstVoidPtr __B, int __ldb, double __beta, VoidPtr __C, int __ldc);

    /**
     * These routines perform linear operations (scalar multiplication and addition)
     * on matrices, with optional transposition.  Specifically, the operation is:
     * <p>
     * C = alpha * A + beta * B
     * <p>
     * where A and B are optionally transposed as indicated by the value of transA
     * and transB.  This is a surprisingly useful operation; although its function
     * is fairly trivial, efficient implementation has enough subtlety to justify
     * a library interface.
     * <p>
     * As an added convenience, this function supports in-place operation for
     * square matrices; in-place operation for non-square matrices in the face of
     * transposition is a subtle problem outside the scope of this interface.
     * In-place operation is only supported if the leading dimensions match as well
     * as the pointers.  If C overlaps A or B but does not have equal leading
     * dimension, or does not exactly match the source that it overlaps, the
     * behavior of this function is undefined.
     * <p>
     * If alpha or beta is zero, then A (or B, respectively) is ignored entirely,
     * meaning that the memory is not accessed and the data does not contribute
     * to the result (meaning you can pass B == NULL if beta is zero).
     * <p>
     * Note that m and n are the number of rows and columns of C, respectively.
     * If either A or B is transposed, then they are interpreted as n x m matrices.
     */
    @Generated
    @CFunction
    public static native void appleblas_sgeadd(int __order, int __transA, int __transB, int __m, int __n, float __alpha,
            ConstFloatPtr __A, int __lda, float __beta, ConstFloatPtr __B, int __ldb, FloatPtr __C, int __ldc);

    @Generated
    @CFunction
    public static native void appleblas_dgeadd(int __order, int __transA, int __transB, int __m, int __n,
            double __alpha, ConstDoublePtr __A, int __lda, double __beta, ConstDoublePtr __B, int __ldb, DoublePtr __C,
            int __ldc);

    @Generated
    @CFunction
    public static native void SetBLASParamErrorProc(
            @FunctionPtr(name = "call_SetBLASParamErrorProc") Function_SetBLASParamErrorProc __ErrorProc);

    @Generated
    @CFunction
    public static native int cbdsqr_(BytePtr __uplo, IntPtr __n, IntPtr __ncvt, IntPtr __nru, IntPtr __ncc,
            FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vt, IntPtr __ldvt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __u, IntPtr __ldu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbbrd_(BytePtr __vect, IntPtr __m, IntPtr __n, IntPtr __ncc, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __pt, IntPtr __ldpt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbcon_(BytePtr __norm, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            IntPtr __ipiv, FloatPtr __anorm, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbequ_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbequb_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbrfs_(BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afb, IntPtr __ldafb,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbsv_(IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbsvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku,
            IntPtr __nrhs, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afb,
            IntPtr __ldafb, IntPtr __ipiv, BytePtr __equed, FloatPtr __r__, FloatPtr __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbtf2_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbtrf_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgbtrs_(BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgebak_(BytePtr __job, BytePtr __side, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __scale, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgebal_(BytePtr __job, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ilo, IntPtr __ihi, FloatPtr __scale, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgebd2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tauq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __taup,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgebrd_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tauq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __taup,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgecon_(BytePtr __norm, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __anorm, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeequ_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeequb_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeev_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeevx_(BytePtr __balanc, BytePtr __jobvl, BytePtr __jobvr, BytePtr __sense, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            IntPtr __ilo, IntPtr __ihi, FloatPtr __scale, FloatPtr __abnrm, FloatPtr __rconde, FloatPtr __rcondv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgegs_(BytePtr __jobvsl, BytePtr __jobvsr, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vsl, IntPtr __ldvsl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vsr, IntPtr __ldvsr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgegv_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgehd2_(IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgehrd_(IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgelq2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgelqf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgels_(BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgelsd_(IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            FloatPtr __s, FloatPtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgelss_(IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            FloatPtr __s, FloatPtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgelsx_(IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __jpvt, FloatPtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgelsy_(IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __jpvt, FloatPtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeql2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeqlf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeqp3_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __jpvt, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeqpf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __jpvt, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeqr2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgeqrf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgerfs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __af, IntPtr __ldaf,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgerq2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgerqf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgesc2_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __rhs, IntPtr __ipiv,
            IntPtr __jpiv, FloatPtr __scale);

    @Generated
    @CFunction
    public static native int cgesdd_(BytePtr __jobz, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __s, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __u,
            IntPtr __ldu, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vt,
            IntPtr __ldvt, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, FloatPtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgesv_(IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgesvd_(BytePtr __jobu, BytePtr __jobvt, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __s, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __u,
            IntPtr __ldu, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vt,
            IntPtr __ldvt, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgesvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __af, IntPtr __ldaf,
            IntPtr __ipiv, BytePtr __equed, FloatPtr __r__, FloatPtr __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgetc2_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __jpiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgetf2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgetrf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgetri_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgetrs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int cggbak_(BytePtr __job, BytePtr __side, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __lscale, FloatPtr __rscale, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cggbal_(BytePtr __job, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __ilo, IntPtr __ihi, FloatPtr __lscale, FloatPtr __rscale, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cggev_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cggevx_(BytePtr __balanc, BytePtr __jobvl, BytePtr __jobvr, BytePtr __sense, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            IntPtr __ilo, IntPtr __ihi, FloatPtr __lscale, FloatPtr __rscale, FloatPtr __abnrm, FloatPtr __bbnrm,
            FloatPtr __rconde, FloatPtr __rcondv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __iwork, IntPtr __bwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cggglm_(IntPtr __n, IntPtr __m, IntPtr __p,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgghrd_(BytePtr __compq, BytePtr __compz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgglse_(IntPtr __m, IntPtr __n, IntPtr __p,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cggqrf_(IntPtr __n, IntPtr __m, IntPtr __p,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __taua,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __taub,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cggrqf_(IntPtr __m, IntPtr __p, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __taua,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __taub,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cggsvd_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __n, IntPtr __p,
            IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            FloatPtr __alpha, FloatPtr __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __u, IntPtr __ldu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cggsvp_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __p, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            FloatPtr __tola, FloatPtr __tolb, IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __u, IntPtr __ldu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            IntPtr __iwork, FloatPtr __rwork,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgtcon_(BytePtr __norm, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du2, IntPtr __ipiv,
            FloatPtr __anorm, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cgtrfs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dlf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __df,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __duf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du2, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgtsv_(IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgtsvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dlf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __df,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __duf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du2, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgttrf_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du2, IntPtr __ipiv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgttrs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du2, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cgtts2_(IntPtr __itrans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du2, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int chbev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __w, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__,
            IntPtr __ldz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chbevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __w, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__,
            IntPtr __ldz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, FloatPtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chbevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int chbgst_(BytePtr __vect, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bb, IntPtr __ldbb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chbgv_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bb, IntPtr __ldbb,
            FloatPtr __w, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__,
            IntPtr __ldz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chbgvd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bb, IntPtr __ldbb,
            FloatPtr __w, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__,
            IntPtr __ldz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, FloatPtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chbgvx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, IntPtr __ka,
            IntPtr __kb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bb,
            IntPtr __ldbb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q,
            IntPtr __ldq, FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m,
            FloatPtr __w, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__,
            IntPtr __ldz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            FloatPtr __rwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int chbtrd_(BytePtr __vect, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int checon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, FloatPtr __anorm, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cheequb_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cheev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __w, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cheevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __w, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, FloatPtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cheevr_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __isuppz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, FloatPtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cheevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int chegs2_(IntPtr __itype, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chegst_(IntPtr __itype, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chegv_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            FloatPtr __w, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chegvd_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            FloatPtr __w, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, FloatPtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chegvx_(IntPtr __itype, BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int cherfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __af, IntPtr __ldaf,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chesv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chesvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __af, IntPtr __ldaf,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            IntPtr __ldx, FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chetd2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau, IntPtr __info);

    @Generated
    @CFunction
    public static native int chetf2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int chetrd_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chetrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chetri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chetrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int chfrk_(BytePtr __transr, BytePtr __uplo, BytePtr __trans, IntPtr __n, IntPtr __k,
            FloatPtr __alpha, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a,
            IntPtr __lda, FloatPtr __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__);

    @Generated
    @CFunction
    public static native int chgeqz_(BytePtr __job, BytePtr __compq, BytePtr __compz, IntPtr __n, IntPtr __ilo,
            IntPtr __ihi, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__,
            IntPtr __ldh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t,
            IntPtr __ldt, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native void chla_transtype__(BytePtr __ret_val, int __ret_val_len, IntPtr __trans);

    @Generated
    @CFunction
    public static native int chpcon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            FloatPtr __anorm, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int chpev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chpevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chpevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __vl,
            FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int chpgst_(IntPtr __itype, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bp, IntPtr __info);

    @Generated
    @CFunction
    public static native int chpgv_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bp, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chpgvd_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bp, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int chpgvx_(IntPtr __itype, BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bp, FloatPtr __vl,
            FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int chprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afp, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chpsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chpsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afp, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chptrd_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __d__,
            FloatPtr __e, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chptrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chptri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int chptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int chsein_(BytePtr __side, BytePtr __eigsrc, BytePtr __initv, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__, IntPtr __ldh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __ifaill, IntPtr __ifailr, IntPtr __info);

    @Generated
    @CFunction
    public static native int chseqr_(BytePtr __job, BytePtr __compz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__, IntPtr __ldh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int clabrd_(IntPtr __m, IntPtr __n, IntPtr __nb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tauq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __taup,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int clacgv_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx);

    @Generated
    @CFunction
    public static native int clacn2_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, FloatPtr __est,
            IntPtr __kase, IntPtr __isave);

    @Generated
    @CFunction
    public static native int clacon_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, FloatPtr __est,
            IntPtr __kase);

    @Generated
    @CFunction
    public static native int clacp2_(BytePtr __uplo, IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int clacpy_(BytePtr __uplo, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int clacrm_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            FloatPtr __rwork);

    @Generated
    @CFunction
    public static native int clacrt_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __cx, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __cy, IntPtr __incy,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __s);

    @Generated
    @CFunction
    public static native void cladiv_(
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ret_val,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y);

    @Generated
    @CFunction
    public static native int claed0_(IntPtr __qsiz, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __qstore, IntPtr __ldqs,
            FloatPtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int claed7_(IntPtr __n, IntPtr __cutpnt, IntPtr __qsiz, IntPtr __tlvls, IntPtr __curlvl,
            IntPtr __curpbm, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            FloatPtr __rho, IntPtr __indxq, FloatPtr __qstore, IntPtr __qptr, IntPtr __prmptr, IntPtr __perm,
            IntPtr __givptr, IntPtr __givcol, FloatPtr __givnum,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int claed8_(IntPtr __k, IntPtr __n, IntPtr __qsiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            FloatPtr __d__, FloatPtr __rho, IntPtr __cutpnt, FloatPtr __z__, FloatPtr __dlamda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q2, IntPtr __ldq2,
            FloatPtr __w, IntPtr __indxp, IntPtr __indx, IntPtr __indxq, IntPtr __perm, IntPtr __givptr,
            IntPtr __givcol, FloatPtr __givnum, IntPtr __info);

    @Generated
    @CFunction
    public static native int claein_(IntPtr __rightv, IntPtr __noinit, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__, IntPtr __ldh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            FloatPtr __rwork, FloatPtr __eps3, FloatPtr __smlnum, IntPtr __info);

    @Generated
    @CFunction
    public static native int claesy_(
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __rt1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __rt2,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __evscal,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __cs1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __sn1);

    @Generated
    @CFunction
    public static native int claev2_(
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, FloatPtr __rt1,
            FloatPtr __rt2, FloatPtr __cs1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __sn1);

    @Generated
    @CFunction
    public static native int clag2z_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __sa, IntPtr __ldsa,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int clags2_(IntPtr __upper, FloatPtr __a1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a2, FloatPtr __a3,
            FloatPtr __b1, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b2,
            FloatPtr __b3, FloatPtr __csu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __snu, FloatPtr __csv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __snv, FloatPtr __csq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __snq);

    @Generated
    @CFunction
    public static native int clagtm_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, FloatPtr __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __beta, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb);

    @Generated
    @CFunction
    public static native int clahef_(BytePtr __uplo, IntPtr __n, IntPtr __nb, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w,
            IntPtr __ldw, IntPtr __info);

    @Generated
    @CFunction
    public static native int clahqr_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__, IntPtr __ldh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w, IntPtr __iloz,
            IntPtr __ihiz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__,
            IntPtr __ldz, IntPtr __info);

    @Generated
    @CFunction
    public static native int clahr2_(IntPtr __n, IntPtr __k, IntPtr __nb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int clahrd_(IntPtr __n, IntPtr __k, IntPtr __nb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int claic1_(IntPtr __job, IntPtr __j,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, FloatPtr __sest,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __gamma,
            FloatPtr __sestpr, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__);

    @Generated
    @CFunction
    public static native int clals0_(IntPtr __icompq, IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bx, IntPtr __ldbx,
            IntPtr __perm, IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, FloatPtr __givnum, IntPtr __ldgnum,
            FloatPtr __poles, FloatPtr __difl, FloatPtr __difr, FloatPtr __z__, IntPtr __k, FloatPtr __c__,
            FloatPtr __s, FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int clalsa_(IntPtr __icompq, IntPtr __smlsiz, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __bx, IntPtr __ldbx,
            FloatPtr __u, IntPtr __ldu, FloatPtr __vt, IntPtr __k, FloatPtr __difl, FloatPtr __difr, FloatPtr __z__,
            FloatPtr __poles, IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, IntPtr __perm, FloatPtr __givnum,
            FloatPtr __c__, FloatPtr __s, FloatPtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int clalsd_(BytePtr __uplo, IntPtr __smlsiz, IntPtr __n, IntPtr __nrhs, FloatPtr __d__,
            FloatPtr __e, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, FloatPtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native double clangb_(BytePtr __norm, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double clange_(BytePtr __norm, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double clangt_(BytePtr __norm, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __du);

    @Generated
    @CFunction
    public static native double clanhb_(BytePtr __norm, BytePtr __uplo, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double clanhe_(BytePtr __norm, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double clanhf_(BytePtr __norm, BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, FloatPtr __work);

    @Generated
    @CFunction
    public static native double clanhp_(BytePtr __norm, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __work);

    @Generated
    @CFunction
    public static native double clanhs_(BytePtr __norm, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double clanht_(BytePtr __norm, IntPtr __n, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e);

    @Generated
    @CFunction
    public static native double clansb_(BytePtr __norm, BytePtr __uplo, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double clansp_(BytePtr __norm, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __work);

    @Generated
    @CFunction
    public static native double clansy_(BytePtr __norm, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double clantb_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double clantp_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __work);

    @Generated
    @CFunction
    public static native double clantr_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native int clapll_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y, IntPtr __incy,
            FloatPtr __ssmin);

    @Generated
    @CFunction
    public static native int clapmt_(IntPtr __forwrd, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            IntPtr __k);

    @Generated
    @CFunction
    public static native int claqgb_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int claqge_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int claqhb_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int claqhe_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int claqhp_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __s,
            FloatPtr __scond, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int claqp2_(IntPtr __m, IntPtr __n, IntPtr __offset,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __jpvt, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            FloatPtr __vn1, FloatPtr __vn2,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work);

    @Generated
    @CFunction
    public static native int claqps_(IntPtr __m, IntPtr __n, IntPtr __offset, IntPtr __nb, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __jpvt, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            FloatPtr __vn1, FloatPtr __vn2,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __auxv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __f, IntPtr __ldf);

    @Generated
    @CFunction
    public static native int claqr0_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__, IntPtr __ldh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w, IntPtr __iloz,
            IntPtr __ihiz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__,
            IntPtr __ldz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int claqr1_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__, IntPtr __ldh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __s1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __s2,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v);

    @Generated
    @CFunction
    public static native int claqr2_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ktop, IntPtr __kbot,
            IntPtr __nw, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__,
            IntPtr __ldh, IntPtr __iloz, IntPtr __ihiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __ns, IntPtr __nd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __sh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            IntPtr __nh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t,
            IntPtr __ldt, IntPtr __nv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __wv, IntPtr __ldwv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork);

    @Generated
    @CFunction
    public static native int claqr3_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ktop, IntPtr __kbot,
            IntPtr __nw, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__,
            IntPtr __ldh, IntPtr __iloz, IntPtr __ihiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __ns, IntPtr __nd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __sh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            IntPtr __nh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t,
            IntPtr __ldt, IntPtr __nv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __wv, IntPtr __ldwv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork);

    @Generated
    @CFunction
    public static native int claqr4_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__, IntPtr __ldh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w, IntPtr __iloz,
            IntPtr __ihiz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__,
            IntPtr __ldz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int claqr5_(IntPtr __wantt, IntPtr __wantz, IntPtr __kacc22, IntPtr __n, IntPtr __ktop,
            IntPtr __kbot, IntPtr __nshfts,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __h__, IntPtr __ldh,
            IntPtr __iloz, IntPtr __ihiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __u, IntPtr __ldu,
            IntPtr __nv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __wv,
            IntPtr __ldwv, IntPtr __nh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __wh, IntPtr __ldwh);

    @Generated
    @CFunction
    public static native int claqsb_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int claqsp_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __s,
            FloatPtr __scond, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int claqsy_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int clar1v_(IntPtr __n, IntPtr __b1, IntPtr __bn, FloatPtr __lambda, FloatPtr __d__,
            FloatPtr __l, FloatPtr __ld, FloatPtr __lld, FloatPtr __pivmin, FloatPtr __gaptol,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __wantnc,
            IntPtr __negcnt, FloatPtr __ztz, FloatPtr __mingma, IntPtr __r__, IntPtr __isuppz, FloatPtr __nrminv,
            FloatPtr __resid, FloatPtr __rqcorr, FloatPtr __work);

    @Generated
    @CFunction
    public static native int clar2v_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __incx,
            FloatPtr __c__, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __s,
            IntPtr __incc);

    @Generated
    @CFunction
    public static native int clarcm_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            FloatPtr __rwork);

    @Generated
    @CFunction
    public static native int clarf_(BytePtr __side, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __incv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work);

    @Generated
    @CFunction
    public static native int clarfb_(BytePtr __side, BytePtr __trans, BytePtr __direct, BytePtr __storev, IntPtr __m,
            IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __ldwork);

    @Generated
    @CFunction
    public static native int clarfg_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau);

    @Generated
    @CFunction
    public static native int clarfp_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau);

    @Generated
    @CFunction
    public static native int clarft_(BytePtr __direct, BytePtr __storev, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt);

    @Generated
    @CFunction
    public static native int clarfx_(BytePtr __side, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work);

    @Generated
    @CFunction
    public static native int clargv_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y, IntPtr __incy,
            FloatPtr __c__, IntPtr __incc);

    @Generated
    @CFunction
    public static native int clarnv_(IntPtr __idist, IntPtr __iseed, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x);

    @Generated
    @CFunction
    public static native int clarrv_(IntPtr __n, FloatPtr __vl, FloatPtr __vu, FloatPtr __d__, FloatPtr __l,
            FloatPtr __pivmin, IntPtr __isplit, IntPtr __m, IntPtr __dol, IntPtr __dou, FloatPtr __minrgp,
            FloatPtr __rtol1, FloatPtr __rtol2, FloatPtr __w, FloatPtr __werr, FloatPtr __wgap, IntPtr __iblock,
            IntPtr __indexw, FloatPtr __gers,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __isuppz, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int clarscl2_(IntPtr __m, IntPtr __n, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx);

    @Generated
    @CFunction
    public static native int clartg_(
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __f,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __g, FloatPtr __cs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __sn,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __r__);

    @Generated
    @CFunction
    public static native int clartv_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y, IntPtr __incy,
            FloatPtr __c__, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __s,
            IntPtr __incc);

    @Generated
    @CFunction
    public static native int clarz_(BytePtr __side, IntPtr __m, IntPtr __n, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __incv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work);

    @Generated
    @CFunction
    public static native int clarzb_(BytePtr __side, BytePtr __trans, BytePtr __direct, BytePtr __storev, IntPtr __m,
            IntPtr __n, IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __ldwork);

    @Generated
    @CFunction
    public static native int clarzt_(BytePtr __direct, BytePtr __storev, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt);

    @Generated
    @CFunction
    public static native int clascl_(BytePtr __type__, IntPtr __kl, IntPtr __ku, FloatPtr __cfrom, FloatPtr __cto,
            IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int clascl2_(IntPtr __m, IntPtr __n, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx);

    @Generated
    @CFunction
    public static native int claset_(BytePtr __uplo, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int clasr_(BytePtr __side, BytePtr __pivot, BytePtr __direct, IntPtr __m, IntPtr __n,
            FloatPtr __c__, FloatPtr __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int classq_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            FloatPtr __scale, FloatPtr __sumsq);

    @Generated
    @CFunction
    public static native int claswp_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __k1, IntPtr __k2, IntPtr __ipiv, IntPtr __incx);

    @Generated
    @CFunction
    public static native int clasyf_(BytePtr __uplo, IntPtr __n, IntPtr __nb, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w,
            IntPtr __ldw, IntPtr __info);

    @Generated
    @CFunction
    public static native int clatbs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            IntPtr __kd, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            FloatPtr __scale, FloatPtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int clatdf_(IntPtr __ijob, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __rhs, FloatPtr __rdsum,
            FloatPtr __rdscal, IntPtr __ipiv, IntPtr __jpiv);

    @Generated
    @CFunction
    public static native int clatps_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, FloatPtr __scale,
            FloatPtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int clatrd_(BytePtr __uplo, IntPtr __n, IntPtr __nb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __e, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w, IntPtr __ldw);

    @Generated
    @CFunction
    public static native int clatrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, FloatPtr __scale,
            FloatPtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int clatrz_(IntPtr __m, IntPtr __n, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work);

    @Generated
    @CFunction
    public static native int clatzm_(BytePtr __side, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __incv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c2, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work);

    @Generated
    @CFunction
    public static native int clauu2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int clauum_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpbcon_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __anorm, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpbequ_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpbrfs_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afb, IntPtr __ldafb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpbstf_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpbsv_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpbsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afb, IntPtr __ldafb,
            BytePtr __equed, FloatPtr __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpbtf2_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpbtrf_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpbtrs_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpftrf_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpftri_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpftrs_(BytePtr __transr, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpocon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __anorm, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpoequ_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpoequb_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int cporfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __af, IntPtr __ldaf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cposv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cposvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __af, IntPtr __ldaf,
            BytePtr __equed, FloatPtr __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpotf2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpotrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpotri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpotrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cppcon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __anorm,
            FloatPtr __rcond, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cppequ_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __s,
            FloatPtr __scond, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afp,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cppsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cppsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afp, BytePtr __equed,
            FloatPtr __s, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            IntPtr __ldx, FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpptrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpptri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpstf2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __piv, IntPtr __rank, FloatPtr __tol, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpstrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __piv, IntPtr __rank, FloatPtr __tol, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cptcon_(IntPtr __n, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e, FloatPtr __anorm,
            FloatPtr __rcond, FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpteqr_(BytePtr __compz, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cptrfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e, FloatPtr __df,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ef,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cptsv_(IntPtr __n, IntPtr __nrhs, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cptsvx_(BytePtr __fact, IntPtr __n, IntPtr __nrhs, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e, FloatPtr __df,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ef,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cpttrf_(IntPtr __n, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e, IntPtr __info);

    @Generated
    @CFunction
    public static native int cpttrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cptts2_(IntPtr __iuplo, IntPtr __n, IntPtr __nrhs, FloatPtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int crot_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __cx, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __cy, IntPtr __incy,
            FloatPtr __c__, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __s);

    @Generated
    @CFunction
    public static native int cspcon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            FloatPtr __anorm, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cspmv_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y, IntPtr __incy);

    @Generated
    @CFunction
    public static native int cspr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap);

    @Generated
    @CFunction
    public static native int csprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afp, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cspsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cspsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __afp, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int csptrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int csptri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int csptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int csrscl_(IntPtr __n, FloatPtr __sa,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __sx, IntPtr __incx);

    @Generated
    @CFunction
    public static native int cstedc_(BytePtr __compz, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cstegr_(BytePtr __jobz, BytePtr __range, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __isuppz, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int cstein_(IntPtr __n, FloatPtr __d__, FloatPtr __e, IntPtr __m, FloatPtr __w,
            IntPtr __iblock, IntPtr __isplit,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            FloatPtr __work, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int cstemr_(BytePtr __jobz, BytePtr __range, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, IntPtr __m, FloatPtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __nzc, IntPtr __isuppz, IntPtr __tryrac, FloatPtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int csteqr_(BytePtr __compz, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int csycon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, FloatPtr __anorm, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int csyequb_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int csymv_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __y, IntPtr __incy);

    @Generated
    @CFunction
    public static native int csyr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int csyrfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __af, IntPtr __ldaf,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int csysv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int csysvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __af, IntPtr __ldaf,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            IntPtr __ldx, FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int csytf2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int csytrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int csytri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int csytrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctbcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab, IntPtr __ldab,
            FloatPtr __rcond, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctbrfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __kd,
            IntPtr __nrhs, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x,
            IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctbtrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __kd,
            IntPtr __nrhs, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctfsm_(BytePtr __transr, BytePtr __side, BytePtr __uplo, BytePtr __trans, BytePtr __diag,
            IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int ctftri_(BytePtr __transr, BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctfttp_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __arf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctfttr_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __arf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctgevc_(BytePtr __side, BytePtr __howmny, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __s, IntPtr __lds,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __p, IntPtr __ldp,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctgex2_(IntPtr __wantq, IntPtr __wantz, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __j1, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctgexc_(IntPtr __wantq, IntPtr __wantz, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __ifst, IntPtr __ilst, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctgsen_(IntPtr __ijob, IntPtr __wantq, IntPtr __wantz, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __z__, IntPtr __ldz,
            IntPtr __m, FloatPtr __pl, FloatPtr __pr, FloatPtr __dif,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctgsja_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __p, IntPtr __n,
            IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            FloatPtr __tola, FloatPtr __tolb, FloatPtr __alpha, FloatPtr __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __u, IntPtr __ldu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __ncycle,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctgsna_(BytePtr __job, BytePtr __howmny, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            FloatPtr __s, FloatPtr __dif, IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctgsy2_(BytePtr __trans, IntPtr __ijob, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__, IntPtr __ldd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e, IntPtr __lde,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __f, IntPtr __ldf,
            FloatPtr __scale, FloatPtr __rdsum, FloatPtr __rdscal, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctgsyl_(BytePtr __trans, IntPtr __ijob, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __d__, IntPtr __ldd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __e, IntPtr __lde,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __f, IntPtr __ldf,
            FloatPtr __scale, FloatPtr __dif,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctpcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, FloatPtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctprfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctptri_(BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctptrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctpttf_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __arf, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctpttr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            FloatPtr __rcond, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrevc_(BytePtr __side, BytePtr __howmny, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrexc_(BytePtr __compq, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            IntPtr __ifst, IntPtr __ilst, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrrfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, FloatPtr __rwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrsen_(BytePtr __job, BytePtr __compq, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __w, IntPtr __m,
            FloatPtr __s, FloatPtr __sep,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrsna_(BytePtr __job, BytePtr __howmny, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vl, IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __vr, IntPtr __ldvr,
            FloatPtr __s, FloatPtr __sep, IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __ldwork,
            FloatPtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrsyl_(BytePtr __trana, BytePtr __tranb, IntPtr __isgn, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            FloatPtr __scale, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrti2_(BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrtri_(BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrtrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrttf_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __arf, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctrttp_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctzrqf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau, IntPtr __info);

    @Generated
    @CFunction
    public static native int ctzrzf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cung2l_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cung2r_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cungbr_(BytePtr __vect, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cunghr_(IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cungl2_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cunglq_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cungql_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cungqr_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cungr2_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cungrq_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cungtr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cunm2l_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cunm2r_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmbr_(BytePtr __vect, BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n,
            IntPtr __k, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a,
            IntPtr __lda, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmhr_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __ilo,
            IntPtr __ihi, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a,
            IntPtr __lda, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cunml2_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmlq_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmql_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmqr_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmr2_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmr3_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmrq_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmrz_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cunmtr_(BytePtr __side, BytePtr __uplo, BytePtr __trans, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int cupgtr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int cupmtr_(BytePtr __side, BytePtr __uplo, BytePtr __trans, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __c__, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dbdsdc_(BytePtr __uplo, BytePtr __compq, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            DoublePtr __u, IntPtr __ldu, DoublePtr __vt, IntPtr __ldvt, DoublePtr __q, IntPtr __iq, DoublePtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dbdsqr_(BytePtr __uplo, IntPtr __n, IntPtr __ncvt, IntPtr __nru, IntPtr __ncc,
            DoublePtr __d__, DoublePtr __e, DoublePtr __vt, IntPtr __ldvt, DoublePtr __u, IntPtr __ldu, DoublePtr __c__,
            IntPtr __ldc, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int ddisna_(BytePtr __job, IntPtr __m, IntPtr __n, DoublePtr __d__, DoublePtr __sep,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbbrd_(BytePtr __vect, IntPtr __m, IntPtr __n, IntPtr __ncc, IntPtr __kl, IntPtr __ku,
            DoublePtr __ab, IntPtr __ldab, DoublePtr __d__, DoublePtr __e, DoublePtr __q, IntPtr __ldq, DoublePtr __pt,
            IntPtr __ldpt, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbcon_(BytePtr __norm, IntPtr __n, IntPtr __kl, IntPtr __ku, DoublePtr __ab,
            IntPtr __ldab, IntPtr __ipiv, DoublePtr __anorm, DoublePtr __rcond, DoublePtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbequ_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, DoublePtr __ab, IntPtr __ldab,
            DoublePtr __r__, DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbequb_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, DoublePtr __ab, IntPtr __ldab,
            DoublePtr __r__, DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbrfs_(BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            DoublePtr __ab, IntPtr __ldab, DoublePtr __afb, IntPtr __ldafb, IntPtr __ipiv, DoublePtr __b, IntPtr __ldb,
            DoublePtr __x, IntPtr __ldx, DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbsv_(IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs, DoublePtr __ab, IntPtr __ldab,
            IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbsvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku,
            IntPtr __nrhs, DoublePtr __ab, IntPtr __ldab, DoublePtr __afb, IntPtr __ldafb, IntPtr __ipiv,
            BytePtr __equed, DoublePtr __r__, DoublePtr __c__, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbtf2_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, DoublePtr __ab, IntPtr __ldab,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbtrf_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, DoublePtr __ab, IntPtr __ldab,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgbtrs_(BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            DoublePtr __ab, IntPtr __ldab, IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgebak_(BytePtr __job, BytePtr __side, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __scale, IntPtr __m, DoublePtr __v, IntPtr __ldv, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgebal_(BytePtr __job, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __scale, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgebd2_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __d__,
            DoublePtr __e, DoublePtr __tauq, DoublePtr __taup, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgebrd_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __d__,
            DoublePtr __e, DoublePtr __tauq, DoublePtr __taup, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgecon_(BytePtr __norm, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __anorm,
            DoublePtr __rcond, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeequ_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __r__,
            DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeequb_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __r__,
            DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeev_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __wr, DoublePtr __wi, DoublePtr __vl, IntPtr __ldvl, DoublePtr __vr, IntPtr __ldvr,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeevx_(BytePtr __balanc, BytePtr __jobvl, BytePtr __jobvr, BytePtr __sense, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __wr, DoublePtr __wi, DoublePtr __vl, IntPtr __ldvl, DoublePtr __vr,
            IntPtr __ldvr, IntPtr __ilo, IntPtr __ihi, DoublePtr __scale, DoublePtr __abnrm, DoublePtr __rconde,
            DoublePtr __rcondv, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgegs_(BytePtr __jobvsl, BytePtr __jobvsr, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, DoublePtr __alphar, DoublePtr __alphai, DoublePtr __beta, DoublePtr __vsl,
            IntPtr __ldvsl, DoublePtr __vsr, IntPtr __ldvsr, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgegv_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, DoublePtr __alphar, DoublePtr __alphai, DoublePtr __beta, DoublePtr __vl,
            IntPtr __ldvl, DoublePtr __vr, IntPtr __ldvr, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgehd2_(IntPtr __n, IntPtr __ilo, IntPtr __ihi, DoublePtr __a, IntPtr __lda,
            DoublePtr __tau, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgehrd_(IntPtr __n, IntPtr __ilo, IntPtr __ihi, DoublePtr __a, IntPtr __lda,
            DoublePtr __tau, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgejsv_(BytePtr __joba, BytePtr __jobu, BytePtr __jobv, BytePtr __jobr, BytePtr __jobt,
            BytePtr __jobp, IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __sva, DoublePtr __u,
            IntPtr __ldu, DoublePtr __v, IntPtr __ldv, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgelq2_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgelqf_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgels_(BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgelsd_(IntPtr __m, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda, DoublePtr __b,
            IntPtr __ldb, DoublePtr __s, DoublePtr __rcond, IntPtr __rank, DoublePtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgelss_(IntPtr __m, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda, DoublePtr __b,
            IntPtr __ldb, DoublePtr __s, DoublePtr __rcond, IntPtr __rank, DoublePtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dgelsx_(IntPtr __m, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda, DoublePtr __b,
            IntPtr __ldb, IntPtr __jpvt, DoublePtr __rcond, IntPtr __rank, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgelsy_(IntPtr __m, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda, DoublePtr __b,
            IntPtr __ldb, IntPtr __jpvt, DoublePtr __rcond, IntPtr __rank, DoublePtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeql2_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeqlf_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeqp3_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __jpvt,
            DoublePtr __tau, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeqpf_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __jpvt,
            DoublePtr __tau, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeqr2_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgeqrf_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgerfs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            DoublePtr __af, IntPtr __ldaf, IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgerq2_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgerqf_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgesc2_(IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __rhs, IntPtr __ipiv,
            IntPtr __jpiv, DoublePtr __scale);

    @Generated
    @CFunction
    public static native int dgesdd_(BytePtr __jobz, IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __s,
            DoublePtr __u, IntPtr __ldu, DoublePtr __vt, IntPtr __ldvt, DoublePtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgesv_(IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda, IntPtr __ipiv,
            DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgesvd_(BytePtr __jobu, BytePtr __jobvt, IntPtr __m, IntPtr __n, DoublePtr __a,
            IntPtr __lda, DoublePtr __s, DoublePtr __u, IntPtr __ldu, DoublePtr __vt, IntPtr __ldvt, DoublePtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgesvj_(BytePtr __joba, BytePtr __jobu, BytePtr __jobv, IntPtr __m, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __sva, IntPtr __mv, DoublePtr __v, IntPtr __ldv, DoublePtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgesvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __nrhs, DoublePtr __a,
            IntPtr __lda, DoublePtr __af, IntPtr __ldaf, IntPtr __ipiv, BytePtr __equed, DoublePtr __r__,
            DoublePtr __c__, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __rcond,
            DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgetc2_(IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __ipiv, IntPtr __jpiv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dgetf2_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgetrf_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgetri_(IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __ipiv, DoublePtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgetrs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dggbak_(BytePtr __job, BytePtr __side, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __lscale, DoublePtr __rscale, IntPtr __m, DoublePtr __v, IntPtr __ldv, IntPtr __info);

    @Generated
    @CFunction
    public static native int dggbal_(BytePtr __job, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __b,
            IntPtr __ldb, IntPtr __ilo, IntPtr __ihi, DoublePtr __lscale, DoublePtr __rscale, DoublePtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dggev_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, DoublePtr __alphar, DoublePtr __alphai, DoublePtr __beta, DoublePtr __vl,
            IntPtr __ldvl, DoublePtr __vr, IntPtr __ldvr, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dggevx_(BytePtr __balanc, BytePtr __jobvl, BytePtr __jobvr, BytePtr __sense, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __alphar, DoublePtr __alphai,
            DoublePtr __beta, DoublePtr __vl, IntPtr __ldvl, DoublePtr __vr, IntPtr __ldvr, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __lscale, DoublePtr __rscale, DoublePtr __abnrm, DoublePtr __bbnrm, DoublePtr __rconde,
            DoublePtr __rcondv, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __bwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dggglm_(IntPtr __n, IntPtr __m, IntPtr __p, DoublePtr __a, IntPtr __lda, DoublePtr __b,
            IntPtr __ldb, DoublePtr __d__, DoublePtr __x, DoublePtr __y, DoublePtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dgghrd_(BytePtr __compq, BytePtr __compz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __q, IntPtr __ldq, DoublePtr __z__,
            IntPtr __ldz, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgglse_(IntPtr __m, IntPtr __n, IntPtr __p, DoublePtr __a, IntPtr __lda, DoublePtr __b,
            IntPtr __ldb, DoublePtr __c__, DoublePtr __d__, DoublePtr __x, DoublePtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dggqrf_(IntPtr __n, IntPtr __m, IntPtr __p, DoublePtr __a, IntPtr __lda, DoublePtr __taua,
            DoublePtr __b, IntPtr __ldb, DoublePtr __taub, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dggrqf_(IntPtr __m, IntPtr __p, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __taua,
            DoublePtr __b, IntPtr __ldb, DoublePtr __taub, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dggsvd_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __n, IntPtr __p,
            IntPtr __k, IntPtr __l, DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __alpha,
            DoublePtr __beta, DoublePtr __u, IntPtr __ldu, DoublePtr __v, IntPtr __ldv, DoublePtr __q, IntPtr __ldq,
            DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dggsvp_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __p, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __tola, DoublePtr __tolb, IntPtr __k,
            IntPtr __l, DoublePtr __u, IntPtr __ldu, DoublePtr __v, IntPtr __ldv, DoublePtr __q, IntPtr __ldq,
            IntPtr __iwork, DoublePtr __tau, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgsvj0_(BytePtr __jobv, IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __d__, DoublePtr __sva, IntPtr __mv, DoublePtr __v, IntPtr __ldv, DoublePtr __eps,
            DoublePtr __sfmin, DoublePtr __tol, IntPtr __nsweep, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgsvj1_(BytePtr __jobv, IntPtr __m, IntPtr __n, IntPtr __n1, DoublePtr __a, IntPtr __lda,
            DoublePtr __d__, DoublePtr __sva, IntPtr __mv, DoublePtr __v, IntPtr __ldv, DoublePtr __eps,
            DoublePtr __sfmin, DoublePtr __tol, IntPtr __nsweep, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgtcon_(BytePtr __norm, IntPtr __n, DoublePtr __dl, DoublePtr __d__, DoublePtr __du,
            DoublePtr __du2, IntPtr __ipiv, DoublePtr __anorm, DoublePtr __rcond, DoublePtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dgtrfs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, DoublePtr __dl, DoublePtr __d__,
            DoublePtr __du, DoublePtr __dlf, DoublePtr __df, DoublePtr __duf, DoublePtr __du2, IntPtr __ipiv,
            DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __ferr, DoublePtr __berr,
            DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgtsv_(IntPtr __n, IntPtr __nrhs, DoublePtr __dl, DoublePtr __d__, DoublePtr __du,
            DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgtsvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __nrhs, DoublePtr __dl,
            DoublePtr __d__, DoublePtr __du, DoublePtr __dlf, DoublePtr __df, DoublePtr __duf, DoublePtr __du2,
            IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __rcond,
            DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgttrf_(IntPtr __n, DoublePtr __dl, DoublePtr __d__, DoublePtr __du, DoublePtr __du2,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgttrs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, DoublePtr __dl, DoublePtr __d__,
            DoublePtr __du, DoublePtr __du2, IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dgtts2_(IntPtr __itrans, IntPtr __n, IntPtr __nrhs, DoublePtr __dl, DoublePtr __d__,
            DoublePtr __du, DoublePtr __du2, IntPtr __ipiv, DoublePtr __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int dhgeqz_(BytePtr __job, BytePtr __compq, BytePtr __compz, IntPtr __n, IntPtr __ilo,
            IntPtr __ihi, DoublePtr __h__, IntPtr __ldh, DoublePtr __t, IntPtr __ldt, DoublePtr __alphar,
            DoublePtr __alphai, DoublePtr __beta, DoublePtr __q, IntPtr __ldq, DoublePtr __z__, IntPtr __ldz,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dhsein_(BytePtr __side, BytePtr __eigsrc, BytePtr __initv, IntPtr __select, IntPtr __n,
            DoublePtr __h__, IntPtr __ldh, DoublePtr __wr, DoublePtr __wi, DoublePtr __vl, IntPtr __ldvl,
            DoublePtr __vr, IntPtr __ldvr, IntPtr __mm, IntPtr __m, DoublePtr __work, IntPtr __ifaill, IntPtr __ifailr,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dhseqr_(BytePtr __job, BytePtr __compz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __h__, IntPtr __ldh, DoublePtr __wr, DoublePtr __wi, DoublePtr __z__, IntPtr __ldz,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int disnan_(DoublePtr __din);

    @Generated
    @CFunction
    public static native int dlabad_(DoublePtr __small, DoublePtr __large);

    @Generated
    @CFunction
    public static native int dlabrd_(IntPtr __m, IntPtr __n, IntPtr __nb, DoublePtr __a, IntPtr __lda, DoublePtr __d__,
            DoublePtr __e, DoublePtr __tauq, DoublePtr __taup, DoublePtr __x, IntPtr __ldx, DoublePtr __y,
            IntPtr __ldy);

    @Generated
    @CFunction
    public static native int dlacn2_(IntPtr __n, DoublePtr __v, DoublePtr __x, IntPtr __isgn, DoublePtr __est,
            IntPtr __kase, IntPtr __isave);

    @Generated
    @CFunction
    public static native int dlacon_(IntPtr __n, DoublePtr __v, DoublePtr __x, IntPtr __isgn, DoublePtr __est,
            IntPtr __kase);

    @Generated
    @CFunction
    public static native int dlacpy_(BytePtr __uplo, IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __b,
            IntPtr __ldb);

    @Generated
    @CFunction
    public static native int dladiv_(DoublePtr __a, DoublePtr __b, DoublePtr __c__, DoublePtr __d__, DoublePtr __p,
            DoublePtr __q);

    @Generated
    @CFunction
    public static native int dlae2_(DoublePtr __a, DoublePtr __b, DoublePtr __c__, DoublePtr __rt1, DoublePtr __rt2);

    @Generated
    @CFunction
    public static native int dlaebz_(IntPtr __ijob, IntPtr __nitmax, IntPtr __n, IntPtr __mmax, IntPtr __minp,
            IntPtr __nbmin, DoublePtr __abstol, DoublePtr __reltol, DoublePtr __pivmin, DoublePtr __d__, DoublePtr __e,
            DoublePtr __e2, IntPtr __nval, DoublePtr __ab, DoublePtr __c__, IntPtr __mout, IntPtr __nab,
            DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaed0_(IntPtr __icompq, IntPtr __qsiz, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            DoublePtr __q, IntPtr __ldq, DoublePtr __qstore, IntPtr __ldqs, DoublePtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaed1_(IntPtr __n, DoublePtr __d__, DoublePtr __q, IntPtr __ldq, IntPtr __indxq,
            DoublePtr __rho, IntPtr __cutpnt, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaed2_(IntPtr __k, IntPtr __n, IntPtr __n1, DoublePtr __d__, DoublePtr __q, IntPtr __ldq,
            IntPtr __indxq, DoublePtr __rho, DoublePtr __z__, DoublePtr __dlamda, DoublePtr __w, DoublePtr __q2,
            IntPtr __indx, IntPtr __indxc, IntPtr __indxp, IntPtr __coltyp, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaed3_(IntPtr __k, IntPtr __n, IntPtr __n1, DoublePtr __d__, DoublePtr __q, IntPtr __ldq,
            DoublePtr __rho, DoublePtr __dlamda, DoublePtr __q2, IntPtr __indx, IntPtr __ctot, DoublePtr __w,
            DoublePtr __s, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaed4_(IntPtr __n, IntPtr __i__, DoublePtr __d__, DoublePtr __z__, DoublePtr __delta,
            DoublePtr __rho, DoublePtr __dlam, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaed5_(IntPtr __i__, DoublePtr __d__, DoublePtr __z__, DoublePtr __delta, DoublePtr __rho,
            DoublePtr __dlam);

    @Generated
    @CFunction
    public static native int dlaed6_(IntPtr __kniter, IntPtr __orgati, DoublePtr __rho, DoublePtr __d__,
            DoublePtr __z__, DoublePtr __finit, DoublePtr __tau, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaed7_(IntPtr __icompq, IntPtr __n, IntPtr __qsiz, IntPtr __tlvls, IntPtr __curlvl,
            IntPtr __curpbm, DoublePtr __d__, DoublePtr __q, IntPtr __ldq, IntPtr __indxq, DoublePtr __rho,
            IntPtr __cutpnt, DoublePtr __qstore, IntPtr __qptr, IntPtr __prmptr, IntPtr __perm, IntPtr __givptr,
            IntPtr __givcol, DoublePtr __givnum, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaed8_(IntPtr __icompq, IntPtr __k, IntPtr __n, IntPtr __qsiz, DoublePtr __d__,
            DoublePtr __q, IntPtr __ldq, IntPtr __indxq, DoublePtr __rho, IntPtr __cutpnt, DoublePtr __z__,
            DoublePtr __dlamda, DoublePtr __q2, IntPtr __ldq2, DoublePtr __w, IntPtr __perm, IntPtr __givptr,
            IntPtr __givcol, DoublePtr __givnum, IntPtr __indxp, IntPtr __indx, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaed9_(IntPtr __k, IntPtr __kstart, IntPtr __kstop, IntPtr __n, DoublePtr __d__,
            DoublePtr __q, IntPtr __ldq, DoublePtr __rho, DoublePtr __dlamda, DoublePtr __w, DoublePtr __s,
            IntPtr __lds, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaeda_(IntPtr __n, IntPtr __tlvls, IntPtr __curlvl, IntPtr __curpbm, IntPtr __prmptr,
            IntPtr __perm, IntPtr __givptr, IntPtr __givcol, DoublePtr __givnum, DoublePtr __q, IntPtr __qptr,
            DoublePtr __z__, DoublePtr __ztemp, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaein_(IntPtr __rightv, IntPtr __noinit, IntPtr __n, DoublePtr __h__, IntPtr __ldh,
            DoublePtr __wr, DoublePtr __wi, DoublePtr __vr, DoublePtr __vi, DoublePtr __b, IntPtr __ldb,
            DoublePtr __work, DoublePtr __eps3, DoublePtr __smlnum, DoublePtr __bignum, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaev2_(DoublePtr __a, DoublePtr __b, DoublePtr __c__, DoublePtr __rt1, DoublePtr __rt2,
            DoublePtr __cs1, DoublePtr __sn1);

    @Generated
    @CFunction
    public static native int dlaexc_(IntPtr __wantq, IntPtr __n, DoublePtr __t, IntPtr __ldt, DoublePtr __q,
            IntPtr __ldq, IntPtr __j1, IntPtr __n1, IntPtr __n2, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlag2_(DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __safmin,
            DoublePtr __scale1, DoublePtr __scale2, DoublePtr __wr1, DoublePtr __wr2, DoublePtr __wi);

    @Generated
    @CFunction
    public static native int dlag2s_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, FloatPtr __sa, IntPtr __ldsa,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dlags2_(IntPtr __upper, DoublePtr __a1, DoublePtr __a2, DoublePtr __a3, DoublePtr __b1,
            DoublePtr __b2, DoublePtr __b3, DoublePtr __csu, DoublePtr __snu, DoublePtr __csv, DoublePtr __snv,
            DoublePtr __csq, DoublePtr __snq);

    @Generated
    @CFunction
    public static native int dlagtf_(IntPtr __n, DoublePtr __a, DoublePtr __lambda, DoublePtr __b, DoublePtr __c__,
            DoublePtr __tol, DoublePtr __d__, IntPtr __in, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlagtm_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, DoublePtr __alpha, DoublePtr __dl,
            DoublePtr __d__, DoublePtr __du, DoublePtr __x, IntPtr __ldx, DoublePtr __beta, DoublePtr __b,
            IntPtr __ldb);

    @Generated
    @CFunction
    public static native int dlagts_(IntPtr __job, IntPtr __n, DoublePtr __a, DoublePtr __b, DoublePtr __c__,
            DoublePtr __d__, IntPtr __in, DoublePtr __y, DoublePtr __tol, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlagv2_(DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __alphar,
            DoublePtr __alphai, DoublePtr __beta, DoublePtr __csl, DoublePtr __snl, DoublePtr __csr, DoublePtr __snr);

    @Generated
    @CFunction
    public static native int dlahqr_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __h__, IntPtr __ldh, DoublePtr __wr, DoublePtr __wi, IntPtr __iloz, IntPtr __ihiz,
            DoublePtr __z__, IntPtr __ldz, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlahr2_(IntPtr __n, IntPtr __k, IntPtr __nb, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __t, IntPtr __ldt, DoublePtr __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int dlahrd_(IntPtr __n, IntPtr __k, IntPtr __nb, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __t, IntPtr __ldt, DoublePtr __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int dlaic1_(IntPtr __job, IntPtr __j, DoublePtr __x, DoublePtr __sest, DoublePtr __w,
            DoublePtr __gamma, DoublePtr __sestpr, DoublePtr __s, DoublePtr __c__);

    @Generated
    @CFunction
    public static native int dlaisnan_(DoublePtr __din1, DoublePtr __din2);

    @Generated
    @CFunction
    public static native int dlaln2_(IntPtr __ltrans, IntPtr __na, IntPtr __nw, DoublePtr __smin, DoublePtr __ca,
            DoublePtr __a, IntPtr __lda, DoublePtr __d1, DoublePtr __d2, DoublePtr __b, IntPtr __ldb, DoublePtr __wr,
            DoublePtr __wi, DoublePtr __x, IntPtr __ldx, DoublePtr __scale, DoublePtr __xnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlals0_(IntPtr __icompq, IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __nrhs,
            DoublePtr __b, IntPtr __ldb, DoublePtr __bx, IntPtr __ldbx, IntPtr __perm, IntPtr __givptr, IntPtr __givcol,
            IntPtr __ldgcol, DoublePtr __givnum, IntPtr __ldgnum, DoublePtr __poles, DoublePtr __difl, DoublePtr __difr,
            DoublePtr __z__, IntPtr __k, DoublePtr __c__, DoublePtr __s, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlalsa_(IntPtr __icompq, IntPtr __smlsiz, IntPtr __n, IntPtr __nrhs, DoublePtr __b,
            IntPtr __ldb, DoublePtr __bx, IntPtr __ldbx, DoublePtr __u, IntPtr __ldu, DoublePtr __vt, IntPtr __k,
            DoublePtr __difl, DoublePtr __difr, DoublePtr __z__, DoublePtr __poles, IntPtr __givptr, IntPtr __givcol,
            IntPtr __ldgcol, IntPtr __perm, DoublePtr __givnum, DoublePtr __c__, DoublePtr __s, DoublePtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlalsd_(BytePtr __uplo, IntPtr __smlsiz, IntPtr __n, IntPtr __nrhs, DoublePtr __d__,
            DoublePtr __e, DoublePtr __b, IntPtr __ldb, DoublePtr __rcond, IntPtr __rank, DoublePtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlamrg_(IntPtr __n1, IntPtr __n2, DoublePtr __a, IntPtr __dtrd1, IntPtr __dtrd2,
            IntPtr __index);

    @Generated
    @CFunction
    public static native int dlaneg_(IntPtr __n, DoublePtr __d__, DoublePtr __lld, DoublePtr __sigma,
            DoublePtr __pivmin, IntPtr __r__);

    @Generated
    @CFunction
    public static native double dlangb_(BytePtr __norm, IntPtr __n, IntPtr __kl, IntPtr __ku, DoublePtr __ab,
            IntPtr __ldab, DoublePtr __work);

    @Generated
    @CFunction
    public static native double dlange_(BytePtr __norm, IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double dlangt_(BytePtr __norm, IntPtr __n, DoublePtr __dl, DoublePtr __d__, DoublePtr __du);

    @Generated
    @CFunction
    public static native double dlanhs_(BytePtr __norm, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __work);

    @Generated
    @CFunction
    public static native double dlansb_(BytePtr __norm, BytePtr __uplo, IntPtr __n, IntPtr __k, DoublePtr __ab,
            IntPtr __ldab, DoublePtr __work);

    @Generated
    @CFunction
    public static native double dlansf_(BytePtr __norm, BytePtr __transr, BytePtr __uplo, IntPtr __n, DoublePtr __a,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double dlansp_(BytePtr __norm, BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __work);

    @Generated
    @CFunction
    public static native double dlanst_(BytePtr __norm, IntPtr __n, DoublePtr __d__, DoublePtr __e);

    @Generated
    @CFunction
    public static native double dlansy_(BytePtr __norm, BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double dlantb_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, IntPtr __k,
            DoublePtr __ab, IntPtr __ldab, DoublePtr __work);

    @Generated
    @CFunction
    public static native double dlantp_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, DoublePtr __ap,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double dlantr_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __m, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __work);

    @Generated
    @CFunction
    public static native int dlanv2_(DoublePtr __a, DoublePtr __b, DoublePtr __c__, DoublePtr __d__, DoublePtr __rt1r,
            DoublePtr __rt1i, DoublePtr __rt2r, DoublePtr __rt2i, DoublePtr __cs, DoublePtr __sn);

    @Generated
    @CFunction
    public static native int dlapll_(IntPtr __n, DoublePtr __x, IntPtr __incx, DoublePtr __y, IntPtr __incy,
            DoublePtr __ssmin);

    @Generated
    @CFunction
    public static native int dlapmt_(IntPtr __forwrd, IntPtr __m, IntPtr __n, DoublePtr __x, IntPtr __ldx, IntPtr __k);

    @Generated
    @CFunction
    public static native double dlapy2_(DoublePtr __x, DoublePtr __y);

    @Generated
    @CFunction
    public static native double dlapy3_(DoublePtr __x, DoublePtr __y, DoublePtr __z__);

    @Generated
    @CFunction
    public static native int dlaqgb_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, DoublePtr __ab, IntPtr __ldab,
            DoublePtr __r__, DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax,
            BytePtr __equed);

    @Generated
    @CFunction
    public static native int dlaqge_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __r__,
            DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int dlaqp2_(IntPtr __m, IntPtr __n, IntPtr __offset, DoublePtr __a, IntPtr __lda,
            IntPtr __jpvt, DoublePtr __tau, DoublePtr __vn1, DoublePtr __vn2, DoublePtr __work);

    @Generated
    @CFunction
    public static native int dlaqps_(IntPtr __m, IntPtr __n, IntPtr __offset, IntPtr __nb, IntPtr __kb, DoublePtr __a,
            IntPtr __lda, IntPtr __jpvt, DoublePtr __tau, DoublePtr __vn1, DoublePtr __vn2, DoublePtr __auxv,
            DoublePtr __f, IntPtr __ldf);

    @Generated
    @CFunction
    public static native int dlaqr0_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __h__, IntPtr __ldh, DoublePtr __wr, DoublePtr __wi, IntPtr __iloz, IntPtr __ihiz,
            DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaqr1_(IntPtr __n, DoublePtr __h__, IntPtr __ldh, DoublePtr __sr1, DoublePtr __si1,
            DoublePtr __sr2, DoublePtr __si2, DoublePtr __v);

    @Generated
    @CFunction
    public static native int dlaqr2_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ktop, IntPtr __kbot,
            IntPtr __nw, DoublePtr __h__, IntPtr __ldh, IntPtr __iloz, IntPtr __ihiz, DoublePtr __z__, IntPtr __ldz,
            IntPtr __ns, IntPtr __nd, DoublePtr __sr, DoublePtr __si, DoublePtr __v, IntPtr __ldv, IntPtr __nh,
            DoublePtr __t, IntPtr __ldt, IntPtr __nv, DoublePtr __wv, IntPtr __ldwv, DoublePtr __work, IntPtr __lwork);

    @Generated
    @CFunction
    public static native int dlaqr3_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ktop, IntPtr __kbot,
            IntPtr __nw, DoublePtr __h__, IntPtr __ldh, IntPtr __iloz, IntPtr __ihiz, DoublePtr __z__, IntPtr __ldz,
            IntPtr __ns, IntPtr __nd, DoublePtr __sr, DoublePtr __si, DoublePtr __v, IntPtr __ldv, IntPtr __nh,
            DoublePtr __t, IntPtr __ldt, IntPtr __nv, DoublePtr __wv, IntPtr __ldwv, DoublePtr __work, IntPtr __lwork);

    @Generated
    @CFunction
    public static native int dlaqr4_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __h__, IntPtr __ldh, DoublePtr __wr, DoublePtr __wi, IntPtr __iloz, IntPtr __ihiz,
            DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlaqr5_(IntPtr __wantt, IntPtr __wantz, IntPtr __kacc22, IntPtr __n, IntPtr __ktop,
            IntPtr __kbot, IntPtr __nshfts, DoublePtr __sr, DoublePtr __si, DoublePtr __h__, IntPtr __ldh,
            IntPtr __iloz, IntPtr __ihiz, DoublePtr __z__, IntPtr __ldz, DoublePtr __v, IntPtr __ldv, DoublePtr __u,
            IntPtr __ldu, IntPtr __nv, DoublePtr __wv, IntPtr __ldwv, IntPtr __nh, DoublePtr __wh, IntPtr __ldwh);

    @Generated
    @CFunction
    public static native int dlaqsb_(BytePtr __uplo, IntPtr __n, IntPtr __kd, DoublePtr __ab, IntPtr __ldab,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int dlaqsp_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __s, DoublePtr __scond,
            DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int dlaqsy_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __s,
            DoublePtr __scond, DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int dlaqtr_(IntPtr __ltran, IntPtr __l__CLPK_real, IntPtr __n, DoublePtr __t, IntPtr __ldt,
            DoublePtr __b, DoublePtr __w, DoublePtr __scale, DoublePtr __x, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlar1v_(IntPtr __n, IntPtr __b1, IntPtr __bn, DoublePtr __lambda, DoublePtr __d__,
            DoublePtr __l, DoublePtr __ld, DoublePtr __lld, DoublePtr __pivmin, DoublePtr __gaptol, DoublePtr __z__,
            IntPtr __wantnc, IntPtr __negcnt, DoublePtr __ztz, DoublePtr __mingma, IntPtr __r__, IntPtr __isuppz,
            DoublePtr __nrminv, DoublePtr __resid, DoublePtr __rqcorr, DoublePtr __work);

    @Generated
    @CFunction
    public static native int dlar2v_(IntPtr __n, DoublePtr __x, DoublePtr __y, DoublePtr __z__, IntPtr __incx,
            DoublePtr __c__, DoublePtr __s, IntPtr __incc);

    @Generated
    @CFunction
    public static native int dlarf_(BytePtr __side, IntPtr __m, IntPtr __n, DoublePtr __v, IntPtr __incv,
            DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work);

    @Generated
    @CFunction
    public static native int dlarfb_(BytePtr __side, BytePtr __trans, BytePtr __direct, BytePtr __storev, IntPtr __m,
            IntPtr __n, IntPtr __k, DoublePtr __v, IntPtr __ldv, DoublePtr __t, IntPtr __ldt, DoublePtr __c__,
            IntPtr __ldc, DoublePtr __work, IntPtr __ldwork);

    @Generated
    @CFunction
    public static native int dlarfg_(IntPtr __n, DoublePtr __alpha, DoublePtr __x, IntPtr __incx, DoublePtr __tau);

    @Generated
    @CFunction
    public static native int dlarfp_(IntPtr __n, DoublePtr __alpha, DoublePtr __x, IntPtr __incx, DoublePtr __tau);

    @Generated
    @CFunction
    public static native int dlarft_(BytePtr __direct, BytePtr __storev, IntPtr __n, IntPtr __k, DoublePtr __v,
            IntPtr __ldv, DoublePtr __tau, DoublePtr __t, IntPtr __ldt);

    @Generated
    @CFunction
    public static native int dlarfx_(BytePtr __side, IntPtr __m, IntPtr __n, DoublePtr __v, DoublePtr __tau,
            DoublePtr __c__, IntPtr __ldc, DoublePtr __work);

    @Generated
    @CFunction
    public static native int dlargv_(IntPtr __n, DoublePtr __x, IntPtr __incx, DoublePtr __y, IntPtr __incy,
            DoublePtr __c__, IntPtr __incc);

    @Generated
    @CFunction
    public static native int dlarnv_(IntPtr __idist, IntPtr __iseed, IntPtr __n, DoublePtr __x);

    @Generated
    @CFunction
    public static native int dlarra_(IntPtr __n, DoublePtr __d__, DoublePtr __e, DoublePtr __e2, DoublePtr __spltol,
            DoublePtr __tnrm, IntPtr __nsplit, IntPtr __isplit, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarrb_(IntPtr __n, DoublePtr __d__, DoublePtr __lld, IntPtr __ifirst, IntPtr __ilast,
            DoublePtr __rtol1, DoublePtr __rtol2, IntPtr __offset, DoublePtr __w, DoublePtr __wgap, DoublePtr __werr,
            DoublePtr __work, IntPtr __iwork, DoublePtr __pivmin, DoublePtr __spdiam, IntPtr __twist, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarrc_(BytePtr __jobt, IntPtr __n, DoublePtr __vl, DoublePtr __vu, DoublePtr __d__,
            DoublePtr __e, DoublePtr __pivmin, IntPtr __eigcnt, IntPtr __lcnt, IntPtr __rcnt, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarrd_(BytePtr __range, BytePtr __order, IntPtr __n, DoublePtr __vl, DoublePtr __vu,
            IntPtr __il, IntPtr __iu, DoublePtr __gers, DoublePtr __reltol, DoublePtr __d__, DoublePtr __e,
            DoublePtr __e2, DoublePtr __pivmin, IntPtr __nsplit, IntPtr __isplit, IntPtr __m, DoublePtr __w,
            DoublePtr __werr, DoublePtr __wl, DoublePtr __wu, IntPtr __iblock, IntPtr __indexw, DoublePtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarre_(BytePtr __range, IntPtr __n, DoublePtr __vl, DoublePtr __vu, IntPtr __il,
            IntPtr __iu, DoublePtr __d__, DoublePtr __e, DoublePtr __e2, DoublePtr __rtol1, DoublePtr __rtol2,
            DoublePtr __spltol, IntPtr __nsplit, IntPtr __isplit, IntPtr __m, DoublePtr __w, DoublePtr __werr,
            DoublePtr __wgap, IntPtr __iblock, IntPtr __indexw, DoublePtr __gers, DoublePtr __pivmin, DoublePtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarrf_(IntPtr __n, DoublePtr __d__, DoublePtr __l, DoublePtr __ld, IntPtr __clstrt,
            IntPtr __clend, DoublePtr __w, DoublePtr __wgap, DoublePtr __werr, DoublePtr __spdiam, DoublePtr __clgapl,
            DoublePtr __clgapr, DoublePtr __pivmin, DoublePtr __sigma, DoublePtr __dplus, DoublePtr __lplus,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarrj_(IntPtr __n, DoublePtr __d__, DoublePtr __e2, IntPtr __ifirst, IntPtr __ilast,
            DoublePtr __rtol, IntPtr __offset, DoublePtr __w, DoublePtr __werr, DoublePtr __work, IntPtr __iwork,
            DoublePtr __pivmin, DoublePtr __spdiam, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarrk_(IntPtr __n, IntPtr __iw, DoublePtr __gl, DoublePtr __gu, DoublePtr __d__,
            DoublePtr __e2, DoublePtr __pivmin, DoublePtr __reltol, DoublePtr __w, DoublePtr __werr, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarrr_(IntPtr __n, DoublePtr __d__, DoublePtr __e, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarrv_(IntPtr __n, DoublePtr __vl, DoublePtr __vu, DoublePtr __d__, DoublePtr __l,
            DoublePtr __pivmin, IntPtr __isplit, IntPtr __m, IntPtr __dol, IntPtr __dou, DoublePtr __minrgp,
            DoublePtr __rtol1, DoublePtr __rtol2, DoublePtr __w, DoublePtr __werr, DoublePtr __wgap, IntPtr __iblock,
            IntPtr __indexw, DoublePtr __gers, DoublePtr __z__, IntPtr __ldz, IntPtr __isuppz, DoublePtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlarscl2_(IntPtr __m, IntPtr __n, DoublePtr __d__, DoublePtr __x, IntPtr __ldx);

    @Generated
    @CFunction
    public static native int dlartg_(DoublePtr __f, DoublePtr __g, DoublePtr __cs, DoublePtr __sn, DoublePtr __r__);

    @Generated
    @CFunction
    public static native int dlartv_(IntPtr __n, DoublePtr __x, IntPtr __incx, DoublePtr __y, IntPtr __incy,
            DoublePtr __c__, DoublePtr __s, IntPtr __incc);

    @Generated
    @CFunction
    public static native int dlaruv_(IntPtr __iseed, IntPtr __n, DoublePtr __x);

    @Generated
    @CFunction
    public static native int dlarz_(BytePtr __side, IntPtr __m, IntPtr __n, IntPtr __l, DoublePtr __v, IntPtr __incv,
            DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work);

    @Generated
    @CFunction
    public static native int dlarzb_(BytePtr __side, BytePtr __trans, BytePtr __direct, BytePtr __storev, IntPtr __m,
            IntPtr __n, IntPtr __k, IntPtr __l, DoublePtr __v, IntPtr __ldv, DoublePtr __t, IntPtr __ldt,
            DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __ldwork);

    @Generated
    @CFunction
    public static native int dlarzt_(BytePtr __direct, BytePtr __storev, IntPtr __n, IntPtr __k, DoublePtr __v,
            IntPtr __ldv, DoublePtr __tau, DoublePtr __t, IntPtr __ldt);

    @Generated
    @CFunction
    public static native int dlas2_(DoublePtr __f, DoublePtr __g, DoublePtr __h__, DoublePtr __ssmin,
            DoublePtr __ssmax);

    @Generated
    @CFunction
    public static native int dlascl_(BytePtr __type__, IntPtr __kl, IntPtr __ku, DoublePtr __cfrom, DoublePtr __cto,
            IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlascl2_(IntPtr __m, IntPtr __n, DoublePtr __d__, DoublePtr __x, IntPtr __ldx);

    @Generated
    @CFunction
    public static native int dlasd0_(IntPtr __n, IntPtr __sqre, DoublePtr __d__, DoublePtr __e, DoublePtr __u,
            IntPtr __ldu, DoublePtr __vt, IntPtr __ldvt, IntPtr __smlsiz, IntPtr __iwork, DoublePtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasd1_(IntPtr __nl, IntPtr __nr, IntPtr __sqre, DoublePtr __d__, DoublePtr __alpha,
            DoublePtr __beta, DoublePtr __u, IntPtr __ldu, DoublePtr __vt, IntPtr __ldvt, IntPtr __idxq, IntPtr __iwork,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasd2_(IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __k, DoublePtr __d__,
            DoublePtr __z__, DoublePtr __alpha, DoublePtr __beta, DoublePtr __u, IntPtr __ldu, DoublePtr __vt,
            IntPtr __ldvt, DoublePtr __dsigma, DoublePtr __u2, IntPtr __ldu2, DoublePtr __vt2, IntPtr __ldvt2,
            IntPtr __idxp, IntPtr __idx, IntPtr __idxc, IntPtr __idxq, IntPtr __coltyp, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasd3_(IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __k, DoublePtr __d__,
            DoublePtr __q, IntPtr __ldq, DoublePtr __dsigma, DoublePtr __u, IntPtr __ldu, DoublePtr __u2, IntPtr __ldu2,
            DoublePtr __vt, IntPtr __ldvt, DoublePtr __vt2, IntPtr __ldvt2, IntPtr __idxc, IntPtr __ctot,
            DoublePtr __z__, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasd4_(IntPtr __n, IntPtr __i__, DoublePtr __d__, DoublePtr __z__, DoublePtr __delta,
            DoublePtr __rho, DoublePtr __sigma, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasd5_(IntPtr __i__, DoublePtr __d__, DoublePtr __z__, DoublePtr __delta, DoublePtr __rho,
            DoublePtr __dsigma, DoublePtr __work);

    @Generated
    @CFunction
    public static native int dlasd6_(IntPtr __icompq, IntPtr __nl, IntPtr __nr, IntPtr __sqre, DoublePtr __d__,
            DoublePtr __vf, DoublePtr __vl, DoublePtr __alpha, DoublePtr __beta, IntPtr __idxq, IntPtr __perm,
            IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, DoublePtr __givnum, IntPtr __ldgnum, DoublePtr __poles,
            DoublePtr __difl, DoublePtr __difr, DoublePtr __z__, IntPtr __k, DoublePtr __c__, DoublePtr __s,
            DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasd7_(IntPtr __icompq, IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __k,
            DoublePtr __d__, DoublePtr __z__, DoublePtr __zw, DoublePtr __vf, DoublePtr __vfw, DoublePtr __vl,
            DoublePtr __vlw, DoublePtr __alpha, DoublePtr __beta, DoublePtr __dsigma, IntPtr __idx, IntPtr __idxp,
            IntPtr __idxq, IntPtr __perm, IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, DoublePtr __givnum,
            IntPtr __ldgnum, DoublePtr __c__, DoublePtr __s, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasd8_(IntPtr __icompq, IntPtr __k, DoublePtr __d__, DoublePtr __z__, DoublePtr __vf,
            DoublePtr __vl, DoublePtr __difl, DoublePtr __difr, IntPtr __lddifr, DoublePtr __dsigma, DoublePtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasda_(IntPtr __icompq, IntPtr __smlsiz, IntPtr __n, IntPtr __sqre, DoublePtr __d__,
            DoublePtr __e, DoublePtr __u, IntPtr __ldu, DoublePtr __vt, IntPtr __k, DoublePtr __difl, DoublePtr __difr,
            DoublePtr __z__, DoublePtr __poles, IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, IntPtr __perm,
            DoublePtr __givnum, DoublePtr __c__, DoublePtr __s, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasdq_(BytePtr __uplo, IntPtr __sqre, IntPtr __n, IntPtr __ncvt, IntPtr __nru,
            IntPtr __ncc, DoublePtr __d__, DoublePtr __e, DoublePtr __vt, IntPtr __ldvt, DoublePtr __u, IntPtr __ldu,
            DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasdt_(IntPtr __n, IntPtr __lvl, IntPtr __nd, IntPtr __inode, IntPtr __ndiml,
            IntPtr __ndimr, IntPtr __msub);

    @Generated
    @CFunction
    public static native int dlaset_(BytePtr __uplo, IntPtr __m, IntPtr __n, DoublePtr __alpha, DoublePtr __beta,
            DoublePtr __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int dlasq1_(IntPtr __n, DoublePtr __d__, DoublePtr __e, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasq2_(IntPtr __n, DoublePtr __z__, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasq3_(IntPtr __i0, IntPtr __n0, DoublePtr __z__, IntPtr __pp, DoublePtr __dmin__,
            DoublePtr __sigma, DoublePtr __desig, DoublePtr __qmax, IntPtr __nfail, IntPtr __iter, IntPtr __ndiv,
            IntPtr __ieee, IntPtr __ttype, DoublePtr __dmin1, DoublePtr __dmin2, DoublePtr __dn, DoublePtr __dn1,
            DoublePtr __dn2, DoublePtr __g, DoublePtr __tau);

    @Generated
    @CFunction
    public static native int dlasq4_(IntPtr __i0, IntPtr __n0, DoublePtr __z__, IntPtr __pp, IntPtr __n0in,
            DoublePtr __dmin__, DoublePtr __dmin1, DoublePtr __dmin2, DoublePtr __dn, DoublePtr __dn1, DoublePtr __dn2,
            DoublePtr __tau, IntPtr __ttype, DoublePtr __g);

    @Generated
    @CFunction
    public static native int dlasq5_(IntPtr __i0, IntPtr __n0, DoublePtr __z__, IntPtr __pp, DoublePtr __tau,
            DoublePtr __dmin__, DoublePtr __dmin1, DoublePtr __dmin2, DoublePtr __dn, DoublePtr __dnm1,
            DoublePtr __dnm2, IntPtr __ieee);

    @Generated
    @CFunction
    public static native int dlasq6_(IntPtr __i0, IntPtr __n0, DoublePtr __z__, IntPtr __pp, DoublePtr __dmin__,
            DoublePtr __dmin1, DoublePtr __dmin2, DoublePtr __dn, DoublePtr __dnm1, DoublePtr __dnm2);

    @Generated
    @CFunction
    public static native int dlasr_(BytePtr __side, BytePtr __pivot, BytePtr __direct, IntPtr __m, IntPtr __n,
            DoublePtr __c__, DoublePtr __s, DoublePtr __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int dlasrt_(BytePtr __id, IntPtr __n, DoublePtr __d__, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlassq_(IntPtr __n, DoublePtr __x, IntPtr __incx, DoublePtr __scale, DoublePtr __sumsq);

    @Generated
    @CFunction
    public static native int dlasv2_(DoublePtr __f, DoublePtr __g, DoublePtr __h__, DoublePtr __ssmin,
            DoublePtr __ssmax, DoublePtr __snr, DoublePtr __csr, DoublePtr __snl, DoublePtr __csl);

    @Generated
    @CFunction
    public static native int dlaswp_(IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __k1, IntPtr __k2, IntPtr __ipiv,
            IntPtr __incx);

    @Generated
    @CFunction
    public static native int dlasy2_(IntPtr __ltranl, IntPtr __ltranr, IntPtr __isgn, IntPtr __n1, IntPtr __n2,
            DoublePtr __tl, IntPtr __ldtl, DoublePtr __tr, IntPtr __ldtr, DoublePtr __b, IntPtr __ldb,
            DoublePtr __scale, DoublePtr __x, IntPtr __ldx, DoublePtr __xnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlasyf_(BytePtr __uplo, IntPtr __n, IntPtr __nb, IntPtr __kb, DoublePtr __a, IntPtr __lda,
            IntPtr __ipiv, DoublePtr __w, IntPtr __ldw, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlat2s_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, FloatPtr __sa,
            IntPtr __ldsa, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlatbs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            IntPtr __kd, DoublePtr __ab, IntPtr __ldab, DoublePtr __x, DoublePtr __scale, DoublePtr __cnorm,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dlatdf_(IntPtr __ijob, IntPtr __n, DoublePtr __z__, IntPtr __ldz, DoublePtr __rhs,
            DoublePtr __rdsum, DoublePtr __rdscal, IntPtr __ipiv, IntPtr __jpiv);

    @Generated
    @CFunction
    public static native int dlatps_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            DoublePtr __ap, DoublePtr __x, DoublePtr __scale, DoublePtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlatrd_(BytePtr __uplo, IntPtr __n, IntPtr __nb, DoublePtr __a, IntPtr __lda,
            DoublePtr __e, DoublePtr __tau, DoublePtr __w, IntPtr __ldw);

    @Generated
    @CFunction
    public static native int dlatrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __x, DoublePtr __scale, DoublePtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlatrz_(IntPtr __m, IntPtr __n, IntPtr __l, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native int dlatzm_(BytePtr __side, IntPtr __m, IntPtr __n, DoublePtr __v, IntPtr __incv,
            DoublePtr __tau, DoublePtr __c1, DoublePtr __c2, IntPtr __ldc, DoublePtr __work);

    @Generated
    @CFunction
    public static native int dlauu2_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int dlauum_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int dopgtr_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __tau, DoublePtr __q,
            IntPtr __ldq, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dopmtr_(BytePtr __side, BytePtr __uplo, BytePtr __trans, IntPtr __m, IntPtr __n,
            DoublePtr __ap, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorg2l_(IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorg2r_(IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorgbr_(BytePtr __vect, IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a, IntPtr __lda,
            DoublePtr __tau, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorghr_(IntPtr __n, IntPtr __ilo, IntPtr __ihi, DoublePtr __a, IntPtr __lda,
            DoublePtr __tau, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorgl2_(IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorglq_(IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorgql_(IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorgqr_(IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorgr2_(IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorgrq_(IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorgtr_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorm2l_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a,
            IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorm2r_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a,
            IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dormbr_(BytePtr __vect, BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n,
            IntPtr __k, DoublePtr __a, IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dormhr_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __ilo,
            IntPtr __ihi, DoublePtr __a, IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dorml2_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a,
            IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dormlq_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a,
            IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dormql_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a,
            IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dormqr_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a,
            IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dormr2_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a,
            IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dormr3_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, IntPtr __l,
            DoublePtr __a, IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dormrq_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, DoublePtr __a,
            IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dormrz_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, IntPtr __l,
            DoublePtr __a, IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dormtr_(BytePtr __side, BytePtr __uplo, BytePtr __trans, IntPtr __m, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __tau, DoublePtr __c__, IntPtr __ldc, DoublePtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpbcon_(BytePtr __uplo, IntPtr __n, IntPtr __kd, DoublePtr __ab, IntPtr __ldab,
            DoublePtr __anorm, DoublePtr __rcond, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpbequ_(BytePtr __uplo, IntPtr __n, IntPtr __kd, DoublePtr __ab, IntPtr __ldab,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpbrfs_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs, DoublePtr __ab,
            IntPtr __ldab, DoublePtr __afb, IntPtr __ldafb, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpbstf_(BytePtr __uplo, IntPtr __n, IntPtr __kd, DoublePtr __ab, IntPtr __ldab,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dpbsv_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs, DoublePtr __ab,
            IntPtr __ldab, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpbsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            DoublePtr __ab, IntPtr __ldab, DoublePtr __afb, IntPtr __ldafb, BytePtr __equed, DoublePtr __s,
            DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __rcond, DoublePtr __ferr,
            DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpbtf2_(BytePtr __uplo, IntPtr __n, IntPtr __kd, DoublePtr __ab, IntPtr __ldab,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dpbtrf_(BytePtr __uplo, IntPtr __n, IntPtr __kd, DoublePtr __ab, IntPtr __ldab,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dpbtrs_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs, DoublePtr __ab,
            IntPtr __ldab, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpftrf_(BytePtr __transr, BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpftri_(BytePtr __transr, BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpftrs_(BytePtr __transr, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a,
            DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpocon_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __anorm,
            DoublePtr __rcond, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpoequ_(IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __s, DoublePtr __scond,
            DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpoequb_(IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __s, DoublePtr __scond,
            DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int dporfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            DoublePtr __af, IntPtr __ldaf, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __ferr,
            DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dposv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dposvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a,
            IntPtr __lda, DoublePtr __af, IntPtr __ldaf, BytePtr __equed, DoublePtr __s, DoublePtr __b, IntPtr __ldb,
            DoublePtr __x, IntPtr __ldx, DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr, DoublePtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpotf2_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpotrf_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpotri_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpotrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dppcon_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __anorm, DoublePtr __rcond,
            DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dppequ_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __s, DoublePtr __scond,
            DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __ap, DoublePtr __afp,
            DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __ferr, DoublePtr __berr,
            DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dppsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __ap, DoublePtr __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dppsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __ap,
            DoublePtr __afp, BytePtr __equed, DoublePtr __s, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpptrf_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpptri_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __ap, DoublePtr __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpstf2_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __piv,
            IntPtr __rank, DoublePtr __tol, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpstrf_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __piv,
            IntPtr __rank, DoublePtr __tol, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dptcon_(IntPtr __n, DoublePtr __d__, DoublePtr __e, DoublePtr __anorm, DoublePtr __rcond,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpteqr_(BytePtr __compz, IntPtr __n, DoublePtr __d__, DoublePtr __e, DoublePtr __z__,
            IntPtr __ldz, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dptrfs_(IntPtr __n, IntPtr __nrhs, DoublePtr __d__, DoublePtr __e, DoublePtr __df,
            DoublePtr __ef, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __ferr,
            DoublePtr __berr, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dptsv_(IntPtr __n, IntPtr __nrhs, DoublePtr __d__, DoublePtr __e, DoublePtr __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dptsvx_(BytePtr __fact, IntPtr __n, IntPtr __nrhs, DoublePtr __d__, DoublePtr __e,
            DoublePtr __df, DoublePtr __ef, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __rcond,
            DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpttrf_(IntPtr __n, DoublePtr __d__, DoublePtr __e, IntPtr __info);

    @Generated
    @CFunction
    public static native int dpttrs_(IntPtr __n, IntPtr __nrhs, DoublePtr __d__, DoublePtr __e, DoublePtr __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dptts2_(IntPtr __n, IntPtr __nrhs, DoublePtr __d__, DoublePtr __e, DoublePtr __b,
            IntPtr __ldb);

    @Generated
    @CFunction
    public static native int drscl_(IntPtr __n, DoublePtr __sa, DoublePtr __sx, IntPtr __incx);

    @Generated
    @CFunction
    public static native int dsbev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __kd, DoublePtr __ab,
            IntPtr __ldab, DoublePtr __w, DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsbevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __kd, DoublePtr __ab,
            IntPtr __ldab, DoublePtr __w, DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsbevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            DoublePtr __ab, IntPtr __ldab, DoublePtr __q, IntPtr __ldq, DoublePtr __vl, DoublePtr __vu, IntPtr __il,
            IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w, DoublePtr __z__, IntPtr __ldz, DoublePtr __work,
            IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsbgst_(BytePtr __vect, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            DoublePtr __ab, IntPtr __ldab, DoublePtr __bb, IntPtr __ldbb, DoublePtr __x, IntPtr __ldx, DoublePtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dsbgv_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            DoublePtr __ab, IntPtr __ldab, DoublePtr __bb, IntPtr __ldbb, DoublePtr __w, DoublePtr __z__, IntPtr __ldz,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsbgvd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            DoublePtr __ab, IntPtr __ldab, DoublePtr __bb, IntPtr __ldbb, DoublePtr __w, DoublePtr __z__, IntPtr __ldz,
            DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsbgvx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, IntPtr __ka,
            IntPtr __kb, DoublePtr __ab, IntPtr __ldab, DoublePtr __bb, IntPtr __ldbb, DoublePtr __q, IntPtr __ldq,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsbtrd_(BytePtr __vect, BytePtr __uplo, IntPtr __n, IntPtr __kd, DoublePtr __ab,
            IntPtr __ldab, DoublePtr __d__, DoublePtr __e, DoublePtr __q, IntPtr __ldq, DoublePtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dsfrk_(BytePtr __transr, BytePtr __uplo, BytePtr __trans, IntPtr __n, IntPtr __k,
            DoublePtr __alpha, DoublePtr __a, IntPtr __lda, DoublePtr __beta, DoublePtr __c__);

    @Generated
    @CFunction
    public static native int dsgesv_(IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda, IntPtr __ipiv,
            DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __work, FloatPtr __swork, IntPtr __iter,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dspcon_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, IntPtr __ipiv, DoublePtr __anorm,
            DoublePtr __rcond, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dspev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __w,
            DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dspevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __w,
            DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dspevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, DoublePtr __ap,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int dspgst_(IntPtr __itype, BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __bp,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dspgv_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n, DoublePtr __ap,
            DoublePtr __bp, DoublePtr __w, DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dspgvd_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n, DoublePtr __ap,
            DoublePtr __bp, DoublePtr __w, DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dspgvx_(IntPtr __itype, BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            DoublePtr __ap, DoublePtr __bp, DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu,
            DoublePtr __abstol, IntPtr __m, DoublePtr __w, DoublePtr __z__, IntPtr __ldz, DoublePtr __work,
            IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsposv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __work, FloatPtr __swork, IntPtr __iter,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dsprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __ap, DoublePtr __afp,
            IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __ferr, DoublePtr __berr,
            DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dspsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __ap, IntPtr __ipiv,
            DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dspsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __ap,
            DoublePtr __afp, IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __rcond,
            DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsptrd_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __d__, DoublePtr __e,
            DoublePtr __tau, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsptrf_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsptri_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, IntPtr __ipiv, DoublePtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dsptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __ap, IntPtr __ipiv,
            DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dstebz_(BytePtr __range, BytePtr __order, IntPtr __n, DoublePtr __vl, DoublePtr __vu,
            IntPtr __il, IntPtr __iu, DoublePtr __abstol, DoublePtr __d__, DoublePtr __e, IntPtr __m, IntPtr __nsplit,
            DoublePtr __w, IntPtr __iblock, IntPtr __isplit, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dstedc_(BytePtr __compz, IntPtr __n, DoublePtr __d__, DoublePtr __e, DoublePtr __z__,
            IntPtr __ldz, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dstegr_(BytePtr __jobz, BytePtr __range, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            DoublePtr __z__, IntPtr __ldz, IntPtr __isuppz, DoublePtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dstein_(IntPtr __n, DoublePtr __d__, DoublePtr __e, IntPtr __m, DoublePtr __w,
            IntPtr __iblock, IntPtr __isplit, DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __iwork,
            IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int dstemr_(BytePtr __jobz, BytePtr __range, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, IntPtr __m, DoublePtr __w, DoublePtr __z__,
            IntPtr __ldz, IntPtr __nzc, IntPtr __isuppz, IntPtr __tryrac, DoublePtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsteqr_(BytePtr __compz, IntPtr __n, DoublePtr __d__, DoublePtr __e, DoublePtr __z__,
            IntPtr __ldz, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsterf_(IntPtr __n, DoublePtr __d__, DoublePtr __e, IntPtr __info);

    @Generated
    @CFunction
    public static native int dstev_(BytePtr __jobz, IntPtr __n, DoublePtr __d__, DoublePtr __e, DoublePtr __z__,
            IntPtr __ldz, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dstevd_(BytePtr __jobz, IntPtr __n, DoublePtr __d__, DoublePtr __e, DoublePtr __z__,
            IntPtr __ldz, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dstevr_(BytePtr __jobz, BytePtr __range, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            DoublePtr __z__, IntPtr __ldz, IntPtr __isuppz, DoublePtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dstevx_(BytePtr __jobz, BytePtr __range, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsycon_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __ipiv,
            DoublePtr __anorm, DoublePtr __rcond, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsyequb_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __s,
            DoublePtr __scond, DoublePtr __amax, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsyev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __w, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsyevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __w, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsyevr_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, DoublePtr __a,
            IntPtr __lda, DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m,
            DoublePtr __w, DoublePtr __z__, IntPtr __ldz, IntPtr __isuppz, DoublePtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsyevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, DoublePtr __a,
            IntPtr __lda, DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m,
            DoublePtr __w, DoublePtr __z__, IntPtr __ldz, DoublePtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsygs2_(IntPtr __itype, BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsygst_(IntPtr __itype, BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsygv_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n, DoublePtr __a,
            IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __w, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsygvd_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n, DoublePtr __a,
            IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __w, DoublePtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsygvx_(IntPtr __itype, BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __vl, DoublePtr __vu, IntPtr __il,
            IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w, DoublePtr __z__, IntPtr __ldz, DoublePtr __work,
            IntPtr __lwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsyrfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            DoublePtr __af, IntPtr __ldaf, IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsysv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsysvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a,
            IntPtr __lda, DoublePtr __af, IntPtr __ldaf, IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, DoublePtr __x,
            IntPtr __ldx, DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsytd2_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __d__,
            DoublePtr __e, DoublePtr __tau, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsytf2_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __ipiv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dsytrd_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __d__,
            DoublePtr __e, DoublePtr __tau, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsytrf_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __ipiv,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsytri_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, IntPtr __ipiv,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dsytrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __a, IntPtr __lda,
            IntPtr __ipiv, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtbcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, IntPtr __kd,
            DoublePtr __ab, IntPtr __ldab, DoublePtr __rcond, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtbrfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __kd,
            IntPtr __nrhs, DoublePtr __ab, IntPtr __ldab, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtbtrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __kd,
            IntPtr __nrhs, DoublePtr __ab, IntPtr __ldab, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtfsm_(BytePtr __transr, BytePtr __side, BytePtr __uplo, BytePtr __trans, BytePtr __diag,
            IntPtr __m, IntPtr __n, DoublePtr __alpha, DoublePtr __a, DoublePtr __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int dtftri_(BytePtr __transr, BytePtr __uplo, BytePtr __diag, IntPtr __n, DoublePtr __a,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtfttp_(BytePtr __transr, BytePtr __uplo, IntPtr __n, DoublePtr __arf, DoublePtr __ap,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtfttr_(BytePtr __transr, BytePtr __uplo, IntPtr __n, DoublePtr __arf, DoublePtr __a,
            IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtgevc_(BytePtr __side, BytePtr __howmny, IntPtr __select, IntPtr __n, DoublePtr __s,
            IntPtr __lds, DoublePtr __p, IntPtr __ldp, DoublePtr __vl, IntPtr __ldvl, DoublePtr __vr, IntPtr __ldvr,
            IntPtr __mm, IntPtr __m, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtgex2_(IntPtr __wantq, IntPtr __wantz, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, DoublePtr __q, IntPtr __ldq, DoublePtr __z__, IntPtr __ldz, IntPtr __j1,
            IntPtr __n1, IntPtr __n2, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtgexc_(IntPtr __wantq, IntPtr __wantz, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb, DoublePtr __q, IntPtr __ldq, DoublePtr __z__, IntPtr __ldz, IntPtr __ifst,
            IntPtr __ilst, DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtgsen_(IntPtr __ijob, IntPtr __wantq, IntPtr __wantz, IntPtr __select, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __alphar, DoublePtr __alphai,
            DoublePtr __beta, DoublePtr __q, IntPtr __ldq, DoublePtr __z__, IntPtr __ldz, IntPtr __m, DoublePtr __pl,
            DoublePtr __pr, DoublePtr __dif, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtgsja_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __p, IntPtr __n,
            IntPtr __k, IntPtr __l, DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __tola,
            DoublePtr __tolb, DoublePtr __alpha, DoublePtr __beta, DoublePtr __u, IntPtr __ldu, DoublePtr __v,
            IntPtr __ldv, DoublePtr __q, IntPtr __ldq, DoublePtr __work, IntPtr __ncycle, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtgsna_(BytePtr __job, BytePtr __howmny, IntPtr __select, IntPtr __n, DoublePtr __a,
            IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __vl, IntPtr __ldvl, DoublePtr __vr, IntPtr __ldvr,
            DoublePtr __s, DoublePtr __dif, IntPtr __mm, IntPtr __m, DoublePtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtgsy2_(BytePtr __trans, IntPtr __ijob, IntPtr __m, IntPtr __n, DoublePtr __a,
            IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __c__, IntPtr __ldc, DoublePtr __d__, IntPtr __ldd,
            DoublePtr __e, IntPtr __lde, DoublePtr __f, IntPtr __ldf, DoublePtr __scale, DoublePtr __rdsum,
            DoublePtr __rdscal, IntPtr __iwork, IntPtr __pq, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtgsyl_(BytePtr __trans, IntPtr __ijob, IntPtr __m, IntPtr __n, DoublePtr __a,
            IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __c__, IntPtr __ldc, DoublePtr __d__, IntPtr __ldd,
            DoublePtr __e, IntPtr __lde, DoublePtr __f, IntPtr __ldf, DoublePtr __scale, DoublePtr __dif,
            DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtpcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, DoublePtr __ap,
            DoublePtr __rcond, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtprfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            DoublePtr __ap, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __ferr,
            DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtptri_(BytePtr __uplo, BytePtr __diag, IntPtr __n, DoublePtr __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtptrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            DoublePtr __ap, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtpttf_(BytePtr __transr, BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __arf,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtpttr_(BytePtr __uplo, IntPtr __n, DoublePtr __ap, DoublePtr __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, DoublePtr __a,
            IntPtr __lda, DoublePtr __rcond, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrevc_(BytePtr __side, BytePtr __howmny, IntPtr __select, IntPtr __n, DoublePtr __t,
            IntPtr __ldt, DoublePtr __vl, IntPtr __ldvl, DoublePtr __vr, IntPtr __ldvr, IntPtr __mm, IntPtr __m,
            DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrexc_(BytePtr __compq, IntPtr __n, DoublePtr __t, IntPtr __ldt, DoublePtr __q,
            IntPtr __ldq, IntPtr __ifst, IntPtr __ilst, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrrfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __x, IntPtr __ldx, DoublePtr __ferr,
            DoublePtr __berr, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrsen_(BytePtr __job, BytePtr __compq, IntPtr __select, IntPtr __n, DoublePtr __t,
            IntPtr __ldt, DoublePtr __q, IntPtr __ldq, DoublePtr __wr, DoublePtr __wi, IntPtr __m, DoublePtr __s,
            DoublePtr __sep, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrsna_(BytePtr __job, BytePtr __howmny, IntPtr __select, IntPtr __n, DoublePtr __t,
            IntPtr __ldt, DoublePtr __vl, IntPtr __ldvl, DoublePtr __vr, IntPtr __ldvr, DoublePtr __s, DoublePtr __sep,
            IntPtr __mm, IntPtr __m, DoublePtr __work, IntPtr __ldwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrsyl_(BytePtr __trana, BytePtr __tranb, IntPtr __isgn, IntPtr __m, IntPtr __n,
            DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, DoublePtr __c__, IntPtr __ldc, DoublePtr __scale,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrti2_(BytePtr __uplo, BytePtr __diag, IntPtr __n, DoublePtr __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrtri_(BytePtr __uplo, BytePtr __diag, IntPtr __n, DoublePtr __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrtrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            DoublePtr __a, IntPtr __lda, DoublePtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrttf_(BytePtr __transr, BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda,
            DoublePtr __arf, IntPtr __info);

    @Generated
    @CFunction
    public static native int dtrttp_(BytePtr __uplo, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __ap,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtzrqf_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dtzrzf_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda, DoublePtr __tau,
            DoublePtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native double dzsum1_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __cx,
            IntPtr __incx);

    @Generated
    @CFunction
    public static native int icmax1_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __cx, IntPtr __incx);

    @Generated
    @CFunction
    public static native int ieeeck_(IntPtr __ispec, FloatPtr __zero, FloatPtr __one);

    @Generated
    @CFunction
    public static native int ilaclc_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int ilaclr_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int iladiag_(BytePtr __diag);

    @Generated
    @CFunction
    public static native int iladlc_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int iladlr_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int ilaenv_(IntPtr __ispec, BytePtr __name__, BytePtr __opts, IntPtr __n1, IntPtr __n2,
            IntPtr __n3, IntPtr __n4);

    @Generated
    @CFunction
    public static native int ilaprec_(BytePtr __prec);

    @Generated
    @CFunction
    public static native int ilaslc_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int ilaslr_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int ilatrans_(BytePtr __trans);

    @Generated
    @CFunction
    public static native int ilauplo_(BytePtr __uplo);

    @Generated
    @CFunction
    public static native int ilaver_(IntPtr __vers_major__, IntPtr __vers_minor__, IntPtr __vers_patch__);

    @Generated
    @CFunction
    public static native int ilazlc_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int ilazlr_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int iparmq_(IntPtr __ispec, BytePtr __name__, BytePtr __opts, IntPtr __n, IntPtr __ilo,
            IntPtr __ihi, IntPtr __lwork);

    @Generated
    @CFunction
    public static native int izmax1_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __cx,
            IntPtr __incx);

    @Generated
    @CFunction
    public static native int lsamen_(IntPtr __n, BytePtr __ca, BytePtr __cb);

    @Generated
    @CFunction
    public static native int smaxloc_(FloatPtr __a, IntPtr __dimm);

    @Generated
    @CFunction
    public static native int sbdsdc_(BytePtr __uplo, BytePtr __compq, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            FloatPtr __u, IntPtr __ldu, FloatPtr __vt, IntPtr __ldvt, FloatPtr __q, IntPtr __iq, FloatPtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sbdsqr_(BytePtr __uplo, IntPtr __n, IntPtr __ncvt, IntPtr __nru, IntPtr __ncc,
            FloatPtr __d__, FloatPtr __e, FloatPtr __vt, IntPtr __ldvt, FloatPtr __u, IntPtr __ldu, FloatPtr __c__,
            IntPtr __ldc, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native double scsum1_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __cx, IntPtr __incx);

    @Generated
    @CFunction
    public static native int sdisna_(BytePtr __job, IntPtr __m, IntPtr __n, FloatPtr __d__, FloatPtr __sep,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbbrd_(BytePtr __vect, IntPtr __m, IntPtr __n, IntPtr __ncc, IntPtr __kl, IntPtr __ku,
            FloatPtr __ab, IntPtr __ldab, FloatPtr __d__, FloatPtr __e, FloatPtr __q, IntPtr __ldq, FloatPtr __pt,
            IntPtr __ldpt, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbcon_(BytePtr __norm, IntPtr __n, IntPtr __kl, IntPtr __ku, FloatPtr __ab, IntPtr __ldab,
            IntPtr __ipiv, FloatPtr __anorm, FloatPtr __rcond, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbequ_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, FloatPtr __ab, IntPtr __ldab,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbequb_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, FloatPtr __ab, IntPtr __ldab,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbrfs_(BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            FloatPtr __ab, IntPtr __ldab, FloatPtr __afb, IntPtr __ldafb, IntPtr __ipiv, FloatPtr __b, IntPtr __ldb,
            FloatPtr __x, IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbsv_(IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs, FloatPtr __ab, IntPtr __ldab,
            IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbsvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku,
            IntPtr __nrhs, FloatPtr __ab, IntPtr __ldab, FloatPtr __afb, IntPtr __ldafb, IntPtr __ipiv, BytePtr __equed,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __rcond,
            FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbtf2_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, FloatPtr __ab, IntPtr __ldab,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbtrf_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, FloatPtr __ab, IntPtr __ldab,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgbtrs_(BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            FloatPtr __ab, IntPtr __ldab, IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgebak_(BytePtr __job, BytePtr __side, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __scale, IntPtr __m, FloatPtr __v, IntPtr __ldv, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgebal_(BytePtr __job, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __scale, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgebd2_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __d__, FloatPtr __e,
            FloatPtr __tauq, FloatPtr __taup, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgebrd_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __d__, FloatPtr __e,
            FloatPtr __tauq, FloatPtr __taup, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgecon_(BytePtr __norm, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __anorm,
            FloatPtr __rcond, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeequ_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __r__, FloatPtr __c__,
            FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeequb_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __r__,
            FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeev_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __wr, FloatPtr __wi, FloatPtr __vl, IntPtr __ldvl, FloatPtr __vr, IntPtr __ldvr, FloatPtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeevx_(BytePtr __balanc, BytePtr __jobvl, BytePtr __jobvr, BytePtr __sense, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __wr, FloatPtr __wi, FloatPtr __vl, IntPtr __ldvl, FloatPtr __vr,
            IntPtr __ldvr, IntPtr __ilo, IntPtr __ihi, FloatPtr __scale, FloatPtr __abnrm, FloatPtr __rconde,
            FloatPtr __rcondv, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgegs_(BytePtr __jobvsl, BytePtr __jobvsr, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, FloatPtr __alphar, FloatPtr __alphai, FloatPtr __beta, FloatPtr __vsl,
            IntPtr __ldvsl, FloatPtr __vsr, IntPtr __ldvsr, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgegv_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, FloatPtr __alphar, FloatPtr __alphai, FloatPtr __beta, FloatPtr __vl,
            IntPtr __ldvl, FloatPtr __vr, IntPtr __ldvr, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgehd2_(IntPtr __n, IntPtr __ilo, IntPtr __ihi, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgehrd_(IntPtr __n, IntPtr __ilo, IntPtr __ihi, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgejsv_(BytePtr __joba, BytePtr __jobu, BytePtr __jobv, BytePtr __jobr, BytePtr __jobt,
            BytePtr __jobp, IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __sva, FloatPtr __u,
            IntPtr __ldu, FloatPtr __v, IntPtr __ldv, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgelq2_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgelqf_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgels_(BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgelsd_(IntPtr __m, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda, FloatPtr __b,
            IntPtr __ldb, FloatPtr __s, FloatPtr __rcond, IntPtr __rank, FloatPtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgelss_(IntPtr __m, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda, FloatPtr __b,
            IntPtr __ldb, FloatPtr __s, FloatPtr __rcond, IntPtr __rank, FloatPtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sgelsx_(IntPtr __m, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda, FloatPtr __b,
            IntPtr __ldb, IntPtr __jpvt, FloatPtr __rcond, IntPtr __rank, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgelsy_(IntPtr __m, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda, FloatPtr __b,
            IntPtr __ldb, IntPtr __jpvt, FloatPtr __rcond, IntPtr __rank, FloatPtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeql2_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeqlf_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeqp3_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __jpvt, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeqpf_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __jpvt, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeqr2_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgeqrf_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgerfs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda,
            FloatPtr __af, IntPtr __ldaf, IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgerq2_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgerqf_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgesc2_(IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __rhs, IntPtr __ipiv,
            IntPtr __jpiv, FloatPtr __scale);

    @Generated
    @CFunction
    public static native int sgesdd_(BytePtr __jobz, IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __s,
            FloatPtr __u, IntPtr __ldu, FloatPtr __vt, IntPtr __ldvt, FloatPtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sgesv_(IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda, IntPtr __ipiv, FloatPtr __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgesvd_(BytePtr __jobu, BytePtr __jobvt, IntPtr __m, IntPtr __n, FloatPtr __a,
            IntPtr __lda, FloatPtr __s, FloatPtr __u, IntPtr __ldu, FloatPtr __vt, IntPtr __ldvt, FloatPtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgesvj_(BytePtr __joba, BytePtr __jobu, BytePtr __jobv, IntPtr __m, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __sva, IntPtr __mv, FloatPtr __v, IntPtr __ldv, FloatPtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgesvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __nrhs, FloatPtr __a,
            IntPtr __lda, FloatPtr __af, IntPtr __ldaf, IntPtr __ipiv, BytePtr __equed, FloatPtr __r__, FloatPtr __c__,
            FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgetc2_(IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __ipiv, IntPtr __jpiv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sgetf2_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgetrf_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgetri_(IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __ipiv, FloatPtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgetrs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda,
            IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sggbak_(BytePtr __job, BytePtr __side, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __lscale, FloatPtr __rscale, IntPtr __m, FloatPtr __v, IntPtr __ldv, IntPtr __info);

    @Generated
    @CFunction
    public static native int sggbal_(BytePtr __job, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb,
            IntPtr __ilo, IntPtr __ihi, FloatPtr __lscale, FloatPtr __rscale, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sggev_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, FloatPtr __alphar, FloatPtr __alphai, FloatPtr __beta, FloatPtr __vl,
            IntPtr __ldvl, FloatPtr __vr, IntPtr __ldvr, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sggevx_(BytePtr __balanc, BytePtr __jobvl, BytePtr __jobvr, BytePtr __sense, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __alphar, FloatPtr __alphai,
            FloatPtr __beta, FloatPtr __vl, IntPtr __ldvl, FloatPtr __vr, IntPtr __ldvr, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __lscale, FloatPtr __rscale, FloatPtr __abnrm, FloatPtr __bbnrm, FloatPtr __rconde,
            FloatPtr __rcondv, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __bwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sggglm_(IntPtr __n, IntPtr __m, IntPtr __p, FloatPtr __a, IntPtr __lda, FloatPtr __b,
            IntPtr __ldb, FloatPtr __d__, FloatPtr __x, FloatPtr __y, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgghrd_(BytePtr __compq, BytePtr __compz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __q, IntPtr __ldq, FloatPtr __z__,
            IntPtr __ldz, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgglse_(IntPtr __m, IntPtr __n, IntPtr __p, FloatPtr __a, IntPtr __lda, FloatPtr __b,
            IntPtr __ldb, FloatPtr __c__, FloatPtr __d__, FloatPtr __x, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sggqrf_(IntPtr __n, IntPtr __m, IntPtr __p, FloatPtr __a, IntPtr __lda, FloatPtr __taua,
            FloatPtr __b, IntPtr __ldb, FloatPtr __taub, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sggrqf_(IntPtr __m, IntPtr __p, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __taua,
            FloatPtr __b, IntPtr __ldb, FloatPtr __taub, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sggsvd_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __n, IntPtr __p,
            IntPtr __k, IntPtr __l, FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __alpha,
            FloatPtr __beta, FloatPtr __u, IntPtr __ldu, FloatPtr __v, IntPtr __ldv, FloatPtr __q, IntPtr __ldq,
            FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sggsvp_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __p, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __tola, FloatPtr __tolb, IntPtr __k,
            IntPtr __l, FloatPtr __u, IntPtr __ldu, FloatPtr __v, IntPtr __ldv, FloatPtr __q, IntPtr __ldq,
            IntPtr __iwork, FloatPtr __tau, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgsvj0_(BytePtr __jobv, IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __d__,
            FloatPtr __sva, IntPtr __mv, FloatPtr __v, IntPtr __ldv, FloatPtr __eps, FloatPtr __sfmin, FloatPtr __tol,
            IntPtr __nsweep, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgsvj1_(BytePtr __jobv, IntPtr __m, IntPtr __n, IntPtr __n1, FloatPtr __a, IntPtr __lda,
            FloatPtr __d__, FloatPtr __sva, IntPtr __mv, FloatPtr __v, IntPtr __ldv, FloatPtr __eps, FloatPtr __sfmin,
            FloatPtr __tol, IntPtr __nsweep, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgtcon_(BytePtr __norm, IntPtr __n, FloatPtr __dl, FloatPtr __d__, FloatPtr __du,
            FloatPtr __du2, IntPtr __ipiv, FloatPtr __anorm, FloatPtr __rcond, FloatPtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sgtrfs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, FloatPtr __dl, FloatPtr __d__,
            FloatPtr __du, FloatPtr __dlf, FloatPtr __df, FloatPtr __duf, FloatPtr __du2, IntPtr __ipiv, FloatPtr __b,
            IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sgtsv_(IntPtr __n, IntPtr __nrhs, FloatPtr __dl, FloatPtr __d__, FloatPtr __du,
            FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgtsvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __nrhs, FloatPtr __dl,
            FloatPtr __d__, FloatPtr __du, FloatPtr __dlf, FloatPtr __df, FloatPtr __duf, FloatPtr __du2, IntPtr __ipiv,
            FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgttrf_(IntPtr __n, FloatPtr __dl, FloatPtr __d__, FloatPtr __du, FloatPtr __du2,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgttrs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, FloatPtr __dl, FloatPtr __d__,
            FloatPtr __du, FloatPtr __du2, IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sgtts2_(IntPtr __itrans, IntPtr __n, IntPtr __nrhs, FloatPtr __dl, FloatPtr __d__,
            FloatPtr __du, FloatPtr __du2, IntPtr __ipiv, FloatPtr __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int shgeqz_(BytePtr __job, BytePtr __compq, BytePtr __compz, IntPtr __n, IntPtr __ilo,
            IntPtr __ihi, FloatPtr __h__, IntPtr __ldh, FloatPtr __t, IntPtr __ldt, FloatPtr __alphar,
            FloatPtr __alphai, FloatPtr __beta, FloatPtr __q, IntPtr __ldq, FloatPtr __z__, IntPtr __ldz,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int shsein_(BytePtr __side, BytePtr __eigsrc, BytePtr __initv, IntPtr __select, IntPtr __n,
            FloatPtr __h__, IntPtr __ldh, FloatPtr __wr, FloatPtr __wi, FloatPtr __vl, IntPtr __ldvl, FloatPtr __vr,
            IntPtr __ldvr, IntPtr __mm, IntPtr __m, FloatPtr __work, IntPtr __ifaill, IntPtr __ifailr, IntPtr __info);

    @Generated
    @CFunction
    public static native int shseqr_(BytePtr __job, BytePtr __compz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __h__, IntPtr __ldh, FloatPtr __wr, FloatPtr __wi, FloatPtr __z__, IntPtr __ldz, FloatPtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sisnan_(FloatPtr __sin__);

    @Generated
    @CFunction
    public static native int slabad_(FloatPtr __small, FloatPtr __large);

    @Generated
    @CFunction
    public static native int slabrd_(IntPtr __m, IntPtr __n, IntPtr __nb, FloatPtr __a, IntPtr __lda, FloatPtr __d__,
            FloatPtr __e, FloatPtr __tauq, FloatPtr __taup, FloatPtr __x, IntPtr __ldx, FloatPtr __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int slacn2_(IntPtr __n, FloatPtr __v, FloatPtr __x, IntPtr __isgn, FloatPtr __est,
            IntPtr __kase, IntPtr __isave);

    @Generated
    @CFunction
    public static native int slacon_(IntPtr __n, FloatPtr __v, FloatPtr __x, IntPtr __isgn, FloatPtr __est,
            IntPtr __kase);

    @Generated
    @CFunction
    public static native int slacpy_(BytePtr __uplo, IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __b,
            IntPtr __ldb);

    @Generated
    @CFunction
    public static native int sladiv_(FloatPtr __a, FloatPtr __b, FloatPtr __c__, FloatPtr __d__, FloatPtr __p,
            FloatPtr __q);

    @Generated
    @CFunction
    public static native int slae2_(FloatPtr __a, FloatPtr __b, FloatPtr __c__, FloatPtr __rt1, FloatPtr __rt2);

    @Generated
    @CFunction
    public static native int slaebz_(IntPtr __ijob, IntPtr __nitmax, IntPtr __n, IntPtr __mmax, IntPtr __minp,
            IntPtr __nbmin, FloatPtr __abstol, FloatPtr __reltol, FloatPtr __pivmin, FloatPtr __d__, FloatPtr __e,
            FloatPtr __e2, IntPtr __nval, FloatPtr __ab, FloatPtr __c__, IntPtr __mout, IntPtr __nab, FloatPtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaed0_(IntPtr __icompq, IntPtr __qsiz, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            FloatPtr __q, IntPtr __ldq, FloatPtr __qstore, IntPtr __ldqs, FloatPtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int slaed1_(IntPtr __n, FloatPtr __d__, FloatPtr __q, IntPtr __ldq, IntPtr __indxq,
            FloatPtr __rho, IntPtr __cutpnt, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaed2_(IntPtr __k, IntPtr __n, IntPtr __n1, FloatPtr __d__, FloatPtr __q, IntPtr __ldq,
            IntPtr __indxq, FloatPtr __rho, FloatPtr __z__, FloatPtr __dlamda, FloatPtr __w, FloatPtr __q2,
            IntPtr __indx, IntPtr __indxc, IntPtr __indxp, IntPtr __coltyp, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaed3_(IntPtr __k, IntPtr __n, IntPtr __n1, FloatPtr __d__, FloatPtr __q, IntPtr __ldq,
            FloatPtr __rho, FloatPtr __dlamda, FloatPtr __q2, IntPtr __indx, IntPtr __ctot, FloatPtr __w, FloatPtr __s,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int slaed4_(IntPtr __n, IntPtr __i__, FloatPtr __d__, FloatPtr __z__, FloatPtr __delta,
            FloatPtr __rho, FloatPtr __dlam, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaed5_(IntPtr __i__, FloatPtr __d__, FloatPtr __z__, FloatPtr __delta, FloatPtr __rho,
            FloatPtr __dlam);

    @Generated
    @CFunction
    public static native int slaed6_(IntPtr __kniter, IntPtr __orgati, FloatPtr __rho, FloatPtr __d__, FloatPtr __z__,
            FloatPtr __finit, FloatPtr __tau, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaed7_(IntPtr __icompq, IntPtr __n, IntPtr __qsiz, IntPtr __tlvls, IntPtr __curlvl,
            IntPtr __curpbm, FloatPtr __d__, FloatPtr __q, IntPtr __ldq, IntPtr __indxq, FloatPtr __rho,
            IntPtr __cutpnt, FloatPtr __qstore, IntPtr __qptr, IntPtr __prmptr, IntPtr __perm, IntPtr __givptr,
            IntPtr __givcol, FloatPtr __givnum, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaed8_(IntPtr __icompq, IntPtr __k, IntPtr __n, IntPtr __qsiz, FloatPtr __d__,
            FloatPtr __q, IntPtr __ldq, IntPtr __indxq, FloatPtr __rho, IntPtr __cutpnt, FloatPtr __z__,
            FloatPtr __dlamda, FloatPtr __q2, IntPtr __ldq2, FloatPtr __w, IntPtr __perm, IntPtr __givptr,
            IntPtr __givcol, FloatPtr __givnum, IntPtr __indxp, IntPtr __indx, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaed9_(IntPtr __k, IntPtr __kstart, IntPtr __kstop, IntPtr __n, FloatPtr __d__,
            FloatPtr __q, IntPtr __ldq, FloatPtr __rho, FloatPtr __dlamda, FloatPtr __w, FloatPtr __s, IntPtr __lds,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int slaeda_(IntPtr __n, IntPtr __tlvls, IntPtr __curlvl, IntPtr __curpbm, IntPtr __prmptr,
            IntPtr __perm, IntPtr __givptr, IntPtr __givcol, FloatPtr __givnum, FloatPtr __q, IntPtr __qptr,
            FloatPtr __z__, FloatPtr __ztemp, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaein_(IntPtr __rightv, IntPtr __noinit, IntPtr __n, FloatPtr __h__, IntPtr __ldh,
            FloatPtr __wr, FloatPtr __wi, FloatPtr __vr, FloatPtr __vi, FloatPtr __b, IntPtr __ldb, FloatPtr __work,
            FloatPtr __eps3, FloatPtr __smlnum, FloatPtr __bignum, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaev2_(FloatPtr __a, FloatPtr __b, FloatPtr __c__, FloatPtr __rt1, FloatPtr __rt2,
            FloatPtr __cs1, FloatPtr __sn1);

    @Generated
    @CFunction
    public static native int slaexc_(IntPtr __wantq, IntPtr __n, FloatPtr __t, IntPtr __ldt, FloatPtr __q, IntPtr __ldq,
            IntPtr __j1, IntPtr __n1, IntPtr __n2, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int slag2_(FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __safmin,
            FloatPtr __scale1, FloatPtr __scale2, FloatPtr __wr1, FloatPtr __wr2, FloatPtr __wi);

    @Generated
    @CFunction
    public static native int slag2d_(IntPtr __m, IntPtr __n, FloatPtr __sa, IntPtr __ldsa, DoublePtr __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int slags2_(IntPtr __upper, FloatPtr __a1, FloatPtr __a2, FloatPtr __a3, FloatPtr __b1,
            FloatPtr __b2, FloatPtr __b3, FloatPtr __csu, FloatPtr __snu, FloatPtr __csv, FloatPtr __snv,
            FloatPtr __csq, FloatPtr __snq);

    @Generated
    @CFunction
    public static native int slagtf_(IntPtr __n, FloatPtr __a, FloatPtr __lambda, FloatPtr __b, FloatPtr __c__,
            FloatPtr __tol, FloatPtr __d__, IntPtr __in, IntPtr __info);

    @Generated
    @CFunction
    public static native int slagtm_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, FloatPtr __alpha, FloatPtr __dl,
            FloatPtr __d__, FloatPtr __du, FloatPtr __x, IntPtr __ldx, FloatPtr __beta, FloatPtr __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int slagts_(IntPtr __job, IntPtr __n, FloatPtr __a, FloatPtr __b, FloatPtr __c__,
            FloatPtr __d__, IntPtr __in, FloatPtr __y, FloatPtr __tol, IntPtr __info);

    @Generated
    @CFunction
    public static native int slagv2_(FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __alphar,
            FloatPtr __alphai, FloatPtr __beta, FloatPtr __csl, FloatPtr __snl, FloatPtr __csr, FloatPtr __snr);

    @Generated
    @CFunction
    public static native int slahqr_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __h__, IntPtr __ldh, FloatPtr __wr, FloatPtr __wi, IntPtr __iloz, IntPtr __ihiz, FloatPtr __z__,
            IntPtr __ldz, IntPtr __info);

    @Generated
    @CFunction
    public static native int slahr2_(IntPtr __n, IntPtr __k, IntPtr __nb, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __t, IntPtr __ldt, FloatPtr __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int slahrd_(IntPtr __n, IntPtr __k, IntPtr __nb, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __t, IntPtr __ldt, FloatPtr __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int slaic1_(IntPtr __job, IntPtr __j, FloatPtr __x, FloatPtr __sest, FloatPtr __w,
            FloatPtr __gamma, FloatPtr __sestpr, FloatPtr __s, FloatPtr __c__);

    @Generated
    @CFunction
    public static native int slaisnan_(FloatPtr __sin1, FloatPtr __sin2);

    @Generated
    @CFunction
    public static native int slaln2_(IntPtr __ltrans, IntPtr __na, IntPtr __nw, FloatPtr __smin, FloatPtr __ca,
            FloatPtr __a, IntPtr __lda, FloatPtr __d1, FloatPtr __d2, FloatPtr __b, IntPtr __ldb, FloatPtr __wr,
            FloatPtr __wi, FloatPtr __x, IntPtr __ldx, FloatPtr __scale, FloatPtr __xnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int slals0_(IntPtr __icompq, IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __nrhs,
            FloatPtr __b, IntPtr __ldb, FloatPtr __bx, IntPtr __ldbx, IntPtr __perm, IntPtr __givptr, IntPtr __givcol,
            IntPtr __ldgcol, FloatPtr __givnum, IntPtr __ldgnum, FloatPtr __poles, FloatPtr __difl, FloatPtr __difr,
            FloatPtr __z__, IntPtr __k, FloatPtr __c__, FloatPtr __s, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int slalsa_(IntPtr __icompq, IntPtr __smlsiz, IntPtr __n, IntPtr __nrhs, FloatPtr __b,
            IntPtr __ldb, FloatPtr __bx, IntPtr __ldbx, FloatPtr __u, IntPtr __ldu, FloatPtr __vt, IntPtr __k,
            FloatPtr __difl, FloatPtr __difr, FloatPtr __z__, FloatPtr __poles, IntPtr __givptr, IntPtr __givcol,
            IntPtr __ldgcol, IntPtr __perm, FloatPtr __givnum, FloatPtr __c__, FloatPtr __s, FloatPtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slalsd_(BytePtr __uplo, IntPtr __smlsiz, IntPtr __n, IntPtr __nrhs, FloatPtr __d__,
            FloatPtr __e, FloatPtr __b, IntPtr __ldb, FloatPtr __rcond, IntPtr __rank, FloatPtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int slamrg_(IntPtr __n1, IntPtr __n2, FloatPtr __a, IntPtr __strd1, IntPtr __strd2,
            IntPtr __index);

    @Generated
    @CFunction
    public static native int slaneg_(IntPtr __n, FloatPtr __d__, FloatPtr __lld, FloatPtr __sigma, FloatPtr __pivmin,
            IntPtr __r__);

    @Generated
    @CFunction
    public static native double slangb_(BytePtr __norm, IntPtr __n, IntPtr __kl, IntPtr __ku, FloatPtr __ab,
            IntPtr __ldab, FloatPtr __work);

    @Generated
    @CFunction
    public static native double slange_(BytePtr __norm, IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double slangt_(BytePtr __norm, IntPtr __n, FloatPtr __dl, FloatPtr __d__, FloatPtr __du);

    @Generated
    @CFunction
    public static native double slanhs_(BytePtr __norm, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __work);

    @Generated
    @CFunction
    public static native double slansb_(BytePtr __norm, BytePtr __uplo, IntPtr __n, IntPtr __k, FloatPtr __ab,
            IntPtr __ldab, FloatPtr __work);

    @Generated
    @CFunction
    public static native double slansf_(BytePtr __norm, BytePtr __transr, BytePtr __uplo, IntPtr __n, FloatPtr __a,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double slansp_(BytePtr __norm, BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __work);

    @Generated
    @CFunction
    public static native double slanst_(BytePtr __norm, IntPtr __n, FloatPtr __d__, FloatPtr __e);

    @Generated
    @CFunction
    public static native double slansy_(BytePtr __norm, BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double slantb_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, IntPtr __k,
            FloatPtr __ab, IntPtr __ldab, FloatPtr __work);

    @Generated
    @CFunction
    public static native double slantp_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, FloatPtr __ap,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native double slantr_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __m, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __work);

    @Generated
    @CFunction
    public static native int slanv2_(FloatPtr __a, FloatPtr __b, FloatPtr __c__, FloatPtr __d__, FloatPtr __rt1r,
            FloatPtr __rt1i, FloatPtr __rt2r, FloatPtr __rt2i, FloatPtr __cs, FloatPtr __sn);

    @Generated
    @CFunction
    public static native int slapll_(IntPtr __n, FloatPtr __x, IntPtr __incx, FloatPtr __y, IntPtr __incy,
            FloatPtr __ssmin);

    @Generated
    @CFunction
    public static native int slapmt_(IntPtr __forwrd, IntPtr __m, IntPtr __n, FloatPtr __x, IntPtr __ldx, IntPtr __k);

    @Generated
    @CFunction
    public static native double slapy2_(FloatPtr __x, FloatPtr __y);

    @Generated
    @CFunction
    public static native double slapy3_(FloatPtr __x, FloatPtr __y, FloatPtr __z__);

    @Generated
    @CFunction
    public static native int slaqgb_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku, FloatPtr __ab, IntPtr __ldab,
            FloatPtr __r__, FloatPtr __c__, FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int slaqge_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __r__, FloatPtr __c__,
            FloatPtr __rowcnd, FloatPtr __colcnd, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int slaqp2_(IntPtr __m, IntPtr __n, IntPtr __offset, FloatPtr __a, IntPtr __lda, IntPtr __jpvt,
            FloatPtr __tau, FloatPtr __vn1, FloatPtr __vn2, FloatPtr __work);

    @Generated
    @CFunction
    public static native int slaqps_(IntPtr __m, IntPtr __n, IntPtr __offset, IntPtr __nb, IntPtr __kb, FloatPtr __a,
            IntPtr __lda, IntPtr __jpvt, FloatPtr __tau, FloatPtr __vn1, FloatPtr __vn2, FloatPtr __auxv, FloatPtr __f,
            IntPtr __ldf);

    @Generated
    @CFunction
    public static native int slaqr0_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __h__, IntPtr __ldh, FloatPtr __wr, FloatPtr __wi, IntPtr __iloz, IntPtr __ihiz, FloatPtr __z__,
            IntPtr __ldz, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaqr1_(IntPtr __n, FloatPtr __h__, IntPtr __ldh, FloatPtr __sr1, FloatPtr __si1,
            FloatPtr __sr2, FloatPtr __si2, FloatPtr __v);

    @Generated
    @CFunction
    public static native int slaqr2_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ktop, IntPtr __kbot,
            IntPtr __nw, FloatPtr __h__, IntPtr __ldh, IntPtr __iloz, IntPtr __ihiz, FloatPtr __z__, IntPtr __ldz,
            IntPtr __ns, IntPtr __nd, FloatPtr __sr, FloatPtr __si, FloatPtr __v, IntPtr __ldv, IntPtr __nh,
            FloatPtr __t, IntPtr __ldt, IntPtr __nv, FloatPtr __wv, IntPtr __ldwv, FloatPtr __work, IntPtr __lwork);

    @Generated
    @CFunction
    public static native int slaqr3_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ktop, IntPtr __kbot,
            IntPtr __nw, FloatPtr __h__, IntPtr __ldh, IntPtr __iloz, IntPtr __ihiz, FloatPtr __z__, IntPtr __ldz,
            IntPtr __ns, IntPtr __nd, FloatPtr __sr, FloatPtr __si, FloatPtr __v, IntPtr __ldv, IntPtr __nh,
            FloatPtr __t, IntPtr __ldt, IntPtr __nv, FloatPtr __wv, IntPtr __ldwv, FloatPtr __work, IntPtr __lwork);

    @Generated
    @CFunction
    public static native int slaqr4_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            FloatPtr __h__, IntPtr __ldh, FloatPtr __wr, FloatPtr __wi, IntPtr __iloz, IntPtr __ihiz, FloatPtr __z__,
            IntPtr __ldz, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slaqr5_(IntPtr __wantt, IntPtr __wantz, IntPtr __kacc22, IntPtr __n, IntPtr __ktop,
            IntPtr __kbot, IntPtr __nshfts, FloatPtr __sr, FloatPtr __si, FloatPtr __h__, IntPtr __ldh, IntPtr __iloz,
            IntPtr __ihiz, FloatPtr __z__, IntPtr __ldz, FloatPtr __v, IntPtr __ldv, FloatPtr __u, IntPtr __ldu,
            IntPtr __nv, FloatPtr __wv, IntPtr __ldwv, IntPtr __nh, FloatPtr __wh, IntPtr __ldwh);

    @Generated
    @CFunction
    public static native int slaqsb_(BytePtr __uplo, IntPtr __n, IntPtr __kd, FloatPtr __ab, IntPtr __ldab,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int slaqsp_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __s, FloatPtr __scond,
            FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int slaqsy_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __s,
            FloatPtr __scond, FloatPtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int slaqtr_(IntPtr __ltran, IntPtr __l__CLPK_real, IntPtr __n, FloatPtr __t, IntPtr __ldt,
            FloatPtr __b, FloatPtr __w, FloatPtr __scale, FloatPtr __x, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int slar1v_(IntPtr __n, IntPtr __b1, IntPtr __bn, FloatPtr __lambda, FloatPtr __d__,
            FloatPtr __l, FloatPtr __ld, FloatPtr __lld, FloatPtr __pivmin, FloatPtr __gaptol, FloatPtr __z__,
            IntPtr __wantnc, IntPtr __negcnt, FloatPtr __ztz, FloatPtr __mingma, IntPtr __r__, IntPtr __isuppz,
            FloatPtr __nrminv, FloatPtr __resid, FloatPtr __rqcorr, FloatPtr __work);

    @Generated
    @CFunction
    public static native int slar2v_(IntPtr __n, FloatPtr __x, FloatPtr __y, FloatPtr __z__, IntPtr __incx,
            FloatPtr __c__, FloatPtr __s, IntPtr __incc);

    @Generated
    @CFunction
    public static native int slarf_(BytePtr __side, IntPtr __m, IntPtr __n, FloatPtr __v, IntPtr __incv, FloatPtr __tau,
            FloatPtr __c__, IntPtr __ldc, FloatPtr __work);

    @Generated
    @CFunction
    public static native int slarfb_(BytePtr __side, BytePtr __trans, BytePtr __direct, BytePtr __storev, IntPtr __m,
            IntPtr __n, IntPtr __k, FloatPtr __v, IntPtr __ldv, FloatPtr __t, IntPtr __ldt, FloatPtr __c__,
            IntPtr __ldc, FloatPtr __work, IntPtr __ldwork);

    @Generated
    @CFunction
    public static native int slarfg_(IntPtr __n, FloatPtr __alpha, FloatPtr __x, IntPtr __incx, FloatPtr __tau);

    @Generated
    @CFunction
    public static native int slarfp_(IntPtr __n, FloatPtr __alpha, FloatPtr __x, IntPtr __incx, FloatPtr __tau);

    @Generated
    @CFunction
    public static native int slarft_(BytePtr __direct, BytePtr __storev, IntPtr __n, IntPtr __k, FloatPtr __v,
            IntPtr __ldv, FloatPtr __tau, FloatPtr __t, IntPtr __ldt);

    @Generated
    @CFunction
    public static native int slarfx_(BytePtr __side, IntPtr __m, IntPtr __n, FloatPtr __v, FloatPtr __tau,
            FloatPtr __c__, IntPtr __ldc, FloatPtr __work);

    @Generated
    @CFunction
    public static native int slargv_(IntPtr __n, FloatPtr __x, IntPtr __incx, FloatPtr __y, IntPtr __incy,
            FloatPtr __c__, IntPtr __incc);

    @Generated
    @CFunction
    public static native int slarnv_(IntPtr __idist, IntPtr __iseed, IntPtr __n, FloatPtr __x);

    @Generated
    @CFunction
    public static native int slarra_(IntPtr __n, FloatPtr __d__, FloatPtr __e, FloatPtr __e2, FloatPtr __spltol,
            FloatPtr __tnrm, IntPtr __nsplit, IntPtr __isplit, IntPtr __info);

    @Generated
    @CFunction
    public static native int slarrb_(IntPtr __n, FloatPtr __d__, FloatPtr __lld, IntPtr __ifirst, IntPtr __ilast,
            FloatPtr __rtol1, FloatPtr __rtol2, IntPtr __offset, FloatPtr __w, FloatPtr __wgap, FloatPtr __werr,
            FloatPtr __work, IntPtr __iwork, FloatPtr __pivmin, FloatPtr __spdiam, IntPtr __twist, IntPtr __info);

    @Generated
    @CFunction
    public static native int slarrc_(BytePtr __jobt, IntPtr __n, FloatPtr __vl, FloatPtr __vu, FloatPtr __d__,
            FloatPtr __e, FloatPtr __pivmin, IntPtr __eigcnt, IntPtr __lcnt, IntPtr __rcnt, IntPtr __info);

    @Generated
    @CFunction
    public static native int slarrd_(BytePtr __range, BytePtr __order, IntPtr __n, FloatPtr __vl, FloatPtr __vu,
            IntPtr __il, IntPtr __iu, FloatPtr __gers, FloatPtr __reltol, FloatPtr __d__, FloatPtr __e, FloatPtr __e2,
            FloatPtr __pivmin, IntPtr __nsplit, IntPtr __isplit, IntPtr __m, FloatPtr __w, FloatPtr __werr,
            FloatPtr __wl, FloatPtr __wu, IntPtr __iblock, IntPtr __indexw, FloatPtr __work, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int slarre_(BytePtr __range, IntPtr __n, FloatPtr __vl, FloatPtr __vu, IntPtr __il,
            IntPtr __iu, FloatPtr __d__, FloatPtr __e, FloatPtr __e2, FloatPtr __rtol1, FloatPtr __rtol2,
            FloatPtr __spltol, IntPtr __nsplit, IntPtr __isplit, IntPtr __m, FloatPtr __w, FloatPtr __werr,
            FloatPtr __wgap, IntPtr __iblock, IntPtr __indexw, FloatPtr __gers, FloatPtr __pivmin, FloatPtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slarrf_(IntPtr __n, FloatPtr __d__, FloatPtr __l, FloatPtr __ld, IntPtr __clstrt,
            IntPtr __clend, FloatPtr __w, FloatPtr __wgap, FloatPtr __werr, FloatPtr __spdiam, FloatPtr __clgapl,
            FloatPtr __clgapr, FloatPtr __pivmin, FloatPtr __sigma, FloatPtr __dplus, FloatPtr __lplus, FloatPtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int slarrj_(IntPtr __n, FloatPtr __d__, FloatPtr __e2, IntPtr __ifirst, IntPtr __ilast,
            FloatPtr __rtol, IntPtr __offset, FloatPtr __w, FloatPtr __werr, FloatPtr __work, IntPtr __iwork,
            FloatPtr __pivmin, FloatPtr __spdiam, IntPtr __info);

    @Generated
    @CFunction
    public static native int slarrk_(IntPtr __n, IntPtr __iw, FloatPtr __gl, FloatPtr __gu, FloatPtr __d__,
            FloatPtr __e2, FloatPtr __pivmin, FloatPtr __reltol, FloatPtr __w, FloatPtr __werr, IntPtr __info);

    @Generated
    @CFunction
    public static native int slarrr_(IntPtr __n, FloatPtr __d__, FloatPtr __e, IntPtr __info);

    @Generated
    @CFunction
    public static native int slarrv_(IntPtr __n, FloatPtr __vl, FloatPtr __vu, FloatPtr __d__, FloatPtr __l,
            FloatPtr __pivmin, IntPtr __isplit, IntPtr __m, IntPtr __dol, IntPtr __dou, FloatPtr __minrgp,
            FloatPtr __rtol1, FloatPtr __rtol2, FloatPtr __w, FloatPtr __werr, FloatPtr __wgap, IntPtr __iblock,
            IntPtr __indexw, FloatPtr __gers, FloatPtr __z__, IntPtr __ldz, IntPtr __isuppz, FloatPtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slarscl2_(IntPtr __m, IntPtr __n, FloatPtr __d__, FloatPtr __x, IntPtr __ldx);

    @Generated
    @CFunction
    public static native int slartg_(FloatPtr __f, FloatPtr __g, FloatPtr __cs, FloatPtr __sn, FloatPtr __r__);

    @Generated
    @CFunction
    public static native int slartv_(IntPtr __n, FloatPtr __x, IntPtr __incx, FloatPtr __y, IntPtr __incy,
            FloatPtr __c__, FloatPtr __s, IntPtr __incc);

    @Generated
    @CFunction
    public static native int slaruv_(IntPtr __iseed, IntPtr __n, FloatPtr __x);

    @Generated
    @CFunction
    public static native int slarz_(BytePtr __side, IntPtr __m, IntPtr __n, IntPtr __l, FloatPtr __v, IntPtr __incv,
            FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work);

    @Generated
    @CFunction
    public static native int slarzb_(BytePtr __side, BytePtr __trans, BytePtr __direct, BytePtr __storev, IntPtr __m,
            IntPtr __n, IntPtr __k, IntPtr __l, FloatPtr __v, IntPtr __ldv, FloatPtr __t, IntPtr __ldt, FloatPtr __c__,
            IntPtr __ldc, FloatPtr __work, IntPtr __ldwork);

    @Generated
    @CFunction
    public static native int slarzt_(BytePtr __direct, BytePtr __storev, IntPtr __n, IntPtr __k, FloatPtr __v,
            IntPtr __ldv, FloatPtr __tau, FloatPtr __t, IntPtr __ldt);

    @Generated
    @CFunction
    public static native int slas2_(FloatPtr __f, FloatPtr __g, FloatPtr __h__, FloatPtr __ssmin, FloatPtr __ssmax);

    @Generated
    @CFunction
    public static native int slascl_(BytePtr __type__, IntPtr __kl, IntPtr __ku, FloatPtr __cfrom, FloatPtr __cto,
            IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int slascl2_(IntPtr __m, IntPtr __n, FloatPtr __d__, FloatPtr __x, IntPtr __ldx);

    @Generated
    @CFunction
    public static native int slasd0_(IntPtr __n, IntPtr __sqre, FloatPtr __d__, FloatPtr __e, FloatPtr __u,
            IntPtr __ldu, FloatPtr __vt, IntPtr __ldvt, IntPtr __smlsiz, IntPtr __iwork, FloatPtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int slasd1_(IntPtr __nl, IntPtr __nr, IntPtr __sqre, FloatPtr __d__, FloatPtr __alpha,
            FloatPtr __beta, FloatPtr __u, IntPtr __ldu, FloatPtr __vt, IntPtr __ldvt, IntPtr __idxq, IntPtr __iwork,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasd2_(IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __k, FloatPtr __d__,
            FloatPtr __z__, FloatPtr __alpha, FloatPtr __beta, FloatPtr __u, IntPtr __ldu, FloatPtr __vt, IntPtr __ldvt,
            FloatPtr __dsigma, FloatPtr __u2, IntPtr __ldu2, FloatPtr __vt2, IntPtr __ldvt2, IntPtr __idxp,
            IntPtr __idx, IntPtr __idxc, IntPtr __idxq, IntPtr __coltyp, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasd3_(IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __k, FloatPtr __d__, FloatPtr __q,
            IntPtr __ldq, FloatPtr __dsigma, FloatPtr __u, IntPtr __ldu, FloatPtr __u2, IntPtr __ldu2, FloatPtr __vt,
            IntPtr __ldvt, FloatPtr __vt2, IntPtr __ldvt2, IntPtr __idxc, IntPtr __ctot, FloatPtr __z__, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasd4_(IntPtr __n, IntPtr __i__, FloatPtr __d__, FloatPtr __z__, FloatPtr __delta,
            FloatPtr __rho, FloatPtr __sigma, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasd5_(IntPtr __i__, FloatPtr __d__, FloatPtr __z__, FloatPtr __delta, FloatPtr __rho,
            FloatPtr __dsigma, FloatPtr __work);

    @Generated
    @CFunction
    public static native int slasd6_(IntPtr __icompq, IntPtr __nl, IntPtr __nr, IntPtr __sqre, FloatPtr __d__,
            FloatPtr __vf, FloatPtr __vl, FloatPtr __alpha, FloatPtr __beta, IntPtr __idxq, IntPtr __perm,
            IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, FloatPtr __givnum, IntPtr __ldgnum, FloatPtr __poles,
            FloatPtr __difl, FloatPtr __difr, FloatPtr __z__, IntPtr __k, FloatPtr __c__, FloatPtr __s, FloatPtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasd7_(IntPtr __icompq, IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __k,
            FloatPtr __d__, FloatPtr __z__, FloatPtr __zw, FloatPtr __vf, FloatPtr __vfw, FloatPtr __vl, FloatPtr __vlw,
            FloatPtr __alpha, FloatPtr __beta, FloatPtr __dsigma, IntPtr __idx, IntPtr __idxp, IntPtr __idxq,
            IntPtr __perm, IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, FloatPtr __givnum, IntPtr __ldgnum,
            FloatPtr __c__, FloatPtr __s, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasd8_(IntPtr __icompq, IntPtr __k, FloatPtr __d__, FloatPtr __z__, FloatPtr __vf,
            FloatPtr __vl, FloatPtr __difl, FloatPtr __difr, IntPtr __lddifr, FloatPtr __dsigma, FloatPtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int slasda_(IntPtr __icompq, IntPtr __smlsiz, IntPtr __n, IntPtr __sqre, FloatPtr __d__,
            FloatPtr __e, FloatPtr __u, IntPtr __ldu, FloatPtr __vt, IntPtr __k, FloatPtr __difl, FloatPtr __difr,
            FloatPtr __z__, FloatPtr __poles, IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, IntPtr __perm,
            FloatPtr __givnum, FloatPtr __c__, FloatPtr __s, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasdq_(BytePtr __uplo, IntPtr __sqre, IntPtr __n, IntPtr __ncvt, IntPtr __nru,
            IntPtr __ncc, FloatPtr __d__, FloatPtr __e, FloatPtr __vt, IntPtr __ldvt, FloatPtr __u, IntPtr __ldu,
            FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasdt_(IntPtr __n, IntPtr __lvl, IntPtr __nd, IntPtr __inode, IntPtr __ndiml,
            IntPtr __ndimr, IntPtr __msub);

    @Generated
    @CFunction
    public static native int slaset_(BytePtr __uplo, IntPtr __m, IntPtr __n, FloatPtr __alpha, FloatPtr __beta,
            FloatPtr __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int slasq1_(IntPtr __n, FloatPtr __d__, FloatPtr __e, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasq2_(IntPtr __n, FloatPtr __z__, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasq3_(IntPtr __i0, IntPtr __n0, FloatPtr __z__, IntPtr __pp, FloatPtr __dmin__,
            FloatPtr __sigma, FloatPtr __desig, FloatPtr __qmax, IntPtr __nfail, IntPtr __iter, IntPtr __ndiv,
            IntPtr __ieee, IntPtr __ttype, FloatPtr __dmin1, FloatPtr __dmin2, FloatPtr __dn, FloatPtr __dn1,
            FloatPtr __dn2, FloatPtr __g, FloatPtr __tau);

    @Generated
    @CFunction
    public static native int slasq4_(IntPtr __i0, IntPtr __n0, FloatPtr __z__, IntPtr __pp, IntPtr __n0in,
            FloatPtr __dmin__, FloatPtr __dmin1, FloatPtr __dmin2, FloatPtr __dn, FloatPtr __dn1, FloatPtr __dn2,
            FloatPtr __tau, IntPtr __ttype, FloatPtr __g);

    @Generated
    @CFunction
    public static native int slasq5_(IntPtr __i0, IntPtr __n0, FloatPtr __z__, IntPtr __pp, FloatPtr __tau,
            FloatPtr __dmin__, FloatPtr __dmin1, FloatPtr __dmin2, FloatPtr __dn, FloatPtr __dnm1, FloatPtr __dnm2,
            IntPtr __ieee);

    @Generated
    @CFunction
    public static native int slasq6_(IntPtr __i0, IntPtr __n0, FloatPtr __z__, IntPtr __pp, FloatPtr __dmin__,
            FloatPtr __dmin1, FloatPtr __dmin2, FloatPtr __dn, FloatPtr __dnm1, FloatPtr __dnm2);

    @Generated
    @CFunction
    public static native int slasr_(BytePtr __side, BytePtr __pivot, BytePtr __direct, IntPtr __m, IntPtr __n,
            FloatPtr __c__, FloatPtr __s, FloatPtr __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int slasrt_(BytePtr __id, IntPtr __n, FloatPtr __d__, IntPtr __info);

    @Generated
    @CFunction
    public static native int slassq_(IntPtr __n, FloatPtr __x, IntPtr __incx, FloatPtr __scale, FloatPtr __sumsq);

    @Generated
    @CFunction
    public static native int slasv2_(FloatPtr __f, FloatPtr __g, FloatPtr __h__, FloatPtr __ssmin, FloatPtr __ssmax,
            FloatPtr __snr, FloatPtr __csr, FloatPtr __snl, FloatPtr __csl);

    @Generated
    @CFunction
    public static native int slaswp_(IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __k1, IntPtr __k2, IntPtr __ipiv,
            IntPtr __incx);

    @Generated
    @CFunction
    public static native int slasy2_(IntPtr __ltranl, IntPtr __ltranr, IntPtr __isgn, IntPtr __n1, IntPtr __n2,
            FloatPtr __tl, IntPtr __ldtl, FloatPtr __tr, IntPtr __ldtr, FloatPtr __b, IntPtr __ldb, FloatPtr __scale,
            FloatPtr __x, IntPtr __ldx, FloatPtr __xnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int slasyf_(BytePtr __uplo, IntPtr __n, IntPtr __nb, IntPtr __kb, FloatPtr __a, IntPtr __lda,
            IntPtr __ipiv, FloatPtr __w, IntPtr __ldw, IntPtr __info);

    @Generated
    @CFunction
    public static native int slatbs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            IntPtr __kd, FloatPtr __ab, IntPtr __ldab, FloatPtr __x, FloatPtr __scale, FloatPtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int slatdf_(IntPtr __ijob, IntPtr __n, FloatPtr __z__, IntPtr __ldz, FloatPtr __rhs,
            FloatPtr __rdsum, FloatPtr __rdscal, IntPtr __ipiv, IntPtr __jpiv);

    @Generated
    @CFunction
    public static native int slatps_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            FloatPtr __ap, FloatPtr __x, FloatPtr __scale, FloatPtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int slatrd_(BytePtr __uplo, IntPtr __n, IntPtr __nb, FloatPtr __a, IntPtr __lda, FloatPtr __e,
            FloatPtr __tau, FloatPtr __w, IntPtr __ldw);

    @Generated
    @CFunction
    public static native int slatrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __x, FloatPtr __scale, FloatPtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int slatrz_(IntPtr __m, IntPtr __n, IntPtr __l, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work);

    @Generated
    @CFunction
    public static native int slatzm_(BytePtr __side, IntPtr __m, IntPtr __n, FloatPtr __v, IntPtr __incv,
            FloatPtr __tau, FloatPtr __c1, FloatPtr __c2, IntPtr __ldc, FloatPtr __work);

    @Generated
    @CFunction
    public static native int slauu2_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int slauum_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int sopgtr_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __tau, FloatPtr __q,
            IntPtr __ldq, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sopmtr_(BytePtr __side, BytePtr __uplo, BytePtr __trans, IntPtr __m, IntPtr __n,
            FloatPtr __ap, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorg2l_(IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorg2r_(IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorgbr_(BytePtr __vect, IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a, IntPtr __lda,
            FloatPtr __tau, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorghr_(IntPtr __n, IntPtr __ilo, IntPtr __ihi, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorgl2_(IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorglq_(IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorgql_(IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorgqr_(IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorgr2_(IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorgrq_(IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorgtr_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorm2l_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a,
            IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorm2r_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a,
            IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sormbr_(BytePtr __vect, BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n,
            IntPtr __k, FloatPtr __a, IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sormhr_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __ilo,
            IntPtr __ihi, FloatPtr __a, IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sorml2_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a,
            IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sormlq_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a,
            IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sormql_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a,
            IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sormqr_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a,
            IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sormr2_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a,
            IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sormr3_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, IntPtr __l,
            FloatPtr __a, IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sormrq_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, FloatPtr __a,
            IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sormrz_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, IntPtr __l,
            FloatPtr __a, IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sormtr_(BytePtr __side, BytePtr __uplo, BytePtr __trans, IntPtr __m, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __tau, FloatPtr __c__, IntPtr __ldc, FloatPtr __work, IntPtr __lwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int spbcon_(BytePtr __uplo, IntPtr __n, IntPtr __kd, FloatPtr __ab, IntPtr __ldab,
            FloatPtr __anorm, FloatPtr __rcond, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int spbequ_(BytePtr __uplo, IntPtr __n, IntPtr __kd, FloatPtr __ab, IntPtr __ldab,
            FloatPtr __s, FloatPtr __scond, FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int spbrfs_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs, FloatPtr __ab,
            IntPtr __ldab, FloatPtr __afb, IntPtr __ldafb, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int spbstf_(BytePtr __uplo, IntPtr __n, IntPtr __kd, FloatPtr __ab, IntPtr __ldab,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int spbsv_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs, FloatPtr __ab,
            IntPtr __ldab, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int spbsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            FloatPtr __ab, IntPtr __ldab, FloatPtr __afb, IntPtr __ldafb, BytePtr __equed, FloatPtr __s, FloatPtr __b,
            IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr,
            FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int spbtf2_(BytePtr __uplo, IntPtr __n, IntPtr __kd, FloatPtr __ab, IntPtr __ldab,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int spbtrf_(BytePtr __uplo, IntPtr __n, IntPtr __kd, FloatPtr __ab, IntPtr __ldab,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int spbtrs_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs, FloatPtr __ab,
            IntPtr __ldab, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int spftrf_(BytePtr __transr, BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __info);

    @Generated
    @CFunction
    public static native int spftri_(BytePtr __transr, BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __info);

    @Generated
    @CFunction
    public static native int spftrs_(BytePtr __transr, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __a,
            FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int spocon_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __anorm,
            FloatPtr __rcond, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int spoequ_(IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __s, FloatPtr __scond,
            FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int spoequb_(IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __s, FloatPtr __scond,
            FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int sporfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda,
            FloatPtr __af, IntPtr __ldaf, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __ferr,
            FloatPtr __berr, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sposv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda, FloatPtr __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sposvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __a,
            IntPtr __lda, FloatPtr __af, IntPtr __ldaf, BytePtr __equed, FloatPtr __s, FloatPtr __b, IntPtr __ldb,
            FloatPtr __x, IntPtr __ldx, FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr, FloatPtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int spotf2_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int spotrf_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int spotri_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int spotrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sppcon_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __anorm, FloatPtr __rcond,
            FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sppequ_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __s, FloatPtr __scond,
            FloatPtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int spprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __ap, FloatPtr __afp,
            FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr, FloatPtr __work,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sppsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __ap, FloatPtr __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sppsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __ap,
            FloatPtr __afp, BytePtr __equed, FloatPtr __s, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx,
            FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int spptrf_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int spptri_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int spptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __ap, FloatPtr __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int spstf2_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __piv,
            IntPtr __rank, FloatPtr __tol, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int spstrf_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __piv,
            IntPtr __rank, FloatPtr __tol, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sptcon_(IntPtr __n, FloatPtr __d__, FloatPtr __e, FloatPtr __anorm, FloatPtr __rcond,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int spteqr_(BytePtr __compz, IntPtr __n, FloatPtr __d__, FloatPtr __e, FloatPtr __z__,
            IntPtr __ldz, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sptrfs_(IntPtr __n, IntPtr __nrhs, FloatPtr __d__, FloatPtr __e, FloatPtr __df,
            FloatPtr __ef, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sptsv_(IntPtr __n, IntPtr __nrhs, FloatPtr __d__, FloatPtr __e, FloatPtr __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sptsvx_(BytePtr __fact, IntPtr __n, IntPtr __nrhs, FloatPtr __d__, FloatPtr __e,
            FloatPtr __df, FloatPtr __ef, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __rcond,
            FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int spttrf_(IntPtr __n, FloatPtr __d__, FloatPtr __e, IntPtr __info);

    @Generated
    @CFunction
    public static native int spttrs_(IntPtr __n, IntPtr __nrhs, FloatPtr __d__, FloatPtr __e, FloatPtr __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sptts2_(IntPtr __n, IntPtr __nrhs, FloatPtr __d__, FloatPtr __e, FloatPtr __b,
            IntPtr __ldb);

    @Generated
    @CFunction
    public static native int srscl_(IntPtr __n, FloatPtr __sa, FloatPtr __sx, IntPtr __incx);

    @Generated
    @CFunction
    public static native int ssbev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __kd, FloatPtr __ab,
            IntPtr __ldab, FloatPtr __w, FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssbevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __kd, FloatPtr __ab,
            IntPtr __ldab, FloatPtr __w, FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssbevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            FloatPtr __ab, IntPtr __ldab, FloatPtr __q, IntPtr __ldq, FloatPtr __vl, FloatPtr __vu, IntPtr __il,
            IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w, FloatPtr __z__, IntPtr __ldz, FloatPtr __work,
            IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssbgst_(BytePtr __vect, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            FloatPtr __ab, IntPtr __ldab, FloatPtr __bb, IntPtr __ldbb, FloatPtr __x, IntPtr __ldx, FloatPtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ssbgv_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb, FloatPtr __ab,
            IntPtr __ldab, FloatPtr __bb, IntPtr __ldbb, FloatPtr __w, FloatPtr __z__, IntPtr __ldz, FloatPtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ssbgvd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            FloatPtr __ab, IntPtr __ldab, FloatPtr __bb, IntPtr __ldbb, FloatPtr __w, FloatPtr __z__, IntPtr __ldz,
            FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssbgvx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, IntPtr __ka,
            IntPtr __kb, FloatPtr __ab, IntPtr __ldab, FloatPtr __bb, IntPtr __ldbb, FloatPtr __q, IntPtr __ldq,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssbtrd_(BytePtr __vect, BytePtr __uplo, IntPtr __n, IntPtr __kd, FloatPtr __ab,
            IntPtr __ldab, FloatPtr __d__, FloatPtr __e, FloatPtr __q, IntPtr __ldq, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssfrk_(BytePtr __transr, BytePtr __uplo, BytePtr __trans, IntPtr __n, IntPtr __k,
            FloatPtr __alpha, FloatPtr __a, IntPtr __lda, FloatPtr __beta, FloatPtr __c__);

    @Generated
    @CFunction
    public static native int sspcon_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, IntPtr __ipiv, FloatPtr __anorm,
            FloatPtr __rcond, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sspev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __w,
            FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sspevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __w,
            FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sspevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, FloatPtr __ap,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int sspgst_(IntPtr __itype, BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __bp,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int sspgv_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n, FloatPtr __ap,
            FloatPtr __bp, FloatPtr __w, FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sspgvd_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n, FloatPtr __ap,
            FloatPtr __bp, FloatPtr __w, FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sspgvx_(IntPtr __itype, BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            FloatPtr __ap, FloatPtr __bp, FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol,
            IntPtr __m, FloatPtr __w, FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __iwork, IntPtr __ifail,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ssprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __ap, FloatPtr __afp,
            IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr,
            FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sspsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __ap, IntPtr __ipiv,
            FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sspsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __ap,
            FloatPtr __afp, IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __rcond,
            FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssptrd_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __d__, FloatPtr __e,
            FloatPtr __tau, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssptrf_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssptri_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, IntPtr __ipiv, FloatPtr __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ssptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __ap, IntPtr __ipiv,
            FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int sstebz_(BytePtr __range, BytePtr __order, IntPtr __n, FloatPtr __vl, FloatPtr __vu,
            IntPtr __il, IntPtr __iu, FloatPtr __abstol, FloatPtr __d__, FloatPtr __e, IntPtr __m, IntPtr __nsplit,
            FloatPtr __w, IntPtr __iblock, IntPtr __isplit, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sstedc_(BytePtr __compz, IntPtr __n, FloatPtr __d__, FloatPtr __e, FloatPtr __z__,
            IntPtr __ldz, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sstegr_(BytePtr __jobz, BytePtr __range, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            FloatPtr __z__, IntPtr __ldz, IntPtr __isuppz, FloatPtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sstein_(IntPtr __n, FloatPtr __d__, FloatPtr __e, IntPtr __m, FloatPtr __w,
            IntPtr __iblock, IntPtr __isplit, FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __iwork,
            IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int sstemr_(BytePtr __jobz, BytePtr __range, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, IntPtr __m, FloatPtr __w, FloatPtr __z__,
            IntPtr __ldz, IntPtr __nzc, IntPtr __isuppz, IntPtr __tryrac, FloatPtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssteqr_(BytePtr __compz, IntPtr __n, FloatPtr __d__, FloatPtr __e, FloatPtr __z__,
            IntPtr __ldz, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssterf_(IntPtr __n, FloatPtr __d__, FloatPtr __e, IntPtr __info);

    @Generated
    @CFunction
    public static native int sstev_(BytePtr __jobz, IntPtr __n, FloatPtr __d__, FloatPtr __e, FloatPtr __z__,
            IntPtr __ldz, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int sstevd_(BytePtr __jobz, IntPtr __n, FloatPtr __d__, FloatPtr __e, FloatPtr __z__,
            IntPtr __ldz, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sstevr_(BytePtr __jobz, BytePtr __range, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            FloatPtr __z__, IntPtr __ldz, IntPtr __isuppz, FloatPtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int sstevx_(BytePtr __jobz, BytePtr __range, IntPtr __n, FloatPtr __d__, FloatPtr __e,
            FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w,
            FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssycon_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __ipiv,
            FloatPtr __anorm, FloatPtr __rcond, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssyequb_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __s,
            FloatPtr __scond, FloatPtr __amax, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssyev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __w, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssyevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __w, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssyevr_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, FloatPtr __a,
            IntPtr __lda, FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m,
            FloatPtr __w, FloatPtr __z__, IntPtr __ldz, IntPtr __isuppz, FloatPtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssyevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, FloatPtr __a,
            IntPtr __lda, FloatPtr __vl, FloatPtr __vu, IntPtr __il, IntPtr __iu, FloatPtr __abstol, IntPtr __m,
            FloatPtr __w, FloatPtr __z__, IntPtr __ldz, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __ifail,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ssygs2_(IntPtr __itype, BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssygst_(IntPtr __itype, BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssygv_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n, FloatPtr __a,
            IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __w, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssygvd_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n, FloatPtr __a,
            IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __w, FloatPtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssygvx_(IntPtr __itype, BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __vl, FloatPtr __vu, IntPtr __il,
            IntPtr __iu, FloatPtr __abstol, IntPtr __m, FloatPtr __w, FloatPtr __z__, IntPtr __ldz, FloatPtr __work,
            IntPtr __lwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssyrfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda,
            FloatPtr __af, IntPtr __ldaf, IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssysv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda,
            IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssysvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __a,
            IntPtr __lda, FloatPtr __af, IntPtr __ldaf, IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, FloatPtr __x,
            IntPtr __ldx, FloatPtr __rcond, FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssytd2_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __d__,
            FloatPtr __e, FloatPtr __tau, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssytf2_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __ipiv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ssytrd_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __d__,
            FloatPtr __e, FloatPtr __tau, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssytrf_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __ipiv,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssytri_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, IntPtr __ipiv,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int ssytrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, FloatPtr __a, IntPtr __lda,
            IntPtr __ipiv, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int stbcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, IntPtr __kd,
            FloatPtr __ab, IntPtr __ldab, FloatPtr __rcond, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int stbrfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __kd,
            IntPtr __nrhs, FloatPtr __ab, IntPtr __ldab, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx,
            FloatPtr __ferr, FloatPtr __berr, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int stbtrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __kd,
            IntPtr __nrhs, FloatPtr __ab, IntPtr __ldab, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int stfsm_(BytePtr __transr, BytePtr __side, BytePtr __uplo, BytePtr __trans, BytePtr __diag,
            IntPtr __m, IntPtr __n, FloatPtr __alpha, FloatPtr __a, FloatPtr __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int stftri_(BytePtr __transr, BytePtr __uplo, BytePtr __diag, IntPtr __n, FloatPtr __a,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int stfttp_(BytePtr __transr, BytePtr __uplo, IntPtr __n, FloatPtr __arf, FloatPtr __ap,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int stfttr_(BytePtr __transr, BytePtr __uplo, IntPtr __n, FloatPtr __arf, FloatPtr __a,
            IntPtr __lda, IntPtr __info);

    @Generated
    @CFunction
    public static native int stgevc_(BytePtr __side, BytePtr __howmny, IntPtr __select, IntPtr __n, FloatPtr __s,
            IntPtr __lds, FloatPtr __p, IntPtr __ldp, FloatPtr __vl, IntPtr __ldvl, FloatPtr __vr, IntPtr __ldvr,
            IntPtr __mm, IntPtr __m, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int stgex2_(IntPtr __wantq, IntPtr __wantz, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, FloatPtr __q, IntPtr __ldq, FloatPtr __z__, IntPtr __ldz, IntPtr __j1,
            IntPtr __n1, IntPtr __n2, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int stgexc_(IntPtr __wantq, IntPtr __wantz, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, FloatPtr __q, IntPtr __ldq, FloatPtr __z__, IntPtr __ldz, IntPtr __ifst,
            IntPtr __ilst, FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int stgsen_(IntPtr __ijob, IntPtr __wantq, IntPtr __wantz, IntPtr __select, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __alphar, FloatPtr __alphai,
            FloatPtr __beta, FloatPtr __q, IntPtr __ldq, FloatPtr __z__, IntPtr __ldz, IntPtr __m, FloatPtr __pl,
            FloatPtr __pr, FloatPtr __dif, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int stgsja_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __p, IntPtr __n,
            IntPtr __k, IntPtr __l, FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __tola,
            FloatPtr __tolb, FloatPtr __alpha, FloatPtr __beta, FloatPtr __u, IntPtr __ldu, FloatPtr __v, IntPtr __ldv,
            FloatPtr __q, IntPtr __ldq, FloatPtr __work, IntPtr __ncycle, IntPtr __info);

    @Generated
    @CFunction
    public static native int stgsna_(BytePtr __job, BytePtr __howmny, IntPtr __select, IntPtr __n, FloatPtr __a,
            IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __vl, IntPtr __ldvl, FloatPtr __vr, IntPtr __ldvr,
            FloatPtr __s, FloatPtr __dif, IntPtr __mm, IntPtr __m, FloatPtr __work, IntPtr __lwork, IntPtr __iwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int stgsy2_(BytePtr __trans, IntPtr __ijob, IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, FloatPtr __c__, IntPtr __ldc, FloatPtr __d__, IntPtr __ldd, FloatPtr __e,
            IntPtr __lde, FloatPtr __f, IntPtr __ldf, FloatPtr __scale, FloatPtr __rdsum, FloatPtr __rdscal,
            IntPtr __iwork, IntPtr __pq, IntPtr __info);

    @Generated
    @CFunction
    public static native int stgsyl_(BytePtr __trans, IntPtr __ijob, IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __b, IntPtr __ldb, FloatPtr __c__, IntPtr __ldc, FloatPtr __d__, IntPtr __ldd, FloatPtr __e,
            IntPtr __lde, FloatPtr __f, IntPtr __ldf, FloatPtr __scale, FloatPtr __dif, FloatPtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int stpcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, FloatPtr __ap,
            FloatPtr __rcond, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int stprfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            FloatPtr __ap, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __ferr, FloatPtr __berr,
            FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int stptri_(BytePtr __uplo, BytePtr __diag, IntPtr __n, FloatPtr __ap, IntPtr __info);

    @Generated
    @CFunction
    public static native int stptrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            FloatPtr __ap, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int stpttf_(BytePtr __transr, BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __arf,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int stpttr_(BytePtr __uplo, IntPtr __n, FloatPtr __ap, FloatPtr __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int strcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, FloatPtr __a,
            IntPtr __lda, FloatPtr __rcond, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int strevc_(BytePtr __side, BytePtr __howmny, IntPtr __select, IntPtr __n, FloatPtr __t,
            IntPtr __ldt, FloatPtr __vl, IntPtr __ldvl, FloatPtr __vr, IntPtr __ldvr, IntPtr __mm, IntPtr __m,
            FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int strexc_(BytePtr __compq, IntPtr __n, FloatPtr __t, IntPtr __ldt, FloatPtr __q,
            IntPtr __ldq, IntPtr __ifst, IntPtr __ilst, FloatPtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int strrfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __x, IntPtr __ldx, FloatPtr __ferr,
            FloatPtr __berr, FloatPtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int strsen_(BytePtr __job, BytePtr __compq, IntPtr __select, IntPtr __n, FloatPtr __t,
            IntPtr __ldt, FloatPtr __q, IntPtr __ldq, FloatPtr __wr, FloatPtr __wi, IntPtr __m, FloatPtr __s,
            FloatPtr __sep, FloatPtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int strsna_(BytePtr __job, BytePtr __howmny, IntPtr __select, IntPtr __n, FloatPtr __t,
            IntPtr __ldt, FloatPtr __vl, IntPtr __ldvl, FloatPtr __vr, IntPtr __ldvr, FloatPtr __s, FloatPtr __sep,
            IntPtr __mm, IntPtr __m, FloatPtr __work, IntPtr __ldwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int strsyl_(BytePtr __trana, BytePtr __tranb, IntPtr __isgn, IntPtr __m, IntPtr __n,
            FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, FloatPtr __c__, IntPtr __ldc, FloatPtr __scale,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int strti2_(BytePtr __uplo, BytePtr __diag, IntPtr __n, FloatPtr __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int strtri_(BytePtr __uplo, BytePtr __diag, IntPtr __n, FloatPtr __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int strtrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            FloatPtr __a, IntPtr __lda, FloatPtr __b, IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int strttf_(BytePtr __transr, BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda,
            FloatPtr __arf, IntPtr __info);

    @Generated
    @CFunction
    public static native int strttp_(BytePtr __uplo, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __ap,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int stzrqf_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau, IntPtr __info);

    @Generated
    @CFunction
    public static native int stzrzf_(IntPtr __m, IntPtr __n, FloatPtr __a, IntPtr __lda, FloatPtr __tau,
            FloatPtr __work, IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zbdsqr_(BytePtr __uplo, IntPtr __n, IntPtr __ncvt, IntPtr __nru, IntPtr __ncc,
            DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vt,
            IntPtr __ldvt, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __u,
            IntPtr __ldu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zcgesv_(IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __swork,
            DoublePtr __rwork, IntPtr __iter, IntPtr __info);

    @Generated
    @CFunction
    public static native int zcposv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __swork,
            DoublePtr __rwork, IntPtr __iter, IntPtr __info);

    @Generated
    @CFunction
    public static native int zdrscl_(IntPtr __n, DoublePtr __sa,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __sx,
            IntPtr __incx);

    @Generated
    @CFunction
    public static native int zgbbrd_(BytePtr __vect, IntPtr __m, IntPtr __n, IntPtr __ncc, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __pt,
            IntPtr __ldpt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgbcon_(BytePtr __norm, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, IntPtr __ipiv, DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgbequ_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __r__, DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgbequb_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __r__, DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgbrfs_(BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afb,
            IntPtr __ldafb, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgbsv_(IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgbsvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku,
            IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afb,
            IntPtr __ldafb, IntPtr __ipiv, BytePtr __equed, DoublePtr __r__, DoublePtr __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgbtf2_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgbtrf_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgbtrs_(BytePtr __trans, IntPtr __n, IntPtr __kl, IntPtr __ku, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgebak_(BytePtr __job, BytePtr __side, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __scale, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgebal_(BytePtr __job, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ilo, IntPtr __ihi, DoublePtr __scale, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgebd2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tauq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __taup,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgebrd_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tauq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __taup,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgecon_(BytePtr __norm, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeequ_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __r__, DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeequb_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __r__, DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeev_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeevx_(BytePtr __balanc, BytePtr __jobvl, BytePtr __jobvr, BytePtr __sense, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr, IntPtr __ilo, IntPtr __ihi, DoublePtr __scale, DoublePtr __abnrm, DoublePtr __rconde,
            DoublePtr __rcondv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgegs_(BytePtr __jobvsl, BytePtr __jobvsr, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vsl,
            IntPtr __ldvsl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vsr,
            IntPtr __ldvsr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgegv_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgehd2_(IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgehrd_(IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgelq2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgelqf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgels_(BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgelsd_(IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            DoublePtr __s, DoublePtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgelss_(IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            DoublePtr __s, DoublePtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgelsx_(IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __jpvt, DoublePtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgelsy_(IntPtr __m, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __jpvt, DoublePtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeql2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeqlf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeqp3_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __jpvt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeqpf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __jpvt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeqr2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgeqrf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgerfs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __af,
            IntPtr __ldaf, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgerq2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgerqf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgesc2_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __rhs,
            IntPtr __ipiv, IntPtr __jpiv, DoublePtr __scale);

    @Generated
    @CFunction
    public static native int zgesdd_(BytePtr __jobz, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __s, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __u,
            IntPtr __ldu, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vt,
            IntPtr __ldvt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgesv_(IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgesvd_(BytePtr __jobu, BytePtr __jobvt, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __s, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __u,
            IntPtr __ldu, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vt,
            IntPtr __ldvt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgesvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __af,
            IntPtr __ldaf, IntPtr __ipiv, BytePtr __equed, DoublePtr __r__, DoublePtr __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgetc2_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __jpiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgetf2_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgetrf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgetri_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgetrs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zggbak_(BytePtr __job, BytePtr __side, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            DoublePtr __lscale, DoublePtr __rscale, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zggbal_(BytePtr __job, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __ilo, IntPtr __ihi, DoublePtr __lscale, DoublePtr __rscale, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int zggev_(BytePtr __jobvl, BytePtr __jobvr, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zggevx_(BytePtr __balanc, BytePtr __jobvl, BytePtr __jobvr, BytePtr __sense, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr, IntPtr __ilo, IntPtr __ihi, DoublePtr __lscale, DoublePtr __rscale, DoublePtr __abnrm,
            DoublePtr __bbnrm, DoublePtr __rconde, DoublePtr __rcondv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __iwork, IntPtr __bwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zggglm_(IntPtr __n, IntPtr __m, IntPtr __p,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgghrd_(BytePtr __compq, BytePtr __compz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgglse_(IntPtr __m, IntPtr __n, IntPtr __p,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zggqrf_(IntPtr __n, IntPtr __m, IntPtr __p,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __taua,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __taub,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zggrqf_(IntPtr __m, IntPtr __p, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __taua,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __taub,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zggsvd_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __n, IntPtr __p,
            IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            DoublePtr __alpha, DoublePtr __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __u, IntPtr __ldu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zggsvp_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __p, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            DoublePtr __tola, DoublePtr __tolb, IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __u, IntPtr __ldu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            IntPtr __iwork, DoublePtr __rwork,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgtcon_(BytePtr __norm, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du2,
            IntPtr __ipiv, DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgtrfs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dlf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __df,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __duf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du2,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgtsv_(IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zgtsvx_(BytePtr __fact, BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dlf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __df,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __duf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du2,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx, DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgttrf_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du2,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgttrs_(BytePtr __trans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du2,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zgtts2_(IntPtr __itrans, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du2,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb);

    @Generated
    @CFunction
    public static native int zhbev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhbevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhbevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q,
            IntPtr __ldq, DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhbgst_(BytePtr __vect, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bb,
            IntPtr __ldbb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhbgv_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bb,
            IntPtr __ldbb, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhbgvd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n, IntPtr __ka, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bb,
            IntPtr __ldbb, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhbgvx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n, IntPtr __ka,
            IntPtr __kb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bb,
            IntPtr __ldbb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q,
            IntPtr __ldq, DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhbtrd_(BytePtr __vect, BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zhecon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zheequb_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zheev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zheevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zheevr_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __isuppz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zheevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhegs2_(IntPtr __itype, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zhegst_(IntPtr __itype, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zhegv_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhegvd_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhegvx_(IntPtr __itype, BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int zherfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __af,
            IntPtr __ldaf, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhesv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhesvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __af,
            IntPtr __ldaf, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhetd2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zhetf2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhetrd_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhetrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhetri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zhetrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhfrk_(BytePtr __transr, BytePtr __uplo, BytePtr __trans, IntPtr __n, IntPtr __k,
            DoublePtr __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__);

    @Generated
    @CFunction
    public static native int zhgeqz_(BytePtr __job, BytePtr __compq, BytePtr __compz, IntPtr __n, IntPtr __ilo,
            IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t,
            IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpcon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv, DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpev_(BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpevd_(BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpevx_(BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpgst_(IntPtr __itype, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bp,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpgv_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bp,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpgvd_(IntPtr __itype, BytePtr __jobz, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bp,
            DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpgvx_(IntPtr __itype, BytePtr __jobz, BytePtr __range, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bp,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afp,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhpsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afp,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx, DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhptrd_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zhptrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhptri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zhptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhsein_(BytePtr __side, BytePtr __eigsrc, BytePtr __initv, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr, IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __ifaill, IntPtr __ifailr, IntPtr __info);

    @Generated
    @CFunction
    public static native int zhseqr_(BytePtr __job, BytePtr __compz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlabrd_(IntPtr __m, IntPtr __n, IntPtr __nb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tauq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __taup,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int zlacgv_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __incx);

    @Generated
    @CFunction
    public static native int zlacn2_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            DoublePtr __est, IntPtr __kase, IntPtr __isave);

    @Generated
    @CFunction
    public static native int zlacon_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            DoublePtr __est, IntPtr __kase);

    @Generated
    @CFunction
    public static native int zlacp2_(BytePtr __uplo, IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int zlacpy_(BytePtr __uplo, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int zlacrm_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc, DoublePtr __rwork);

    @Generated
    @CFunction
    public static native int zlacrt_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __cx,
            IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __cy,
            IntPtr __incy,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __s);

    @Generated
    @CFunction
    public static native void zladiv_(
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ret_val,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y);

    @Generated
    @CFunction
    public static native int zlaed0_(IntPtr __qsiz, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __qstore,
            IntPtr __ldqs, DoublePtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlaed7_(IntPtr __n, IntPtr __cutpnt, IntPtr __qsiz, IntPtr __tlvls, IntPtr __curlvl,
            IntPtr __curpbm, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            DoublePtr __rho, IntPtr __indxq, DoublePtr __qstore, IntPtr __qptr, IntPtr __prmptr, IntPtr __perm,
            IntPtr __givptr, IntPtr __givcol, DoublePtr __givnum,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlaed8_(IntPtr __k, IntPtr __n, IntPtr __qsiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            DoublePtr __d__, DoublePtr __rho, IntPtr __cutpnt, DoublePtr __z__, DoublePtr __dlamda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q2,
            IntPtr __ldq2, DoublePtr __w, IntPtr __indxp, IntPtr __indx, IntPtr __indxq, IntPtr __perm, IntPtr __givptr,
            IntPtr __givcol, DoublePtr __givnum, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlaein_(IntPtr __rightv, IntPtr __noinit, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            DoublePtr __rwork, DoublePtr __eps3, DoublePtr __smlnum, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlaesy_(
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __rt1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __rt2,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __evscal,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __cs1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __sn1);

    @Generated
    @CFunction
    public static native int zlaev2_(
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            DoublePtr __rt1, DoublePtr __rt2, DoublePtr __cs1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __sn1);

    @Generated
    @CFunction
    public static native int zlag2c_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __sa, IntPtr __ldsa,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zlags2_(IntPtr __upper, DoublePtr __a1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a2,
            DoublePtr __a3, DoublePtr __b1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b2,
            DoublePtr __b3, DoublePtr __csu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __snu,
            DoublePtr __csv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __snv,
            DoublePtr __csq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __snq);

    @Generated
    @CFunction
    public static native int zlagtm_(BytePtr __trans, IntPtr __n, IntPtr __nrhs, DoublePtr __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int zlahef_(BytePtr __uplo, IntPtr __n, IntPtr __nb, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            IntPtr __ldw, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlahqr_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            IntPtr __iloz, IntPtr __ihiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlahr2_(IntPtr __n, IntPtr __k, IntPtr __nb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int zlahrd_(IntPtr __n, IntPtr __k, IntPtr __nb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y, IntPtr __ldy);

    @Generated
    @CFunction
    public static native int zlaic1_(IntPtr __job, IntPtr __j,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            DoublePtr __sest,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __gamma,
            DoublePtr __sestpr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__);

    @Generated
    @CFunction
    public static native int zlals0_(IntPtr __icompq, IntPtr __nl, IntPtr __nr, IntPtr __sqre, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bx,
            IntPtr __ldbx, IntPtr __perm, IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, DoublePtr __givnum,
            IntPtr __ldgnum, DoublePtr __poles, DoublePtr __difl, DoublePtr __difr, DoublePtr __z__, IntPtr __k,
            DoublePtr __c__, DoublePtr __s, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlalsa_(IntPtr __icompq, IntPtr __smlsiz, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __bx,
            IntPtr __ldbx, DoublePtr __u, IntPtr __ldu, DoublePtr __vt, IntPtr __k, DoublePtr __difl, DoublePtr __difr,
            DoublePtr __z__, DoublePtr __poles, IntPtr __givptr, IntPtr __givcol, IntPtr __ldgcol, IntPtr __perm,
            DoublePtr __givnum, DoublePtr __c__, DoublePtr __s, DoublePtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlalsd_(BytePtr __uplo, IntPtr __smlsiz, IntPtr __n, IntPtr __nrhs, DoublePtr __d__,
            DoublePtr __e, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, DoublePtr __rcond, IntPtr __rank,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native double zlangb_(BytePtr __norm, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlange_(BytePtr __norm, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlangt_(BytePtr __norm, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __dl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __du);

    @Generated
    @CFunction
    public static native double zlanhb_(BytePtr __norm, BytePtr __uplo, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlanhe_(BytePtr __norm, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlanhf_(BytePtr __norm, BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlanhp_(BytePtr __norm, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlanhs_(BytePtr __norm, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlanht_(BytePtr __norm, IntPtr __n, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e);

    @Generated
    @CFunction
    public static native double zlansb_(BytePtr __norm, BytePtr __uplo, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlansp_(BytePtr __norm, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlansy_(BytePtr __norm, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlantb_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlantp_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native double zlantr_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __work);

    @Generated
    @CFunction
    public static native int zlapll_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y, IntPtr __incy,
            DoublePtr __ssmin);

    @Generated
    @CFunction
    public static native int zlapmt_(IntPtr __forwrd, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            IntPtr __k);

    @Generated
    @CFunction
    public static native int zlaqgb_(IntPtr __m, IntPtr __n, IntPtr __kl, IntPtr __ku,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __r__, DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax,
            BytePtr __equed);

    @Generated
    @CFunction
    public static native int zlaqge_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __r__, DoublePtr __c__, DoublePtr __rowcnd, DoublePtr __colcnd, DoublePtr __amax,
            BytePtr __equed);

    @Generated
    @CFunction
    public static native int zlaqhb_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __s, DoublePtr __scond, DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int zlaqhe_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int zlaqhp_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int zlaqp2_(IntPtr __m, IntPtr __n, IntPtr __offset,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __jpvt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            DoublePtr __vn1, DoublePtr __vn2,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work);

    @Generated
    @CFunction
    public static native int zlaqps_(IntPtr __m, IntPtr __n, IntPtr __offset, IntPtr __nb, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __jpvt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            DoublePtr __vn1, DoublePtr __vn2,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __auxv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __f, IntPtr __ldf);

    @Generated
    @CFunction
    public static native int zlaqr0_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            IntPtr __iloz, IntPtr __ihiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlaqr1_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __s1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __s2,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v);

    @Generated
    @CFunction
    public static native int zlaqr2_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ktop, IntPtr __kbot,
            IntPtr __nw, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, IntPtr __iloz, IntPtr __ihiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __ns, IntPtr __nd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __sh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            IntPtr __nh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t,
            IntPtr __ldt, IntPtr __nv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __wv,
            IntPtr __ldwv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork);

    @Generated
    @CFunction
    public static native int zlaqr3_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ktop, IntPtr __kbot,
            IntPtr __nw, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, IntPtr __iloz, IntPtr __ihiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __ns, IntPtr __nd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __sh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            IntPtr __nh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t,
            IntPtr __ldt, IntPtr __nv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __wv,
            IntPtr __ldwv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork);

    @Generated
    @CFunction
    public static native int zlaqr4_(IntPtr __wantt, IntPtr __wantz, IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            IntPtr __iloz, IntPtr __ihiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlaqr5_(IntPtr __wantt, IntPtr __wantz, IntPtr __kacc22, IntPtr __n, IntPtr __ktop,
            IntPtr __kbot, IntPtr __nshfts,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __h__,
            IntPtr __ldh, IntPtr __iloz, IntPtr __ihiz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v,
            IntPtr __ldv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __u,
            IntPtr __ldu, IntPtr __nv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __wv,
            IntPtr __ldwv, IntPtr __nh,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __wh,
            IntPtr __ldwh);

    @Generated
    @CFunction
    public static native int zlaqsb_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __s, DoublePtr __scond, DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int zlaqsp_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int zlaqsy_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax, BytePtr __equed);

    @Generated
    @CFunction
    public static native int zlar1v_(IntPtr __n, IntPtr __b1, IntPtr __bn, DoublePtr __lambda, DoublePtr __d__,
            DoublePtr __l, DoublePtr __ld, DoublePtr __lld, DoublePtr __pivmin, DoublePtr __gaptol,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __wantnc, IntPtr __negcnt, DoublePtr __ztz, DoublePtr __mingma, IntPtr __r__, IntPtr __isuppz,
            DoublePtr __nrminv, DoublePtr __resid, DoublePtr __rqcorr, DoublePtr __work);

    @Generated
    @CFunction
    public static native int zlar2v_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __incx, DoublePtr __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __s,
            IntPtr __incc);

    @Generated
    @CFunction
    public static native int zlarcm_(IntPtr __m, IntPtr __n, DoublePtr __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc, DoublePtr __rwork);

    @Generated
    @CFunction
    public static native int zlarf_(BytePtr __side, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __incv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work);

    @Generated
    @CFunction
    public static native int zlarfb_(BytePtr __side, BytePtr __trans, BytePtr __direct, BytePtr __storev, IntPtr __m,
            IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __ldwork);

    @Generated
    @CFunction
    public static native int zlarfg_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau);

    @Generated
    @CFunction
    public static native int zlarfp_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau);

    @Generated
    @CFunction
    public static native int zlarft_(BytePtr __direct, BytePtr __storev, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt);

    @Generated
    @CFunction
    public static native int zlarfx_(BytePtr __side, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work);

    @Generated
    @CFunction
    public static native int zlargv_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y, IntPtr __incy,
            DoublePtr __c__, IntPtr __incc);

    @Generated
    @CFunction
    public static native int zlarnv_(IntPtr __idist, IntPtr __iseed, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x);

    @Generated
    @CFunction
    public static native int zlarrv_(IntPtr __n, DoublePtr __vl, DoublePtr __vu, DoublePtr __d__, DoublePtr __l,
            DoublePtr __pivmin, IntPtr __isplit, IntPtr __m, IntPtr __dol, IntPtr __dou, DoublePtr __minrgp,
            DoublePtr __rtol1, DoublePtr __rtol2, DoublePtr __w, DoublePtr __werr, DoublePtr __wgap, IntPtr __iblock,
            IntPtr __indexw, DoublePtr __gers,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __isuppz, DoublePtr __work, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlarscl2_(IntPtr __m, IntPtr __n, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx);

    @Generated
    @CFunction
    public static native int zlartg_(
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __f,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __g,
            DoublePtr __cs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __sn,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __r__);

    @Generated
    @CFunction
    public static native int zlartv_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y, IntPtr __incy,
            DoublePtr __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __s,
            IntPtr __incc);

    @Generated
    @CFunction
    public static native int zlarz_(BytePtr __side, IntPtr __m, IntPtr __n, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __incv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work);

    @Generated
    @CFunction
    public static native int zlarzb_(BytePtr __side, BytePtr __trans, BytePtr __direct, BytePtr __storev, IntPtr __m,
            IntPtr __n, IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __ldwork);

    @Generated
    @CFunction
    public static native int zlarzt_(BytePtr __direct, BytePtr __storev, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt);

    @Generated
    @CFunction
    public static native int zlascl_(BytePtr __type__, IntPtr __kl, IntPtr __ku, DoublePtr __cfrom, DoublePtr __cto,
            IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zlascl2_(IntPtr __m, IntPtr __n, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx);

    @Generated
    @CFunction
    public static native int zlaset_(BytePtr __uplo, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int zlasr_(BytePtr __side, BytePtr __pivot, BytePtr __direct, IntPtr __m, IntPtr __n,
            DoublePtr __c__, DoublePtr __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int zlassq_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            DoublePtr __scale, DoublePtr __sumsq);

    @Generated
    @CFunction
    public static native int zlaswp_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __k1, IntPtr __k2, IntPtr __ipiv, IntPtr __incx);

    @Generated
    @CFunction
    public static native int zlasyf_(BytePtr __uplo, IntPtr __n, IntPtr __nb, IntPtr __kb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w,
            IntPtr __ldw, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlat2c_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_complex __sa, IntPtr __ldsa,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zlatbs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            IntPtr __kd, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            DoublePtr __scale, DoublePtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlatdf_(IntPtr __ijob, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __rhs,
            DoublePtr __rdsum, DoublePtr __rdscal, IntPtr __ipiv, IntPtr __jpiv);

    @Generated
    @CFunction
    public static native int zlatps_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            DoublePtr __scale, DoublePtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlatrd_(BytePtr __uplo, IntPtr __n, IntPtr __nb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w, IntPtr __ldw);

    @Generated
    @CFunction
    public static native int zlatrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, BytePtr __normin, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            DoublePtr __scale, DoublePtr __cnorm, IntPtr __info);

    @Generated
    @CFunction
    public static native int zlatrz_(IntPtr __m, IntPtr __n, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work);

    @Generated
    @CFunction
    public static native int zlatzm_(BytePtr __side, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __incv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c1,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c2, IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work);

    @Generated
    @CFunction
    public static native int zlauu2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zlauum_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpbcon_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpbequ_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __s, DoublePtr __scond, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpbrfs_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afb,
            IntPtr __ldafb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpbstf_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpbsv_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpbsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afb,
            IntPtr __ldafb, BytePtr __equed, DoublePtr __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpbtf2_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpbtrf_(BytePtr __uplo, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpbtrs_(BytePtr __uplo, IntPtr __n, IntPtr __kd, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpftrf_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpftri_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpftrs_(BytePtr __transr, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpocon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpoequ_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpoequb_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int zporfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __af,
            IntPtr __ldaf, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zposv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zposvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __af,
            IntPtr __ldaf, BytePtr __equed, DoublePtr __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpotf2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpotrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpotri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpotrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zppcon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zppequ_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afp,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zppsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zppsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afp,
            BytePtr __equed, DoublePtr __s,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpptrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpptri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpstf2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __piv, IntPtr __rank, DoublePtr __tol, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpstrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __piv, IntPtr __rank, DoublePtr __tol, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int zptcon_(IntPtr __n, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e,
            DoublePtr __anorm, DoublePtr __rcond, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpteqr_(BytePtr __compz, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int zptrfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e,
            DoublePtr __df,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ef,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zptsv_(IntPtr __n, IntPtr __nrhs, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zptsvx_(BytePtr __fact, IntPtr __n, IntPtr __nrhs, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e,
            DoublePtr __df,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ef,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zpttrf_(IntPtr __n, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zpttrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zptts2_(IntPtr __iuplo, IntPtr __n, IntPtr __nrhs, DoublePtr __d__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int zrot_(IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __cx,
            IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __cy,
            IntPtr __incy, DoublePtr __c__,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __s);

    @Generated
    @CFunction
    public static native int zspcon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv, DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zspmv_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y,
            IntPtr __incy);

    @Generated
    @CFunction
    public static native int zspr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap);

    @Generated
    @CFunction
    public static native int zsprfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afp,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zspsv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zspsvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __afp,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx, DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zsptrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zsptri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zsptrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int zstedc_(BytePtr __compz, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __lrwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zstegr_(BytePtr __jobz, BytePtr __range, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, DoublePtr __abstol, IntPtr __m, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __isuppz, DoublePtr __work, IntPtr __lwork, IntPtr __iwork, IntPtr __liwork,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zstein_(IntPtr __n, DoublePtr __d__, DoublePtr __e, IntPtr __m, DoublePtr __w,
            IntPtr __iblock, IntPtr __isplit,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, DoublePtr __work, IntPtr __iwork, IntPtr __ifail, IntPtr __info);

    @Generated
    @CFunction
    public static native int zstemr_(BytePtr __jobz, BytePtr __range, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            DoublePtr __vl, DoublePtr __vu, IntPtr __il, IntPtr __iu, IntPtr __m, DoublePtr __w,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __nzc, IntPtr __isuppz, IntPtr __tryrac, DoublePtr __work, IntPtr __lwork,
            IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zsteqr_(BytePtr __compz, IntPtr __n, DoublePtr __d__, DoublePtr __e,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, DoublePtr __work, IntPtr __info);

    @Generated
    @CFunction
    public static native int zsycon_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, DoublePtr __anorm, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zsyequb_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __s, DoublePtr __scond, DoublePtr __amax,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zsymv_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __y,
            IntPtr __incy);

    @Generated
    @CFunction
    public static native int zsyr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __incx,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda);

    @Generated
    @CFunction
    public static native int zsyrfs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __af,
            IntPtr __ldaf, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zsysv_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zsysvx_(BytePtr __fact, BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __af,
            IntPtr __ldaf, IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __rcond, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zsytf2_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, IntPtr __info);

    @Generated
    @CFunction
    public static native int zsytrf_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zsytri_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zsytrs_(BytePtr __uplo, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __ipiv, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztbcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n, IntPtr __kd,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztbrfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __kd,
            IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x,
            IntPtr __ldx, DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztbtrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __kd,
            IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ab,
            IntPtr __ldab, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b,
            IntPtr __ldb, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztfsm_(BytePtr __transr, BytePtr __side, BytePtr __uplo, BytePtr __trans, BytePtr __diag,
            IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb);

    @Generated
    @CFunction
    public static native int ztftri_(BytePtr __transr, BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztfttp_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __arf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztfttr_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __arf,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztgevc_(BytePtr __side, BytePtr __howmny, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __s, IntPtr __lds,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __p, IntPtr __ldp,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr, IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztgex2_(IntPtr __wantq, IntPtr __wantz, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __j1, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztgexc_(IntPtr __wantq, IntPtr __wantz, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __ifst, IntPtr __ilst, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztgsen_(IntPtr __ijob, IntPtr __wantq, IntPtr __wantz, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __z__,
            IntPtr __ldz, IntPtr __m, DoublePtr __pl, DoublePtr __pr, DoublePtr __dif,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __iwork, IntPtr __liwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztgsja_(BytePtr __jobu, BytePtr __jobv, BytePtr __jobq, IntPtr __m, IntPtr __p, IntPtr __n,
            IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            DoublePtr __tola, DoublePtr __tolb, DoublePtr __alpha, DoublePtr __beta,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __u, IntPtr __ldu,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __v, IntPtr __ldv,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __ncycle, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztgsna_(BytePtr __job, BytePtr __howmny, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr, DoublePtr __s, DoublePtr __dif, IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztgsy2_(BytePtr __trans, IntPtr __ijob, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            IntPtr __ldd, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e,
            IntPtr __lde, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __f,
            IntPtr __ldf, DoublePtr __scale, DoublePtr __rdsum, DoublePtr __rdscal, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztgsyl_(BytePtr __trans, IntPtr __ijob, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __d__,
            IntPtr __ldd, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __e,
            IntPtr __lde, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __f,
            IntPtr __ldf, DoublePtr __scale, DoublePtr __dif,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __iwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztpcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztprfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztptri_(BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztptrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztpttf_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __arf,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztpttr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrcon_(BytePtr __norm, BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            DoublePtr __rcond,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrevc_(BytePtr __side, BytePtr __howmny, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr, IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrexc_(BytePtr __compq, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            IntPtr __ifst, IntPtr __ilst, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrrfs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __x, IntPtr __ldx,
            DoublePtr __ferr, DoublePtr __berr,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrsen_(BytePtr __job, BytePtr __compq, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __w, IntPtr __m,
            DoublePtr __s, DoublePtr __sep,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrsna_(BytePtr __job, BytePtr __howmny, IntPtr __select, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __t, IntPtr __ldt,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vl,
            IntPtr __ldvl,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __vr,
            IntPtr __ldvr, DoublePtr __s, DoublePtr __sep, IntPtr __mm, IntPtr __m,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __ldwork, DoublePtr __rwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrsyl_(BytePtr __trana, BytePtr __tranb, IntPtr __isgn, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc, DoublePtr __scale, IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrti2_(BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrtri_(BytePtr __uplo, BytePtr __diag, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrtrs_(BytePtr __uplo, BytePtr __trans, BytePtr __diag, IntPtr __n, IntPtr __nrhs,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __b, IntPtr __ldb,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrttf_(BytePtr __transr, BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __arf,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztrttp_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztzrqf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int ztzrzf_(IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zung2l_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zung2r_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zungbr_(BytePtr __vect, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zunghr_(IntPtr __n, IntPtr __ilo, IntPtr __ihi,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zungl2_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zunglq_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zungql_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zungqr_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zungr2_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zungrq_(IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zungtr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zunm2l_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zunm2r_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmbr_(BytePtr __vect, BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n,
            IntPtr __k, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmhr_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __ilo,
            IntPtr __ihi, @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a,
            IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zunml2_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmlq_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmql_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmqr_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmr2_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmr3_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmrq_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmrz_(BytePtr __side, BytePtr __trans, IntPtr __m, IntPtr __n, IntPtr __k, IntPtr __l,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zunmtr_(BytePtr __side, BytePtr __uplo, BytePtr __trans, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __a, IntPtr __lda,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __lwork, IntPtr __info);

    @Generated
    @CFunction
    public static native int zupgtr_(BytePtr __uplo, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __q, IntPtr __ldq,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int zupmtr_(BytePtr __side, BytePtr __uplo, BytePtr __trans, IntPtr __m, IntPtr __n,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __ap,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __tau,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __c__,
            IntPtr __ldc,
            @UncertainArgument("Options: reference, array Fallback: reference") __CLPK_doublecomplex __work,
            IntPtr __info);

    @Generated
    @CFunction
    public static native int dlamc1_(IntPtr __beta, IntPtr __t, IntPtr __rnd, IntPtr __ieee1);

    @Generated
    @CFunction
    public static native double slamch_(BytePtr __cmach);

    @Generated
    @CFunction
    public static native int slamc1_(IntPtr __beta, IntPtr __t, IntPtr __rnd, IntPtr __ieee1);

    @Generated
    @CFunction
    public static native int slamc2_(IntPtr __beta, IntPtr __t, IntPtr __rnd, FloatPtr __eps, IntPtr __emin,
            FloatPtr __rmin, IntPtr __emax, FloatPtr __rmax);

    @Generated
    @CFunction
    public static native double slamc3_(FloatPtr __a, FloatPtr __b);

    @Generated
    @CFunction
    public static native int slamc4_(IntPtr __emin, FloatPtr __start, IntPtr __base);

    @Generated
    @CFunction
    public static native int slamc5_(IntPtr __beta, IntPtr __p, IntPtr __emin, IntPtr __ieee, IntPtr __emax,
            FloatPtr __rmax);

    @Generated
    @CFunction
    public static native double dlamch_(BytePtr __cmach);

    @Generated
    @CFunction
    public static native int dlamc2_(IntPtr __beta, IntPtr __t, IntPtr __rnd, DoublePtr __eps, IntPtr __emin,
            DoublePtr __rmin, IntPtr __emax, DoublePtr __rmax);

    @Generated
    @CFunction
    public static native double dlamc3_(DoublePtr __a, DoublePtr __b);

    @Generated
    @CFunction
    public static native int dlamc4_(IntPtr __emin, DoublePtr __start, IntPtr __base);

    @Generated
    @CFunction
    public static native int dlamc5_(IntPtr __beta, IntPtr __p, IntPtr __emin, IntPtr __ieee, IntPtr __emax,
            DoublePtr __rmax);

    /**
     * Increment the reference count of a la_object_t object.
     * <p>
     * On a platform with the modern Objective-C runtime this is exactly equivalent
     * to sending the object the -[retain] message.
     *
     * @param object The object to retain.
     * @return The retained object.
     */
    @Generated
    @CFunction
    public static native NSObject la_retain(NSObject object);

    /**
     * Decrement the reference count of an la_object_t object.
     * <p>
     * On a platform with the modern Objective-C runtime this is exactly equivalent
     * to sending the object the -[release] message.
     *
     * @param object The object to release.
     */
    @Generated
    @CFunction
    public static native void la_release(NSObject object);

    /**
     * Add attributes to an la_object_t object.
     * <p>
     * This operation does not remove any existing attributes from the LinearAlgebra
     * object, though it is possible that some attributes will override others (if so,
     * this will be documented in the discussion of those attributes above).
     * Following this function call, the specified object has all of the attributes it
     * had before the call, plus any new attributes specified by the second parameter.
     * <p>
     * Adding an attribute that the object already has does not change the object.
     * <p>
     * This function is not reentrant or thread-safe.  Attempting to add or remove
     * attributes from multiple threads will have unpredictable results.
     *
     * @param object     The object that will have its attributes modified.
     * @param attributes Attributes which are to be added to the object's existing attributes
     *                   to create its new set of attributes.  This value should be constructed by
     *                   or'ing together LA_ATTRIBUTE_* constants.
     */
    @Generated
    @CFunction
    public static native void la_add_attributes(NSObject object, @NUInt long attributes);

    /**
     * Remove attributes from an la_object_t object.
     * <p>
     * This function removes the specified attributes from the LinearAlgebra object.
     * Removing an attribute that the object does not have is harmless and does not
     * change the object.
     * <p>
     * This function is not reentrant or thread-safe.  Attempting to add or remove
     * attributes from multiple threads will have unpredictable results.
     *
     * @param object     The object that will have its attributes modified.
     * @param attributes Attributes which are to be removed from the object's existing attributes
     *                   to create its new set of attributes.  This value should be constructed by
     *                   or'ing together LA_ATTRIBUTE_* constants.
     */
    @Generated
    @CFunction
    public static native void la_remove_attributes(NSObject object, @NUInt long attributes);

    /**
     * Query the status of an la_object.
     * <p>
     * Returns the status of a LinearAlgebra object.  The status will be
     * one of the codes defined in LinearAlgebra/base.h.  New status codes may be
     * added in the future, but the following basic principle will continue to hold:
     * zero indicates success, status codes greater than zero are warnings, and
     * status codes less than zero are errors.  Thus, careful error handling
     * might look like the following:
     *
     * <pre>
     * @textblock
     * la_status_t status = la_status(result_object);
     * if (status == LA_SUCCESS) {
     *    // Everything is copacetic.  Get your data from result_object.
     * } else if (status > 0) {
     *    // No errors occured, but the result does not have full accuracy due to
     *    // numerical considerations.  Here, you might re-compute the result using
     *    // a more careful or stable algorithm.
     * } else {
     *    // An error occured.  Something is seriously amiss and you will need
     *    // to handle it however makes sense for your application.
     * }
     * @/textblock
     * </pre>
     * <p>
     * Note that errors and warnings are propagated.  In general, there is no need
     * to check the status of each subcomputation.  Rather, the preferred idiom is
     * to do a complete computation, then check to see if anything went wrong.
     * Querying status may force evaluation of parts of your computation that might
     * otherwise be deferred until their results were actually needed.
     *
     * @param object The object whose status is being requested.
     * @return The status of the supplied object.
     */
    @Generated
    @CFunction
    @NInt
    public static native long la_status(NSObject object);

    /**
     * Create a matrix using data from a buffer of floats.  Ownership of the buffer
     * remains in control of the caller.
     * <p>
     * This function creates an object representing a matrix whose entries are
     * copied out of the supplied buffer of floats.  Negative or zero strides
     * are not supported by this function (but note that you can reverse the
     * rows or columns using the la_matrix_slice function defined below).
     * <p>
     * This routine assumes that the elements of the matrix are stored in the buffer
     * in row-major order.  If you need to work with data that is in column-major
     * order, you can do that as follows:
     * <p>
     * 1. Use this routine to create a matrix object, but pass the number of
     * columns in your matrix for the matrix_rows parameter and vice-versa.  For
     * the matrix_row_stride parameter, pass the column stride of your matrix.
     * <p>
     * 2. Make a new matrix transpose object from the object created in step 1.  The
     * resulting object represents the matrix that you want to work with.
     *
     * @param buffer            Pointer to float data providing the elements of the matrix.
     * @param matrix_rows       The number of rows in the matrix.
     * @param matrix_cols       The number of columns in the matrix.
     * @param matrix_row_stride The offset in the buffer (measured in floats) between corresponding elements
     *                          in consecutive rows of the matrix.  Must be positive.
     * @param matrix_hint       Flags describing special matrix structures.
     * @param attributes        Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
     *                          to create a normal object.
     * @return a new la_object_t object representing the matrix.
     */
    @Generated
    @CFunction
    public static native NSObject la_matrix_from_float_buffer(ConstFloatPtr buffer, @NUInt long matrix_rows,
            @NUInt long matrix_cols, @NUInt long matrix_row_stride, @NUInt long matrix_hint, @NUInt long attributes);

    /**
     * Create a matrix using data from a buffer of doubles.  Ownership of the buffer
     * remains in control of the caller.
     * <p>
     * This function creates an object representing a matrix whose entries are
     * copied out of the supplied buffer of doubles.  Negative or zero strides
     * are not supported by this function (but note that you can reverse the
     * rows or columns using the la_matrix_slice function defined below).
     * <p>
     * This routine assumes that the elements of the matrix are stored in the buffer
     * in row-major order.  If you need to work with data that is in column-major
     * order, you can do that as follows:
     * <p>
     * 1. Use this routine to create a matrix object, but pass the number of
     * columns in your matrix for the matrix_rows parameter and vice-versa.  For
     * the matrix_row_stride parameter, pass the column stride of your matrix.
     * <p>
     * 2. Make a new matrix transpose object from the object created in step 1.  The
     * resulting object represents the matrix that you want to work with.
     *
     * @param buffer            Pointer to double data providing the elements of the matrix.
     * @param matrix_rows       The number of rows in the matrix.
     * @param matrix_cols       The number of columns in the matrix.
     * @param matrix_row_stride The offset in the buffer (measured in doubles) between corresponding elements
     *                          in consecutive rows of the matrix.  Must be positive.
     * @param matrix_hint       Flags describing special matrix structures.
     * @param attributes        Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
     *                          to create a normal object.
     * @return a new la_object_t object representing the matrix.
     */
    @Generated
    @CFunction
    public static native NSObject la_matrix_from_double_buffer(ConstDoublePtr buffer, @NUInt long matrix_rows,
            @NUInt long matrix_cols, @NUInt long matrix_row_stride, @NUInt long matrix_hint, @NUInt long attributes);

    /**
     * Create a matrix using data from a buffer of floats.  Ownership of the buffer
     * is transferred from the caller to the returned object.
     * <p>
     * This function creates an object representing a matrix whose entries are
     * copied out of the supplied buffer of floats.  Negative or zero strides
     * are not supported by this function (but note that you can reverse the
     * rows or columns using the la_matrix_slice function defined below).
     * <p>
     * This routine assumes that the elements of the matrix are stored in the buffer
     * in row-major order.  If you need to work with data that is in column-major
     * order, you can do that as follows:
     * <p>
     * 1. Use this routine to create a matrix object, but pass the number of
     * columns in your matrix for the matrix_rows parameter and vice-versa.  For
     * the matrix_row_stride parameter, pass the column stride of your matrix.
     * <p>
     * 2. Make a new matrix transpose object from the object created in step 1.  The
     * resulting object represents the matrix that you want to work with.
     *
     * @param buffer            Pointer to float data providing the elements of the matrix.
     * @param matrix_rows       The number of rows in the matrix.
     * @param matrix_cols       The number of columns in the matrix.
     * @param matrix_row_stride The offset in the buffer (measured in floats) between corresponding elements
     *                          in consecutive rows of the matrix.  Must be positive.
     * @param matrix_hint       Flags describing special matrix structures.
     * @param deallocator       Callback to be used to deallocate the buffer when the returned matrix object
     *                          is destroyed.
     * @param attributes        Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
     *                          to create a normal object.
     * @return a new la_object_t object representing the matrix.
     */
    @Generated
    @CFunction
    public static native NSObject la_matrix_from_float_buffer_nocopy(FloatPtr buffer, @NUInt long matrix_rows,
            @NUInt long matrix_cols, @NUInt long matrix_row_stride, @NUInt long matrix_hint,
            @FunctionPtr(name = "call_la_matrix_from_float_buffer_nocopy") Function_la_matrix_from_float_buffer_nocopy deallocator,
            @NUInt long attributes);

    /**
     * Create a matrix using data from a buffer of doubles.  Ownership of the buffer
     * is transferred from the caller to the returned object.
     * <p>
     * This function creates an object representing a matrix whose entries are
     * copied out of the supplied buffer of doubles.  Negative or zero strides
     * are not supported by this function (but note that you can reverse
     * the rows or columns using the la_matrix_slice function defined below).
     * <p>
     * This routine assumes that the elements of the matrix are stored in the buffer
     * in row-major order.  If you need to work with data that is in column-major
     * order, you can do that as follows:
     * <p>
     * 1. Use this routine to create a matrix object, but pass the number of
     * columns in your matrix for the matrix_rows parameter and vice-versa.  For
     * the matrix_row_stride parameter, pass the column stride of your matrix.
     * <p>
     * 2. Make a new matrix transpose object from the object created in step 1.  The
     * resulting object represents the matrix that you want to work with.
     *
     * @param buffer            Pointer to double data providing the elements of the matrix.
     * @param matrix_rows       The number of rows in the matrix.
     * @param matrix_cols       The number of columns in the matrix.
     * @param matrix_row_stride The offset in the buffer (measured in doubles) between corresponding elements
     *                          in consecutive rows of the matrix.  Must be positive.
     * @param matrix_hint       Flags describing special matrix structures.
     * @param deallocator       Callback to be used to deallocate the buffer when the returned matrix object
     *                          is destroyed.
     * @param attributes        Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
     *                          to create a normal object.
     * @return a new la_object_t object representing the matrix.
     */
    @Generated
    @CFunction
    public static native NSObject la_matrix_from_double_buffer_nocopy(DoublePtr buffer, @NUInt long matrix_rows,
            @NUInt long matrix_cols, @NUInt long matrix_row_stride, @NUInt long matrix_hint,
            @FunctionPtr(name = "call_la_matrix_from_double_buffer_nocopy") Function_la_matrix_from_double_buffer_nocopy deallocator,
            @NUInt long attributes);

    /**
     * Stores the elements of a matrix to a buffer.
     * <p>
     * The buffer must be large enough to accomodate the matrix being stored.
     * Specifically, it must have sufficient space to hold
     * <p>
     * buffer_row_stride*(la_matrix_rows(matrix)-1) + la_matrix_cols(matrix)
     * <p>
     * float elements.
     * <p>
     * This function supports storing the contents of a vector as well as a matrix.
     * A vector of length n will be interpreted as a rows(matrix) x cols(matrix) by
     * this function.  If the object is a vector or matrix and does not have an error
     * status, its contents are stored to the buffer.  If it has an error status, NaNs
     * are stored to the buffer.
     * <p>
     * If the object is not a matrix or vector, nothing is written to the buffer and
     * LA_INVALID_PARAMETER_ERROR is returned.
     *
     * @param buffer            Pointer to the destination buffer.
     * @param buffer_row_stride Offset (measured in floats) between the destinations of corresponding elements
     *                          of consecutive rows of the matrix.  Must be positive.
     * @param matrix            The matrix to store.
     */
    @Generated
    @CFunction
    @NInt
    public static native long la_matrix_to_float_buffer(FloatPtr buffer, @NUInt long buffer_row_stride,
            NSObject matrix);

    /**
     * Stores the elements of a matrix to a buffer.
     * <p>
     * The buffer must be large enough to accomodate the matrix being stored.
     * Specifically, it must have sufficient space to hold
     * <p>
     * buffer_row_stride*(la_matrix_rows(matrix)-1) + la_matrix_cols(matrix)
     * <p>
     * double elements.
     * <p>
     * This function supports storing the contents of a vector as well as a matrix.
     * A vector of length n will be interpreted as a rows(matrix) x cols(matrix) by
     * this function.  If the object is a vector or matrix and does not have an error
     * status, its contents are stored to the buffer.  If it has an error status, NaNs
     * are stored to the buffer.
     * <p>
     * If the object is not a matrix or vector, nothing is written to the buffer and
     * LA_INVALID_PARAMETER_ERROR is returned.
     *
     * @param buffer            Pointer to the destination buffer.
     * @param buffer_row_stride Offset (measured in doubles) between the destinations of corresponding elements
     *                          of consecutive rows of the matrix.  Must be positive.
     * @param matrix            The matrix to store.
     */
    @Generated
    @CFunction
    @NInt
    public static native long la_matrix_to_double_buffer(DoublePtr buffer, @NUInt long buffer_row_stride,
            NSObject matrix);

    /**
     * Get the number of rows in a matrix.
     * <p>
     * If the argument has an error status, zero is returned.
     * If the argument is a vector, the number of rows may be 1 or length(vector)
     * depending on the orientation of the vector.
     * If the argument is a matrix, the number of rows is returned.
     * Otherwise, zero is returned.
     */
    @Generated
    @CFunction
    @NUInt
    public static native long la_matrix_rows(NSObject matrix);

    /**
     * Get the number of columns in a matrix.
     * <p>
     * If the argument has an error status, zero is returned.
     * If the argument is a vector, the number of columns may be 1 or length(vector)
     * depending on the orientation of the vector.
     * If the argument is a matrix, the number of columns is returned.
     * Otherwise, zero is returned.
     */
    @Generated
    @CFunction
    @NUInt
    public static native long la_matrix_cols(NSObject matrix);

    /**
     * Create a slice of a matrix.
     * <p>
     * The result object is the slice_rows x slice_cols matrix whose i,jth entry is:
     * <p>
     * matrix[matrix_first_row + i*matrix_row_stride,
     * matrix_first_col + j*matrix_col_stride]
     * <p>
     * Slices provide an efficient means to operate on tiles and strides.  These are
     * lightweight objects that reference the storage of the matrix from which they
     * originate.  In most cases, creating a slice does not require any allocation
     * beyond the object representing the slice, nor require copying.  In some
     * less common cases, a copy may be required.
     * <p>
     * This function supports slicing a vector (interpreted as
     * rows(matrix) x cols(matrix)) or a matrix.  If the object is not a matrix or
     * vector, the returned object will have status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * If the slice references indices that are less than zero or greater than or
     * equal to the dimensions of the matrix, LA_SLICE_OUT_OF_BOUNDS_ERROR is
     * returned.
     *
     * @param matrix            The matrix to be sliced.
     * @param matrix_first_row  The index of the row of the source matrix containing the first element of
     *                          new slice matrix.
     * @param matrix_first_col  The index of the column of the source matrix containing the first element
     *                          of the slice matrix.
     * @param matrix_row_stride The offset in the source matrix between rows that will be consecutive in
     *                          the slice matrix.
     * @param matrix_col_stride The offset in the source matrix between columns that will be consecutve in
     *                          the slice matrix.
     * @param slice_rows        The number of rows in the slice matrix.
     * @param slice_cols        The number of columns in the slice matrix.
     * @return A new matrix with size slice_rows x slice_cols whose elements are taken
     * from the source matrix.
     */
    @Generated
    @CFunction
    public static native NSObject la_matrix_slice(NSObject matrix, @NInt long matrix_first_row,
            @NInt long matrix_first_col, @NInt long matrix_row_stride, @NInt long matrix_col_stride,
            @NUInt long slice_rows, @NUInt long slice_cols);

    @Generated
    @CFunction
    public static native NSObject la_identity_matrix(@NUInt long matrix_size, int scalar_type, @NUInt long attributes);

    /**
     * Create a matrix with a specified diagonal provided by a vector, and zeros in
     * all the other entries.
     * <p>
     * Creates a new matrix with entries on the specified diagonal taken from the
     * vector argument, and zeros in the other entries.  The matrix is square, and
     * has size length(vector) + abs(matrix_diagonal).
     * <p>
     * If matrix_diagonal is zero, the main diagonal is set.  If matrix_diagonal is
     * +1, the first superdiagonal is set.  If matrix_diagonal is -2, the second
     * subdiagonal is set.
     * <p>
     * The diagonal may be specified by a vector or by a matrix that has only one
     * row or only one column.  If the provided object is not a vector or matrix,
     * or is a matrix with both dimensions larger than one, the returned object
     * will have status LA_INVALID_PARAMETER_ERROR.
     *
     * @param vector          Vector providing the data for the non-zero diagonal.
     * @param matrix_diagonal The index of the non-zero diagonal.
     */
    @Generated
    @CFunction
    public static native NSObject la_diagonal_matrix_from_vector(NSObject vector, @NInt long matrix_diagonal);

    /**
     * Creates a vector from the specified row of the matrix.
     * <p>
     * Creates a vector from the specified row of the matrix.  If the value for
     * matrix_row is less than zero or greater than rows(matrix)-1,
     * LA_INVALID_PARAMETER_ERROR is returned.
     * <p>
     * If matrix is a splat, LA_INVALID_PARAMETER_ERROR is returned.
     * <p>
     * Always returns a 1 x vector_length vector.
     *
     * @param matrix      Matrix from which to create the row vector.
     * @param matrix_row. The zero-based index of the row to create the vector from.
     * @return The resulting vector is a 1 x cols(matrix) vector.
     */
    @Generated
    @CFunction
    public static native NSObject la_vector_from_matrix_row(NSObject matrix, @NUInt long matrix_row);

    /**
     * Creates a vector from the specified column of the matrix.
     * <p>
     * Creates a vector from the specified column of the matrix.  If the value for
     * matrix_col is less than zero or greater than cols(matrix)-1,
     * LA_INVALID_PARAMETER_ERROR is returned.
     * <p>
     * If matrix is a splat, LA_INVALID_PARAMETER_ERROR is returned.
     * <p>
     * Always returns a vector_length x 1 vector.
     *
     * @param matrix      Matrix from which to create the column vector.
     * @param matrix_col. The zero-based index of the column to create the vector from.
     * @return The resulting vector is a rows(matrix) x 1 vector.
     */
    @Generated
    @CFunction
    public static native NSObject la_vector_from_matrix_col(NSObject matrix, @NUInt long matrix_col);

    /**
     * Creates a vector from the specified diagonal of the matrix.
     * <p>
     * Creates a new vector with entries on the specified diagonal taken from the
     * vector argument, and zeros in the other entries.  The matrix is square, and
     * has size length(vector) + abs(matrix_diagonal).
     * <p>
     * If matrix_diagonal is zero, the main diagonal is set.  If matrix_diagonal is
     * +1, the first superdiagonal is set.  If matrix_diagonal is -2, the second
     * subdiagonal is set.
     * <p>
     * Creates a vector from the specified diagonal of the matrix.  If the value for
     * matrix_diagonal is less than zero and abs(matrix_diagonal) > rows(matrix)-1,
     * or if matrix_diagonal is greater than zero and matrix_diagonal >
     * cols(matrix)-1, LA_INVALID_PARAMETER_ERROR is returned.
     * <p>
     * If matrix is a splat, LA_INVALID_PARAMETER_ERROR is returned.
     * <p>
     * Always returns a vector_length x 1 vector.
     *
     * @param matrix           Matrix from which to create the vector.
     * @param matrix_diagonal. The index of the diagonal to create the vector from.
     * @return The resulting vector is a length x 1 vector where length is
     * min(rows(matrix),cols(matrix)-abs(matrix_diagonal)
     */
    @Generated
    @CFunction
    public static native NSObject la_vector_from_matrix_diagonal(NSObject matrix, @NInt long matrix_diagonal);

    /**
     * Stores the elements of a vector to a buffer.
     * <p>
     * The buffer must be large enough to accomodate the vector being stored.
     * Specifically, it must have have sufficient space to hold
     * <p>
     * buffer_stride*(la_vector_length(vector)-1) + 1
     * <p>
     * float elements.  Real usage in the most common case (stride = 1) will
     * look roughly like this:
     *
     * <pre>
     * @textblock
     * la_count_t length = la_vector_length(vector);
     * if (!length) {
     * 	// an error occured.
     * }
     * float *buffer = malloc(length * sizeof buffer[0]);
     * la_vector_to_float_buffer(buffer, 1, vector);
     * @/textblock
     * </pre>
     * <p>
     * This function supports storing the contents of a vector, or a matrix that
     * has only one row or only one column.  If the object satisfies those
     * requirements, and it does not have an error status, its contents are stored
     * to the buffer.  If it has an error status, NaNs are stored to the buffer.
     * <p>
     * If the object is not a matrix or vector, or if it is a matrix with both
     * dimensions larger than one, nothing is written to the buffer and
     * LA_INVALID_PARAMETER_ERROR is returned.
     *
     * @param buffer        Pointer to the destination buffer.
     * @param buffer_stride Offset (in floats) between the destinations of consecutive vector elements
     *                      in the buffer.  Negative strides are not supported (you can get the same
     *                      effect by reversing the vector before calling this function).
     * @param vector        The vector to store.
     */
    @Generated
    @CFunction
    @NInt
    public static native long la_vector_to_float_buffer(FloatPtr buffer, @NInt long buffer_stride, NSObject vector);

    /**
     * Stores the elements of a vector to a buffer.
     * <p>
     * The buffer must be large enough to accomodate the vector being stored.
     * Specifically, it must have have sufficient space to hold
     * <p>
     * buffer_stride*(la_vector_length(vector)-1) + 1
     * <p>
     * double elements.  Real usage in the most common case (stride = 1) will
     * look roughly like this:
     *
     * <pre>
     * @textblock
     * la_count_t length = la_vector_length(vector);
     * if (!length) {
     * 	// an error occured.
     * }
     * double *buffer = malloc(length * sizeof buffer[0]);
     * la_vector_to_double_buffer(buffer, 1, vector);
     * @/textblock
     * </pre>
     * <p>
     * This function supports storing the contents of a vector, or a matrix that
     * has only one row or only one column.  If the object satisfies those
     * requirements, and it does not have an error status, its contents are stored
     * to the buffer.  If it has an error status, NaNs are stored to the buffer.
     * <p>
     * If the object is not a matrix or vector, or if it is a matrix with both
     * dimensions larger than one, nothing is written to the buffer and
     * LA_INVALID_PARAMETER_ERROR is returned.
     *
     * @param buffer        Pointer to the destination buffer.
     * @param buffer_stride Offset (in doubles) between the destinations of consecutive vector elements
     *                      in the buffer.  Negative strides are not supported (you can get the same
     *                      effect by reversing the vector before calling this function).
     * @param vector        The vector to store.
     * @return If vector is a valid vector object, its status is returned.  Otherwise
     * the return value is LA_INVALID_PARAMETER_ERROR.
     */
    @Generated
    @CFunction
    @NInt
    public static native long la_vector_to_double_buffer(DoublePtr buffer, @NInt long buffer_stride, NSObject vector);

    /**
     * Get the length of a vector.
     * <p>
     * If the argument has an error status, zero is returned.
     * If the argument is a vector, its length is returned.
     * If the argument is a matrix with only one row or only one column, the other
     * dimension is returned.
     * Otherwise, zero is returned.
     */
    @Generated
    @CFunction
    @NUInt
    public static native long la_vector_length(NSObject vector);

    /**
     * Create a slice of a vector.
     * <p>
     * The result object is the vector:
     * <p>
     * [ vector[vector_first], vector[vector_first+vector_stride], ...
     * ... , vector[vector_first + (slice_length-1)*vector_stride] ]
     * <p>
     * Slices provide an efficient means to operate on subvectors and strides.
     * These are lightweight objects that reference the storage of the vector from
     * which they originate.  Creating a vector slice does not require any allocation
     * beyond the object representing the slice, nor does it require copying.
     * <p>
     * This function supports slicing a vector, or a matrix that has only one row
     * or only one column.  If the object is not a matrix or vector, or if it is
     * a matrix with both dimensions larger than one, the returned object will have
     * status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * If the slice references indices that are less than zero or greater than or
     * equal to the length of the vector, LA_SLICE_OUT_OF_BOUNDS_ERROR is returned.
     * <p>
     * Always return a vector with the same orientation as the input.  If input is
     * vector_length x 1, output is vector_length x 1 and if input is
     * 1 x vector_length, output is 1 x vector_length.
     *
     * @param vector        The vector to be sliced.
     * @param vector_first  The index of the source vector element that will become the first element
     *                      of the new slice vector.
     * @param vector_stride The offset in the source vector between elements that will be consecutive in
     *                      the new slice vector.
     * @param slice_length  The length of the resulting slice vector.
     * @return A new vector with length slice_length whose elements are taken from vector.
     */
    @Generated
    @CFunction
    public static native NSObject la_vector_slice(NSObject vector, @NInt long vector_first, @NInt long vector_stride,
            @NUInt long slice_length);

    /**
     * Splat objects are a feature that is relatively unique to the LinearAlgebra
     * library.
     * <p>
     * A splat object represents a matrix or vector whose entries are all equal.
     * It may be used in the place of a matrix or vector in many computational
     * operations in the library.
     * <p>
     * Splat objects are effectively dimensionless matrices.  Computational
     * operations that accept them interpret them as having dimensions necessary
     * to be compatibile with the other operand.  Because the dimensions of a
     * splat are inferred from the other operands, a single operation cannot
     * have multiple splat operands.
     * <p>
     * A partial list of operations accepting splat operands, and the rules for the
     * inferred size:
     * <p>
     * Operation                           Inferred Dimensions
     * sum(A,splat)                        (rows(A), cols(A))
     * sum(splat,A)                        (rows(A), cols(A))
     * difference(A,splat)                 (rows(A), cols(A))
     * difference(splat,A)                 (rows(A), cols(A))
     * elementwise_product(A,splat)        (rows(A), cols(A))
     * elementwise_product(splat,A)        (rows(A), cols(A))
     * inner_product(A,splat)              (length(A), 1)
     * inner_product(splat,A)              (1, length(A))
     * matrix_product(A,splat)             (cols(A), 1)
     * matrix_product(splat,A)             (1, rows(A))
     */
    @Generated
    @CFunction
    public static native NSObject la_splat_from_float(float scalar_value, @NUInt long attributes);

    @Generated
    @CFunction
    public static native NSObject la_splat_from_double(double scalar_value, @NUInt long attributes);

    @Generated
    @CFunction
    public static native NSObject la_splat_from_vector_element(NSObject vector, @NInt long vector_index);

    @Generated
    @CFunction
    public static native NSObject la_splat_from_matrix_element(NSObject matrix, @NInt long matrix_row,
            @NInt long matrix_col);

    /**
     * It is sometimes useful to be able to just generate a matrix or vector with
     * fixed dimensions from a splat object, either because the operation you want
     * to perform doesn't infer the same dimensions as you would like to use, or
     * if the operation you want to perform doesn't support inferring dimensions
     * at all.  For this purpose, the following functions are provided.
     * <p>
     * The vector returned from la_vector_from_splat is always vector_length x 1.
     */
    @Generated
    @CFunction
    public static native NSObject la_vector_from_splat(NSObject splat, @NUInt long simd_length);

    @Generated
    @CFunction
    public static native NSObject la_matrix_from_splat(NSObject splat, @NUInt long matrix_rows,
            @NUInt long matrix_cols);

    /**
     * Transpose a vector or matrix.
     * <p>
     * Returns a matrix that is the transpose of the source vector or matrix.  If the
     * source object is not a vector or matrix, the returned object will have status
     * LA_INVALID_PARAMETER_ERROR.
     */
    @Generated
    @CFunction
    public static native NSObject la_transpose(NSObject matrix);

    /**
     * Multiply a matrix or vector by a scalar given by a float.
     * <p>
     * Returns a matrix whose entries are the product of the scalar and the
     * corresponding element of the source matrix.  If the source object is not
     * a vector or matrix, the returned object will have status
     * LA_INVALID_PARAMETER_ERROR.
     * <p>
     * If the scalar type of matrix is not float LA_PRECISION_MISMATCH_ERROR is
     * returned.
     */
    @Generated
    @CFunction
    public static native NSObject la_scale_with_float(NSObject matrix, float scalar);

    /**
     * Multiply a matrix or vector by a scalar given by a double.
     * <p>
     * Returns a matrix whose entries are the product of the scalar and the
     * corresponding element of the source matrix.  If the source object is not
     * a vector or matrix, the returned object will have status
     * LA_INVALID_PARAMETER_ERROR.
     * <p>
     * If the scalar type of matrix is not double LA_PRECISION_MISMATCH_ERROR is
     * returned.
     */
    @Generated
    @CFunction
    public static native NSObject la_scale_with_double(NSObject matrix, double scalar);

    /**
     * Compute the element-wise sum of two vectors or matrices.
     * <p>
     * If either source operand is not a vector or matrix or splat, or if both
     * operands are splats, the result has status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * The two operands must have the same dimensions.  If they do not, the result
     * will have status LA_DIMENSION_MISMATCH_ERROR.  For simplicity, a vector
     * of length n, a 1xn matrix, and an nx1 matrix are all treated as having the
     * same dimensions.  If 1xn and nx1 or nx1 and 1xn vectors are passed, an nx1
     * vector will be created, otherwise orientation matches input.
     * <p>
     * The result has the same dimensions as the operands, and each element in
     * the result is the sum of the corresponding elements in the source operands.
     */
    @Generated
    @CFunction
    public static native NSObject la_sum(NSObject obj_left, NSObject obj_right);

    /**
     * Compute the element-wise difference of two vectors or matrices.
     * <p>
     * If either source operand is not a vector or matrix or splat, or if both
     * operands are splats, the result has status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * The two operands must have the same dimensions.  If they do not, the result
     * will have status LA_DIMENSION_MISMATCH_ERROR.  For simplicity, a vector
     * of length n, a 1xn matrix, and an nx1 matrix are all treated as having the
     * same dimensions.  If 1xn and nx1 or nx1 and 1xn vectors are passed, an nx1
     * vector will be created, otherwise orientation matches input.
     * <p>
     * The result has the same dimensions as the operands, and each element in
     * the result is given by subtracting the corresponding element of obj_right
     * from the corresponding element of obj_left.
     */
    @Generated
    @CFunction
    public static native NSObject la_difference(NSObject obj_left, NSObject obj_right);

    /**
     * Compute the element-wise product of two vectors or matrices.
     * <p>
     * If either source operand is not a vector or matrix or splat, or if both
     * operands are splats, the result has status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * The two operands must have the same dimensions.  If they do not, the result
     * will have status LA_DIMENSION_MISMATCH_ERROR.  For simplicity, a vector
     * of length n, a 1xn matrix, and an nx1 matrix are all treated as having the
     * same dimensions.  If 1xn and nx1 or nx1 and 1xn vectors are passed, an nx1
     * vector will be created, otherwise orientation matches input.
     * <p>
     * The result has the same dimensions as the operands, and each element in
     * the result is the product of the corresponding elements in the source operands.
     */
    @Generated
    @CFunction
    public static native NSObject la_elementwise_product(NSObject obj_left, NSObject obj_right);

    /**
     * Compute the inner product of two vectors.
     * <p>
     * If either operand is a matrix that is not 1xn or nx1, the result has the
     * status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * If either operand is not a vector or matrix or splat, or if both operands
     * are splats, the result has the status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * If the lengths of the two operands do not match, the result has the status
     * LA_DIMENSION_MISMATCH_ERROR.
     * <p>
     * Otherwise the result is a 1x1 matrix containing the inner product:
     * <p>
     * sum_{i=0...length} vector_left[i] * vector_right[i]
     */
    @Generated
    @CFunction
    public static native NSObject la_inner_product(NSObject vector_left, NSObject vector_right);

    /**
     * Compute the outer product of two vectors.
     * <p>
     * Splats are not supported by this function.  If either operand
     * is a splat, the result has status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * If either operand is a matrix that is not 1xn or nx1, the result has the
     * status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * If either operand is not a vector or matrix, the result has the status
     * LA_INVALID_PARAMETER_ERROR.
     * <p>
     * Otherwise the result is a matrix containg the outer product.  It has
     * length(vector_left) rows and length(vector_right) columns.  The i,jth
     * element of the matrix is vector_left[i] * vector_right[j].
     */
    @Generated
    @CFunction
    public static native NSObject la_outer_product(NSObject vector_left, NSObject vector_right);

    /**
     * Compute a matrix product.
     * <p>
     * Left splat operands are treated as 1 x rows(matrix_right) vectors and right
     * splat operands are treated as cols(matrix_left) x 1 vectors.
     * <p>
     * For convenience, in certain situations vector operands may be implicitly
     * transposed.  Specifically,
     * <p>
     * If cols(matrix_left) == rows(matrix_right)
     * rows(matrix_left) x cols(matrix_right) = matrix_left * matrix_right
     * Else if cols(matrix_left) == 1 and rows(matrix_left) == rows(matrix_right)
     * 1 x cols(matrix_right) = transpose(matrix_left) * matrix_right
     * Else if rows(matrix_right) == 1 and cols(matrix_left) == cols(matrix_right)
     * rows(matrix_left) x 1 = matrix_left * transpose(matrix_right)
     * Else
     * result has the status LA_DIMENSION_MISMATCH_ERROR.
     * <p>
     * If either operand is not a vector or matrix or splat, or if both operands
     * are splats, the result has the status LA_INVALID_PARAMETER_ERROR.
     * <p>
     * Otherwise the result is a matrix with 1 row if matrix_left is vector or splat
     * and rows(matrix_left) otherwise, and 1 column if matrix_right is vector or
     * splat and cols(matrix_right) otherwise.
     * <p>
     * If cols(matrix_left) == rows(matrix_right), the i,jth element of the matrix is:
     * sum_{k=0...cols(matrix_left)} matrix_left[i,k] * matrix_right[k,j]
     * If cols(matrix_left) == 1 and rows(matrix_left) == rows(matrix_right), the
     * 0,jth element of matrix is:
     * sum_{k=0...rows(matrix_right)} matrix_left[k,0] * matrix_right[k,j]
     * If rows(matrix_right) == 1 and cols(matrix_left) == cols(matrix_right), the
     * i,0th element of matrix is:
     * sum_{k=0...cols(matrix_left)} matrix_left[i,k] * matrix_right[0,k]
     */
    @Generated
    @CFunction
    public static native NSObject la_matrix_product(NSObject matrix_left, NSObject matrix_right);

    /**
     * Solves a system of linear equations
     * <p>
     * If matrix_system represents a matrix A, and obj_rhs represents a vector
     * B, la_solve returns a vector X representing a solution to the equation
     * AX = B, if such a solution exists.  If obj_rhs represents a matrix, then
     * la_solve returns a matrix representing the solution of the same equation.
     * <p>
     * There are several different cases, and different algorithms are chosen
     * depending on the specifics:
     * <p>
     * If the matrix has a special structure that allows us to solve the system
     * without factoring (e.g. if the matrix is diagonal or triangular), we may
     * use that structure to compute the solution.
     * <p>
     * If the matrix is symmetric and all diagonal entries are positive, or if we
     * know, either via a hint parameter or by how earlier computations were
     * structured, that the matrix is positive definite, we attempt a Cholesky
     * factorization.  If this succeeds, it is used to compute the solution via
     * forward- and back-substitution.
     * <p>
     * If the matrix is square, we try to perform Gaussian elimination to construct
     * a triangular factorization with pivoting.  If this factorization succeeds,
     * we use it to solve the system.  If it fails, the returned object has the
     * error status LA_SINGULAR_ERROR.
     * <p>
     * If the matrix is not square, we return a least-squares solution computed by
     * performing a QR factorization of the matrix.
     * <p>
     * If the number of rows of the matrix does not match the number of rows of
     * the right hand side object, the returned object has status
     * LA_DIMENSION_MISMATCH_ERROR.
     * <p>
     * If the object describing the matrix is not a matrix, or if the right hand
     * side is not a matrix or vector, the returned object has status
     * LA_INVALID_PARAMETER_ERROR.
     * <p>
     * If you want to solve the system XA = B, which is less common (but still
     * occurs fairly frequently), you may accomplish this by transposing A and B,
     * solving, and then transposing the result of the solve.
     *
     * @param matrix_system A matrix describing the left-hand side of the system.
     * @param obj_rhs       A vector or matrix describing one or more right-hand sides for which the
     *                      equations are to be solved.
     * @return A matrix of the solution(s) of the system of equations.
     */
    @Generated
    @CFunction
    public static native NSObject la_solve(NSObject matrix_system, NSObject obj_rhs);

    /**
     * Compute a norm of a vector or matrix.
     * <p>
     * "vector" refers to the fact that this function computes the norm of its
     * argument considered as a vector, and not an operator norm.  The actual
     * argument may be either a vector or a matrix.  If it is not a vector or
     * matrix, or if the vector_norm parameter is not a supported value, NAN is
     * returned.
     */
    @Generated
    @CFunction
    public static native float la_norm_as_float(NSObject vector, @NUInt long vector_norm);

    @Generated
    @CFunction
    public static native double la_norm_as_double(NSObject vector, @NUInt long vector_norm);

    /**
     * "Normalizes" a vector or matrix.
     * <p>
     * The returned object has the same direction as the first operand, and has
     * norm 1 in the specified vector norm.  If the input vector is zero, it cannot
     * be meaningfully normalized and the returned object is also zero.  If the
     * parameter vector is not a vector or matrix, or if the vector_norm parameter
     * is not a supported value, the returned object has status
     * LA_INVALID_PARAMETER_ERROR.
     */
    @Generated
    @CFunction
    public static native NSObject la_normalized_vector(NSObject vector, @NUInt long vector_norm);

    /**
     * Compute the inner product of sparse vector x with dense vector y.
     * <p>
     * Compute the inner product of sparse vector x with dense vector y.  Returns zero
     * if nz is less than or equal to zero.
     *
     * @param nz   The number of nonzero entries in the sparse vector x.
     * @param x    Pointer to the dense storage for the values of the sparse vector x.  The
     *             corresponding entry in indx holds the index of the value.  Contains nz values.
     * @param indx Pointer to the dense storage for the index values of the sparse vector x.  The
     *             corresponding entry in x holds the values of the vector.  Contains nz values.
     *             <p>
     *             Indices are always assumed to be stored in ascending order. Additionally,
     *             indices are assumed to be unique.  Undefined behavior if either of these
     *             assumptions are not met.
     *             <p>
     *             All indices are 0 based (the first element of a pointer is ptr[0]).
     * @param y    Pointer to the dense vector y.  Accessed as y[indx[0..nz-1]*incy], so dimension
     *             must be compatible with largest index value in indx.  Behavior undefined if
     *             this is not met.  Negative strides are supported.  Note, unlike dense BLAS
     *             routines, the pointer points to the last element when stride is negative.
     * @param incy Increment between valid values in the dense vector y.  Negative strides are
     *             supported.
     * @return On exit the result of the inner product is returned.
     */
    @Generated
    @CFunction
    public static native float sparse_inner_product_dense_float(long nz, ConstFloatPtr x, ConstLongPtr indx,
            ConstFloatPtr y, long incy);

    @Generated
    @CFunction
    public static native double sparse_inner_product_dense_double(long nz, ConstDoublePtr x, ConstLongPtr indx,
            ConstDoublePtr y, long incy);

    /**
     * Compute the inner product of sparse vector x with sparse vector y.
     * <p>
     * Compute the inner product of sparse vector x with sparse vector y.  Returns
     * zero if nzx or nzy is less than or equal to zero.
     *
     * @param nzx  The number of nonzero entries in the sparse vector x.
     * @param nzy  The number of nonzero entries in the sparse vector y.
     * @param x    Pointer to the dense storage for the values of the sparse vector x.  The
     *             corresponding entry in indx holds the index of the value.  Contains nzx values.
     * @param indx Pointer to the dense storage for the index values of the sparse vector x.  The
     *             corresponding entry in x holds the values of the vector.  Contains nzx values.
     *             <p>
     *             Indices are always assumed to be stored in ascending order. Additionally,
     *             indices are assumed to be unique.  Undefined behavior if either of these
     *             assumptions are not met.
     *             <p>
     *             All indices are 0 based (the first element of a pointer is ptr[0]).
     * @param y    Pointer to the dense storage for the values of the sparse vector y.  The
     *             corresponding entry in indy holds the index of the value.  Contains nzy values.
     * @param indy Pointer to the dense storage for the index values of the sparse vector y.  The
     *             corresponding entry in y holds the values of the vector.  Contains nzy values.
     *             <p>
     *             Indices are always assumed to be stored in ascending order. Additionally,
     *             indices are assumed to be unique.  Undefined behavior if either of these
     *             assumptions are not met.
     *             <p>
     *             All indices are 0 based (the first element of a pointer is ptr[0]).
     * @return On exit the result of the inner product is returned.
     */
    @Generated
    @CFunction
    public static native float sparse_inner_product_sparse_float(long nzx, long nzy, ConstFloatPtr x, ConstLongPtr indx,
            ConstFloatPtr y, ConstLongPtr indy);

    @Generated
    @CFunction
    public static native double sparse_inner_product_sparse_double(long nzx, long nzy, ConstDoublePtr x,
            ConstLongPtr indx, ConstDoublePtr y, ConstLongPtr indy);

    /**
     * Scales the sparse vector x by alpha and adds the result to the dense vector y.
     * <p>
     * y = alpha * x + y
     * <p>
     * Scales the sparse vector x by alpha and adds the result to the dense vector y.
     * If alpha or nz is zero, y is unchanged.
     * <p>
     * If the desired operation is y = alpha * x, then an efficient option is to
     * create the y buffer of zeros as y = calloc(sizeof(..)*ySize) and then perform
     * the operation with the zero filled y.
     *
     * @param nz    The number of nonzero entries in the sparse vector x.
     * @param alpha Scalar multiplier of x.
     * @param x     Pointer to the dense storage for the values of the sparse vector x.  The
     *              corresponding entry in indx holds the index of the value.  Contains nz values.
     * @param indx  Pointer to the dense storage for the index values of the sparse vector x.  The
     *              corresponding entry in x holds the values of the vector.  Contains nz values.
     *              <p>
     *              Indices are always assumed to be stored in ascending order. Additionally,
     *              indices are assumed to be unique.  Undefined behavior if either of these
     *              assumptions are not met.
     *              <p>
     *              All indices are 0 based (the first element of a pointer is ptr[0]).
     * @param y     Pointer to the dense vector y.  Accessed as y[indx[0..nz-1]*incy], so dimension
     *              must be compatible with largest index value in indx.  Behavior undefined if
     *              this is not met.  Negative strides are supported.  Note, unlike dense BLAS
     *              routines, the pointer points to the last element when stride is negative.
     * @param incy  Increment between valid values in the dense vector y.  Negative strides are
     *              supported.
     * @return On exit y has been updated as y = alpha * x + y. If nz is less than or
     * equal to zero or alpha is equal to zero, y is unchanged.
     */
    @Generated
    @CFunction
    public static native void sparse_vector_add_with_scale_dense_float(long nz, float alpha, ConstFloatPtr x,
            ConstLongPtr indx, FloatPtr y, long incy);

    @Generated
    @CFunction
    public static native void sparse_vector_add_with_scale_dense_double(long nz, double alpha, ConstDoublePtr x,
            ConstLongPtr indx, DoublePtr y, long incy);

    /**
     * Compute the specified norm of the sparse vector x.
     * <p>
     * Compute the specified norm of the sparse vector x.  Specify one of:
     * 1) SPARSE_NORM_ONE : sum over i ( | x[i] | )
     * 2) SPARSE_NORM_TWO : sqrt( sum over i (x[i])^2 )
     * 3) SPARSE_NORM_INF : max over i ( | x[i] | )
     * 4) SPARSE_NORM_R1  : Not supported, undefined.
     * <p>
     * If norm is not one of the enumerated norm types, the default value is
     * SPARSE_NORM_INF.
     *
     * @param nz   The number of nonzero values in the sparse vector x.
     * @param x    Pointer to the dense storage for the values of the sparse vector x.  The
     *             corresponding entry in indx holds the index of the value.  Contains nz values.
     * @param indx Pointer to the dense storage for the index values of the sparse vector x.  The
     *             corresponding entry in x holds the values of the vector.  Contains nz values.
     *             <p>
     *             Indices are always assumed to be stored in ascending order. Additionally,
     *             indices are assumed to be unique.  Undefined behavior if either of these
     *             assumptions are not met.
     *             <p>
     *             All indices are 0 based (the first element of a pointer is ptr[0]).
     * @param norm Specify the norm to be computed.  Must be one of SPARSE_NORM_ONE, SPARSE_NORM_TWO,
     *             or SPARSE_NORM_INF.  See discussion for further details.
     * @return Upon success, return the requested norm.
     */
    @Generated
    @CFunction
    public static native float sparse_vector_norm_float(long nz, ConstFloatPtr x, ConstLongPtr indx, int norm);

    @Generated
    @CFunction
    public static native double sparse_vector_norm_double(long nz, ConstDoublePtr x, ConstLongPtr indx, int norm);

    /**
     * Multiplies the dense vector x by the sparse matrix A and adds the result to
     * the dense vector y.
     * <p>
     * y = alpha * op(A) * x + y; where op(A) is either A or the transpose of A
     * <p>
     * Multiplies the dense vector x by the sparse matrix A and adds the result to
     * the dense vector y (y = alpha * op(A) * x + y, where op(A) is either A
     * or the transpose of A).
     * <p>
     * If the desired operation is y = A * x, then an efficient option is to create
     * the y buffer of zeros as y = calloc(sizeof(..)*ySize) and then perform
     * the operation with the zero filled y.
     *
     * @param transa Specifies whether to perform the operation with A or the transpose of A.
     *               Must be one of CblasNoTrans or CblasTrans.
     * @param alpha  Scalar multiplier of A.
     * @param A      The sparse matrix.
     * @param x      Pointer to the dense vector x. The dimension must be the number of columns of
     *               the matrix A when transa is no transpose or the number of rows of the matrix A
     *               when transa is transpose.  Behavior undefined if this is not met.  Negative
     *               strides are supported.  Note, unlike dense BLAS routines, the pointer points to
     *               the last element when stride is negative.
     * @param incx   Increment between valid values in the dense vector x. Negative strides are
     *               supported.
     * @param y      Pointer to the dense vector y. The dimension must be the number of rows of
     *               the matrix A when transa is no transpose or the number of columns of the matrix
     *               A when transa is transpose.  Behavior undefined if this is not met.  Negative
     *               strides are supported.  Note, unlike dense BLAS routines, the pointer points to
     *               the last element when stride is negative.
     * @param incy   Increment between valid values in the dense vector y.  Negative strides are
     *               supported.
     * @return On success return SPARSE_SUCCESS and y has been updated with result of the
     * operation.  Will return SPARSE_ILLEGAL_PARAMETER if transa is invalid and y will
     * be unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_matrix_vector_product_dense_float(int transa, float alpha, sparse_matrix_float A,
            ConstFloatPtr x, long incx, FloatPtr y, long incy);

    @Generated
    @CFunction
    public static native int sparse_matrix_vector_product_dense_double(int transa, double alpha, sparse_matrix_double A,
            ConstDoublePtr x, long incx, DoublePtr y, long incy);

    /**
     * Solve the system of equations x = alpha * T^{-1} * x for x where x is a dense
     * vector and T is a triangular sparse matrix.
     * <p>
     * Solve the system of equations x = alpha * T^{-1} * x for x where x is a dense
     * vector and T is a triangular sparse matrix.  The matrix T must be an upper or
     * lower triangular matrix.
     *
     * @param transt Specifies whether to perform the operation with T or the transpose of T.
     *               Must be one of CblasNoTrans or CblasTrans.
     * @param alpha  Scalar multiplier of T.
     * @param T      The sparse triangular matrix.  Must be upper or lower triangular matrix.
     *               Will return SPARSE_ILLEGAL_PARAMETER if not a triangular matrix.
     * @param x      Pointer to the dense vector x. The dimension must match the dimension of the
     *               triangular matrix T. Behavior undefined if this is not met.  Negative
     *               strides are supported.  Note, unlike dense BLAS routines, the pointer points to
     *               the last element when stride is negative.  On exit holds the solution to the
     *               system of equations.
     * @param incx   Increment between valid values in the dense vector x. Negative strides are
     *               supported.
     * @return On success, SPARSE_SUCCESS is returned and x has been updated with result of the
     * operation.  Will return SPARSE_ILLEGAL_PARAMETER if transt is invalid or if the
     * matrix T is not triangular and x will be unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_vector_triangular_solve_dense_float(int transt, float alpha, sparse_matrix_float T,
            FloatPtr x, long incx);

    @Generated
    @CFunction
    public static native int sparse_vector_triangular_solve_dense_double(int transt, double alpha,
            sparse_matrix_double T, DoublePtr x, long incx);

    /**
     * Compute the outer product of the dense vector x and the sparse vector y and
     * return a new sparse matrix in the uninitialized pointer sparse matrix pointer
     * C.  C = alpha * x * y'
     * <p>
     * Compute the outer product of the dense vector x and the sparse vector y and
     * return a new sparse matrix in the uninitialized pointer sparse matrix pointer
     * C.  C = alpha * x * y'.  Caller responsible for calling sparse_matrix_destroy on
     * the returned matrix.
     * <p>
     * The matrix object returned on success is a point wise based sparse matrix.
     *
     * @param M     The number of rows of x and the resulting matrix.
     * @param N     The number of columns of the resulting matrix.  The number of nonzero values
     *              must be less than or equal to N.
     * @param nz    The number of nonzero values in the sparse vector y.  Must be less than or
     *              equal to N.
     * @param alpha Scalar multiplier of x.
     * @param x     Pointer to the dense vector x.  Must be M number of elements.  Negative strides
     *              are supported.  Note, unlike dense BLAS routines, the pointer points to the
     *              last element when stride is negative.
     * @param incx  Increment between valid values in the dense vector x.  Negative strides are
     *              supported.
     * @param y     Pointer to the dense storage for the values of the sparse vector y.  The
     *              corresponding entry in indy holds the index of the value.  Contains nz values.
     * @param indy  Pointer to the dense storage for the index values of the sparse vector y.  The
     *              corresponding entry in y holds the values of the vector.  Contains nz values.
     *              <p>
     *              Indices are always assumed to be stored in ascending order. Additionally,
     *              indices are assumed to be unique.  Undefined behavior if either of these
     *              assumptions are not met.
     *              <p>
     *              All indices are 0 based (the first element of a pointer is ptr[0]).
     * @param C     Pointer to an uninitialized sparse matrix object.  On success a newly allocated
     *              sparse matrix object is returned in this pointer.  On error, this set to NULL.
     *              Caller is responsible for calling sparse_matrix_destroy on this matrix object.
     * @return On success SPARSE_SUCCESS is returned an C is valid matrix object.  The caller is
     * responsible for cleaning up the sparse matrix object with sparse_matrix_destroy.
     * Will return SPARSE_ILLEGAL_PARAMETER if nz > N, and C will be unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_outer_product_dense_float(long M, long N, long nz, float alpha, ConstFloatPtr x,
            long incx, ConstFloatPtr y, ConstLongPtr indy, Ptr<sparse_matrix_float> C);

    @Generated
    @CFunction
    public static native int sparse_outer_product_dense_double(long M, long N, long nz, double alpha, ConstDoublePtr x,
            long incx, ConstDoublePtr y, ConstLongPtr indy, Ptr<sparse_matrix_double> C);

    /**
     * Permute the rows of the sparse matrix A based on the provided permutation
     * array.
     * <p>
     * Permute the rows of the sparse matrix A based on the provided permutation
     * array.  For each row in A, swap rows as:
     * <p>
     * tmp[:] = A[i,:];
     * A[i,:] = A[perm[i],:];
     * A[perm[i],:] = tmp[:];
     *
     * @param A    The sparse matrix.
     * @param perm The permutation array.  Holds number of rows in A values indicating the
     *             permutation of the matrix.  The indices in perm are expected to be 0 based
     *             (first element of pointer is ptr[0]).  The indices in perm are expected to
     *             be within bounds of the matrix.  Undefined behavior if not met.
     * @return On successful return, A has been permuted and SPARSE_SUCCESS is returned.
     */
    @Generated
    @CFunction
    public static native int sparse_permute_rows_float(sparse_matrix_float A, ConstLongPtr perm);

    @Generated
    @CFunction
    public static native int sparse_permute_rows_double(sparse_matrix_double A, ConstLongPtr perm);

    /**
     * Permute the columns of the sparse matrix A based on the provided permutation
     * array.
     * <p>
     * Permute the columns of the sparse matrix A based on the provided permutation
     * array.  For each column in A, swap columns as:
     * <p>
     * tmp[:] = A[:,j];
     * A[:,j] = A[:,perm[j]];
     * A[:,perm[j]] = tmp[:];
     *
     * @param A    The sparse matrix.
     * @param perm The permutation array.  Holds number of columns in A values indicating the
     *             permutation of the matrix.  The indices in perm are expected to be 0 based
     *             (first element of pointer is ptr[0]).  The indices in perm are expected to
     *             be within bounds of the matrix.  Undefined behavior if not met.
     * @return On successful return, A has been permuted and SPARSE_SUCCESS is returned.
     */
    @Generated
    @CFunction
    public static native int sparse_permute_cols_float(sparse_matrix_float A, ConstLongPtr perm);

    @Generated
    @CFunction
    public static native int sparse_permute_cols_double(sparse_matrix_double A, ConstLongPtr perm);

    /**
     * Compute the specified elementwise norm of the sparse matrix A.  This is the
     * norm of the matrix treated as a vector, not the operator norm.
     * <p>
     * Compute the specified norm of the sparse matrix A.  This is the norm of the
     * matrix treated as a vector, not the operator norm.  Specify one of:
     * 1) SPARSE_NORM_ONE : sum over i,j ( | A[i,j] | )
     * 2) SPARSE_NORM_TWO : sqrt( sum over i,j (A[i,j])^2 )
     * 3) SPARSE_NORM_INF : max over i,j ( | A[i,j] | )
     * 4) SPARSE_NORM_R1  : sum over j ( sqrt ( sum over i ( A[i,j]^2 ) ) )
     * <p>
     * If norm is not one of the enumerated norm types, the default value is
     * SPARSE_NORM_INF.
     *
     * @param A    The sparse matrix.
     * @param norm Specify the norm to be computed.  Must be one of SPARSE_NORM_ONE, SPARSE_NORM_TWO,
     *             SPARSE_NORM_INF, or SPARSE_NORM_R1.  See discussion for further details.
     * @return Upon success, resulting norm is returned.
     */
    @Generated
    @CFunction
    public static native float sparse_elementwise_norm_float(sparse_matrix_float A, int norm);

    @Generated
    @CFunction
    public static native double sparse_elementwise_norm_double(sparse_matrix_double A, int norm);

    /**
     * Compute the specified operator norm of the sparse matrix A.  For elementwise
     * norm use elementwise_norm routines.
     * <p>
     * Compute the specified norm of the sparse matrix A.  This is the norm of the
     * matrix treated as an linear operator, not the elementwise norm.  Specify one of:
     * 1) SPARSE_NORM_ONE : max over j ( sum over i ( | A[i,j] | ) )
     * 2) SPARSE_NORM_TWO : Maximum singular value. This is significantly more
     * expensive to compute than the other norms.
     * 3) SPARSE_NORM_INF : max over i ( sum over j ( | A[i,j] | ) )
     * 4) SPARSE_NORM_R1  : Not supported, undefined.
     * <p>
     * If norm is not one of the enumerated norm types, the default value is
     * SPARSE_NORM_INF.
     *
     * @param A    The sparse matrix.
     * @param norm Specify the norm to be computed.  Must be one of SPARSE_NORM_ONE, SPARSE_NORM_TWO,
     *             or SPARSE_NORM_INF.  See discussion for further details.
     * @return Upon success, resulting norm is returned.
     */
    @Generated
    @CFunction
    public static native float sparse_operator_norm_float(sparse_matrix_float A, int norm);

    @Generated
    @CFunction
    public static native double sparse_operator_norm_double(sparse_matrix_double A, int norm);

    /**
     * Compute the sum along the specified diagonal of the sparse matrix A.
     * <p>
     * Compute the sum along the specified diagonal of the sparse matrix A.  The
     * diagonal is specified by the parameter offset where zero is the main diagonal,
     * values greater than one refer to diagonals above the main diagonal
     * (A[i,i+offset]), and values less than one refer to diagonals below the main
     * diagonal (A[i-offset, i]).
     * <p>
     * If offset is out of the bounds of the matrix A, 0 is returned.
     *
     * @param A      The sparse matrix.
     * @param offset Specifies the diagonal to sum.  A zero value will sum the main diagonal
     *               (A[i,i]), a value greater than zero will sum diagonals above the main diagonal
     *               (A[i,i+offset]), and a values less than zero will sum diagonals below the main
     *               diagonal (A[i-offset,i]).  If offset is out of the bounds of the matrix A, 0
     *               is returned.
     * @return On success, the resulting trace is returned.
     */
    @Generated
    @CFunction
    public static native float sparse_matrix_trace_float(sparse_matrix_float A, long offset);

    @Generated
    @CFunction
    public static native double sparse_matrix_trace_double(sparse_matrix_double A, long offset);

    /**
     * Level 3 Computational Routines
     * [@functiongroup] Level 3
     * <p>
     * Level 3 routines consisting of matrix-matrix operations
     * <p>
     * Multiplies the dense matrix B by the sparse matrix A and adds the result to
     * the dense matrix C.
     * <p>
     * C = alpha * op(A) * B + C; where op(A) is either A or the transpose of A
     * <p>
     * Multiplies the dense matrix B by the sparse matrix A and adds the result to
     * the dense matrix C (C = alpha * op(A) * B + C, where op(A) is either A
     * or the transpose of A). If A is of size M x N, then B is of size N x n and C is
     * of size M x n.
     * <p>
     * If the desired operation is C = A * B, then an efficient option is to create
     * the C buffer of zeros as C = calloc(sizeof(..)*rows*cols) and then perform
     * the operation with the zero filled C.
     *
     * @param order  Specified the storage order for the dense matrices B and C. Must be one of
     *               CblasRowMajor or CblasColMajor.
     * @param transa Specifies whether to perform the operation with A or the transpose of A.
     *               Must be one of CblasNoTrans or CblasTrans.
     * @param n      The number of columns of the matrices B and C.
     * @param alpha  Scalar multiplier of A.
     * @param A      The sparse matrix.
     * @param B      Pointer to the dense matrix B. The number of rows must be equal to the number
     *               of columns of A and the number of columns is n.  Behavior undefined if this
     *               is not met. The argument ldb describes how many elements to move between one
     *               row (row major) or column (column major).
     * @param ldb    Increment in elements between rows (row major) or columns (column major) of B.
     *               Must be greater than or equal to n when row major, or number of columns of
     *               A when column major.
     * @param C      Pointer to the dense matrix C. The number of rows must be equal to the number
     *               of rows of A and the number of columns is n.  Behavior undefined if this
     *               is not met. The argument ldc describes how many elements to move between one
     *               row (row major) or column (column major).  C is updated with the result of the
     *               operation.
     * @param ldc    Increment in elements between rows (row major) or columns (column major) of C.
     *               Must be greater than or equal to n when row major, or number of rows of
     *               A when column major.
     * @return On success, SPARSE_SUCCESS is returned and C has been updated with result of the
     * operation.  Will return SPARSE_ILLEGAL_PARAMETER if order or transa is not valid
     * or the leading dimension parameters do not meet their dimension requirements.
     * On error, C is unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_matrix_product_dense_float(int order, int transa, long n, float alpha,
            sparse_matrix_float A, ConstFloatPtr B, long ldb, FloatPtr C, long ldc);

    @Generated
    @CFunction
    public static native int sparse_matrix_product_dense_double(int order, int transa, long n, double alpha,
            sparse_matrix_double A, ConstDoublePtr B, long ldb, DoublePtr C, long ldc);

    /**
     * Multiplies the sparse matrix B by the sparse matrix A and adds the result to
     * the dense matrix C.
     * <p>
     * C = alpha * op(A) * B + C; where op(A) is either A or the transpose of A
     * <p>
     * Multiplies the sparse matrix B by the sparse matrix A and adds the result to
     * the dense matrix C (C = alpha * op(A) * B + C, where op(A) is either A
     * or the transpose of A). If A is of size M x K, then B is of size K x N and C is
     * of size M x N.
     * <p>
     * If the desired operation is C = A * B, then an efficient option is to create
     * the C buffer of zeros as C = calloc(sizeof(..)*rows*cols) and then perform
     * the operation with the zero filled C.
     *
     * @param order  Specified the storage order for the dense matrix C. Must be one of
     *               CblasRowMajor or CblasColMajor.
     * @param transa Specifies whether to perform the operation with A or the transpose of A.
     *               Must be one of CblasNoTrans or CblasTrans.
     * @param alpha  Scalar multiplier of A.
     * @param A      The sparse matrix A.
     * @param B      The sparse matrix B.
     * @param C      Pointer to the dense matrix C. The number of rows must be equal to the number
     *               of rows of A and the number of columns must be equal to the number
     *               of columns of B.  Behavior undefined if this is not met.
     *               The argument ldc describes how many elements to move between one row (row major)
     *               or column (column major).  C is updated with the result of the operation.
     * @param ldc    Increment in elements between rows (row major) or columns (column major) of C.
     *               Must be greater than or equal to the number of columns of B when row major,
     *               or number of rows of A when column major.
     * @return On success, SPARSE_SUCCESS is returned and C has been updated with result of the
     * operation.  Will return SPARSE_ILLEGAL_PARAMETER if order or transa is not valid
     * or the leading dimension parameters do not meet their dimension requirements.
     * On error, C is unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_matrix_product_sparse_float(int order, int transa, float alpha,
            sparse_matrix_float A, sparse_matrix_float B, FloatPtr C, long ldc);

    @Generated
    @CFunction
    public static native int sparse_matrix_product_sparse_double(int order, int transa, double alpha,
            sparse_matrix_double A, sparse_matrix_double B, DoublePtr C, long ldc);

    /**
     * Solve the system of equations B = alpha * T^{-1} * B for B where B is a dense
     * matrix and T is a triangular sparse matrix.
     * <p>
     * Solve the system of equations B = alpha * T^{-1} * B for B where B is a dense
     * vector and T is a triangular sparse matrix.  If T is of size N x N, then B must
     * be of size N x nrhs.  The matrix T must be an upper or lower triangular matrix.
     *
     * @param order  Specified the storage order for the dense matrix B. Must be one of
     *               CblasRowMajor or CblasColMajor.
     * @param transt Specifies whether to perform the operation with T or the transpose of T.
     *               Must be one of CblasNoTrans or CblasTrans.
     * @param nrhs   The number of columns of the matrix B.
     * @param alpha  Scalar multiplier of T.
     * @param T      The sparse triangular matrix.  Must be upper or lower triangular matrix.
     *               Will return SPARSE_ILLEGAL_PARAMETER if not a triangular matrix.
     * @param B      Pointer to the dense matrix B. The number of rows must be equal to the number
     *               of columns of T and the number of columns is nrhs.  Behavior undefined if this
     *               is not met. The argument ldb describes how many elements to move between one
     *               row (row major) or column (column major). On exit holds the solution to the
     *               system of equations.
     * @param ldb    Increment in elements between rows (row major) or columns (column major) of B.
     *               Must be greater than or equal to nrhs when row major, or number of columns of
     *               A when column major.
     * @return On success, SPARSE_SUCCESS is returned and B has been updated with result of the
     * operation.  Will return SPARSE_ILLEGAL_PARAMETER if either of order or trant are
     * invalid or the ldb does not meet its dimension requirements.  On error
     * B is unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_matrix_triangular_solve_dense_float(int order, int transt, long nrhs, float alpha,
            sparse_matrix_float T, FloatPtr B, long ldb);

    @Generated
    @CFunction
    public static native int sparse_matrix_triangular_solve_dense_double(int order, int transt, long nrhs, double alpha,
            sparse_matrix_double T, DoublePtr B, long ldb);

    /**
     * Create a sparse matrix object that is stored in point wise format and is ready
     * to receive values from the various insert routines.
     * <p>
     * Create a sparse matrix object that is stored in point wise format and is ready
     * to receive values from the various insert routines.  Point wise format means
     * individual values are stored for a given i,j location as opposed to blocks of
     * values.  For block support use the block_create routines.  See the various
     * insert routines for details on inserting entries into this matrix object.
     * <p>
     * The dimensions M and N must be greater than 0.  On success a valid matrix
     * object is returned, otherwise NULL is returned.
     *
     * @param M The number of rows of the matrix.  Must be greater than 0.
     * @param N The number of columns of the matrix.  Must be greater than 0.
     * @return On success, returns a matrix object that is ready for receiving entries.  If an
     * error occurs, NULL is returned.
     */
    @Generated
    @CFunction
    public static native sparse_matrix_float sparse_matrix_create_float(long M, long N);

    @Generated
    @CFunction
    public static native sparse_matrix_double sparse_matrix_create_double(long M, long N);

    /**
     * Use to build a sparse matrix by inserting one scalar entry at a time.  Update
     * A[i,j] = val.  A must have been created with one of sparse_matrix_create_float or
     * sparse_matrix_create_double.
     * <p>
     * Use to build a sparse matrix by inserting one scalar entry at a time.  Update
     * A[i,j] = val.
     * <p>
     * A must have been created with one of sparse_matrix_create_float or
     * sparse_matrix_create_double.
     * <p>
     * Note that matrix properties cannot be modified after value insertion begins.
     * This includes properties such as specifying a triangular matrix.
     * <p>
     * Insertion can be expensive, generally speaking it is best to do a batch update.
     * Inserted values may be temporarily held internally within the object and only
     * inserted into the sparse format when a later computation triggers a need to
     * insert.
     *
     * @param A   The sparse matrix.  A must have been created with one of sparse_matrix_create_float
     *            or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
     * @param val The scalar value to insert into the sparse matrix.
     * @param i   The row location to insert the value.  Indices are 0 based (first element of
     *            pointer is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
     *            undefined behavior if not met.
     * @param j   The column location to insert the value.  Indices are 0 based (first element of
     *            pointer is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
     *            undefined behavior if not met.
     * @return On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
     * returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
     * returned and A is unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_insert_entry_float(sparse_matrix_float A, float val, long i, long j);

    @Generated
    @CFunction
    public static native int sparse_insert_entry_double(sparse_matrix_double A, double val, long i, long j);

    /**
     * Use to build a sparse matrix by providing a list of point entries.  For each
     * entry provided, update A[indx[i],jndx[i]] = val[i].  A must have been created
     * with one of sparse_matrix_create_float or sparse_matrix_create_double.
     * <p>
     * Use to build a sparse matrix by providing a list of point entries.  For each
     * entry provided, update A[indx[i],jndx[i]] = val[i].
     * <p>
     * A must have been created with one of sparse_matrix_create_float or
     * sparse_matrix_create_double.
     * <p>
     * Note that matrix properties cannot be modified after value insertion begins.
     * This includes properties such as specifying a triangular matrix.
     * <p>
     * Insertion can be expensive, generally speaking it is best to do a batch update.
     * Inserted values may be temporarily held internally within the object and only
     * inserted into the sparse format when a later computation triggers a need to
     * insert.
     *
     * @param A    The sparse matrix.  A must have been created with one of sparse_matrix_create_float
     *             or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
     * @param N    The number of values to insert into A.  Each of indx, jndx and val are of size
     *             N.
     * @param val  Pointer to list of scalar values to insert into the sparse matrix.  The value
     *             is inserted into the location specified by the corresponding indices in indx
     *             and jndx.  Must hold N values.
     * @param indx An array of row indices that correspond to the values in val. Must hold N
     *             values.
     *             <p>
     *             Indices are assumed to be unique.  Additionally, indices are assumed to be in the
     *             bounds of the matrix.  Undefined behavior if any of these assumptions are not
     *             met.
     *             <p>
     *             All indices are 0 based (the first element of a pointer is ptr[0]).
     * @param jndx An array of column indices that correspond to the values in val. Must hold N
     *             values.
     *             <p>
     *             Indices are assumed to be unique.  Additionally, indices are assumed to be in the
     *             bounds of the matrix.  Undefined behavior if any of these assumptions are not
     *             met.
     *             <p>
     *             All indices are 0 based (the first element of a pointer is ptr[0]).
     * @return On successful insertion, A has been updated with the values and SPARSE_SUCCESS is
     * returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
     * returned and A is unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_insert_entries_float(sparse_matrix_float A, long N, ConstFloatPtr val,
            ConstLongPtr indx, ConstLongPtr jndx);

    @Generated
    @CFunction
    public static native int sparse_insert_entries_double(sparse_matrix_double A, long N, ConstDoublePtr val,
            ConstLongPtr indx, ConstLongPtr jndx);

    /**
     * Use to build a sparse matrix by providing a list of point entries for a single
     * column.  For each entry provided, update A[indx[i],j] = val[i].  A must have
     * been created with one of sparse_matrix_create_float or sparse_matrix_create_double.
     * <p>
     * Use to build a sparse matrix by providing a list of point entries for a single
     * column.  For each entry provided, update A[indx[i],j] = val[i].  This will not
     * replace the existing contents of the column, it appends new values and
     * overwrites overlapping values.
     * <p>
     * A must have been created with one of sparse_matrix_create_float or
     * sparse_matrix_create_double.
     * <p>
     * Note that matrix properties cannot be modified after value insertion begins.
     * This includes properties such as specifying a triangular matrix.
     * <p>
     * Insertion can be expensive, generally speaking it is best to do a batch update.
     * Inserted values may be temporarily held internally within the object and only
     * inserted into the sparse format when a later computation triggers a need to
     * insert.
     *
     * @param A    The sparse matrix.  A must have been created with one of sparse_matrix_create_float
     *             or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
     * @param j    The column for value insertion.  Indices are 0 based (first element of pointer
     *             is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
     *             undefined behavior if not met.
     * @param nz   The number of values to insert into A.  Each of indx and val are of size
     *             nz.
     * @param val  Pointer to list of scalar values to insert into the sparse matrix.  The value
     *             is inserted into the location specified by the corresponding indices of indx
     *             and j.  Must hold nz values.
     * @param indx An array of column indices that correspond to the values in val. Must hold nz
     *             values.
     *             <p>
     *             Indices are always assumed to be stored in ascending order. Additionally,
     *             indices are assumed to be unique.  Finally, indices are assumed to be in the
     *             bounds of the matrix.  Undefined behavior if any of these assumptions are not
     *             met.
     *             <p>
     *             All indices are 0 based (the first element of a pointer is ptr[0]).
     * @return On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
     * returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
     * returned and A is unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_insert_col_float(sparse_matrix_float A, long j, long nz, ConstFloatPtr val,
            ConstLongPtr indx);

    @Generated
    @CFunction
    public static native int sparse_insert_col_double(sparse_matrix_double A, long j, long nz, ConstDoublePtr val,
            ConstLongPtr indx);

    /**
     * Use to build a sparse matrix by providing a list of point entries for a single
     * row.  For each entry provided, update A[i,jndx[i]] = val[i].  A must have been
     * created with one of sparse_matrix_create_float or sparse_matrix_create_double.
     * <p>
     * Use to build a sparse matrix by providing a list of point entries for a single
     * row.  For each entry provided, update A[i,jndx[i]] = val[i].  This will not
     * replace the existing contents of the row, it appends new values and
     * overwrites overlapping values.
     * <p>
     * A must have been created with one of sparse_matrix_create_float or
     * sparse_matrix_create_double.
     * <p>
     * Note that matrix properties cannot be modified after value insertion begins.
     * This includes properties such as specifying a triangular matrix.
     * <p>
     * Insertion can be expensive, generally speaking it is best to do a batch update.
     * Inserted values may be temporarily held internally within the object and only
     * inserted into the sparse format when a later computation triggers a need to
     * insert.
     *
     * @param A    The sparse matrix.  A must have been created with one of sparse_matrix_create_float
     *             or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
     * @param i    The row for value insertion.  Indices are 0 based (first element of pointer is
     *             ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
     *             undefined behavior if not met.
     * @param nz   The number of values to insert into A.  Each of jndx and val are of size
     *             nz.
     * @param val  Pointer to list of scalar values to insert into the sparse matrix.  The value
     *             is inserted into the location specified by the corresponding indices of i and
     *             jndx.  Must hold nz values.
     * @param jndx An array of column indices that correspond to the values in val. Must hold nz
     *             values.
     *             <p>
     *             Indices are always assumed to be stored in ascending order. Additionally,
     *             indices are assumed to be unique.  Finally, indices are assumed to be in the
     *             bounds of the matrix.  Undefined behavior if any of these assumptions are not
     *             met.
     *             <p>
     *             All indices are 0 based (the first element of a pointer is ptr[0]).
     * @return On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
     * returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
     * returned and A is unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_insert_row_float(sparse_matrix_float A, long i, long nz, ConstFloatPtr val,
            ConstLongPtr jndx);

    @Generated
    @CFunction
    public static native int sparse_insert_row_double(sparse_matrix_double A, long i, long nz, ConstDoublePtr val,
            ConstLongPtr jndx);

    /**
     * Extract the first nz values of the row begining at A[row,column_start] for the
     * sparse matrix A.  A must have been created with one of sparse_matrix_create_float
     * or sparse_matrix_create_double.
     * <p>
     * Extract the first nz values of the row begining at A[row,column_start] for the
     * sparse matrix A.  The number of nonzero values extracted is limited by nz, and
     * the number of nonzero's written to jndx and val are returned.  Additionally,
     * the column index of the next nonzero value is returned in column_end.
     * For example if nz is returned, not all nonzero values have been extracted,
     * and a second extract can start from column_end.
     * <p>
     * A must have been created with one of sparse_matrix_create_float or
     * sparse_matrix_create_double.
     *
     * @param A            The sparse matrix.  A must have been created with one of
     *                     sparse_matrix_create_float or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is
     *                     returned if not met.
     * @param row          The row for value extraction.  Indices are 0 based (first element of pointer is
     *                     ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
     *                     undefined behavior if not met.
     * @param column_start The index of the column to start extraction.  Indices are 0 based (first
     *                     element of pointer is ptr[0]).  Indices expected to be in the bounds of matrix
     *                     dimensions, undefined behavior if not met.
     * @param column_end   On return, holds the column index of the next nonzero value.  If there is no
     *                     next nonzero value (because all of them have been copied into the sparse
     *                     vector), it holds the number of columns in the matrix.
     *                     Indices are 0 based (first element of pointer is ptr[0]).
     *                     Indices expected to be in the bounds of matrix dimensions, undefined behavior
     *                     if not met.
     * @param nz           The number of values to extract from A.  Each of jndx and val are of size
     *                     nz.
     * @param val          Pointer to array to hold the values extracted from the sparse matrix.  The
     *                     value is extracted from the location specified by the corresponding indices of
     *                     row and jndx.  Must be of size nz elements.  If less than nz nonzero values are
     *                     found, then the last nz - actual_nonzero_count elements of val are untouched.
     * @param jndx         An array to hold the extracted column indices that correspond to the values in
     *                     val. Note that these indices are relative to the matrix row and not the
     *                     starting column index specified by column_start.  Returned indices are 0 based
     *                     (first element of pointer is ptr[0]).  Must be of size nz elements.
     * @return On success val and jndx have been updated with the nonzero values of the row'th
     * row, column_end holds the column index of the next nonzero value, and
     * the number of nonzero values written are returned.  If A creation requirements
     * are not met, SPARSE_ILLEGAL_PARAMETER is returned and val and jndx are unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_extract_sparse_row_float(sparse_matrix_float A, long row, long column_start,
            LongPtr column_end, long nz, FloatPtr val, LongPtr jndx);

    @Generated
    @CFunction
    public static native int sparse_extract_sparse_row_double(sparse_matrix_double A, long row, long column_start,
            LongPtr column_end, long nz, DoublePtr val, LongPtr jndx);

    /**
     * Extract the first nz values of the column begining at A[row_start,column] for
     * the sparse matrix A.  A must have been created with one of
     * sparse_matrix_create_float or sparse_matrix_create_double.
     * <p>
     * Extract the first nz values of the column begining at A[column,row_start] for
     * the sparse matrix A.  The number of nonzero values extracted is limited by nz,
     * and the number of nonzero's written to indx and val are returned.
     * Additionally, the row index of the next nonzero value is returned in
     * row_end.  For example if nz is returned, not all nonzero values have been
     * extracted, and a second extract can start from row_end.
     * <p>
     * A must have been created with one of sparse_matrix_create_float or
     * sparse_matrix_create_double.
     *
     * @param A         The sparse matrix.  A must have been created with one of
     *                  sparse_matrix_create_float or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is
     *                  returned if not met.
     * @param column    The column for value extraction.  Indices are 0 based (first element of pointer
     *                  is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
     *                  undefined behavior if not met.
     * @param row_start The index of the row to start extraction.  Indices are 0 based (first
     *                  element of pointer is ptr[0]).  Indices expected to be in the bounds of matrix
     *                  dimensions, undefined behavior if not met.
     * @param row_end   On return, holds the row index of the next nonzero value.  If there is no
     *                  next nonzero value (because all of them have been copied into the sparse
     *                  vector), it holds the number of rows in the matrix.
     *                  Indices are 0 based (first element of pointer is ptr[0]).
     *                  Indices expected to be in the bounds of matrix dimensions, undefined behavior
     *                  if not met.
     * @param nz        The number of values to extract from A.  Each of indx and val are of size
     *                  nz.
     * @param val       Pointer to array to hold the values extracted from the sparse matrix.  The
     *                  value is extracted from the location specified by the corresponding indices of
     *                  column and indx.  Must be of size nz elements.  If less than nz nonzero values
     *                  are found, then the last nz - actual_nonzero_count elements of val are
     *                  untouched.
     * @param indx      An array to hold the extracted row indices that correspond to the values in
     *                  val. Note that these indices are relative to the matrix column and not the
     *                  starting row index specified by row_start.  Returned indices are 0 based
     *                  (first element of pointer is ptr[0]).  Must be of size nz elements.
     * @return On success val and indx have been updated with the nonzero values of the
     * column'th column, row_end holds the row index of the next nonzero value,
     * and the number of nonzero values written are returned.  If A creation
     * requirements are not met, SPARSE_ILLEGAL_PARAMETER is returned and val and indx
     * are unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_extract_sparse_column_float(sparse_matrix_float A, long column, long row_start,
            LongPtr row_end, long nz, FloatPtr val, LongPtr indx);

    @Generated
    @CFunction
    public static native int sparse_extract_sparse_column_double(sparse_matrix_double A, long column, long row_start,
            LongPtr row_end, long nz, DoublePtr val, LongPtr indx);

    /**
     * Create a sparse matrix object that is stored in block-entry format and is ready
     * to receive values from the various block insert routines.  Blocks are of fixed
     * dimension k x l.
     * <p>
     * Create a sparse matrix object that is stored in block-entry format and is ready
     * to receive values from the various block insert routines.  Blocks are are of
     * fixed dimensions k x l.  Block-entry format means blocks of dense regions will
     * be stored at block indices i,j.  For point wise format use non block version of
     * create. See the various insert routines for details on inserting values into
     * this matrix object.
     * <p>
     * The dimensions Mb, Nb, k, and l must be greater than 0.  On success a valid
     * matrix object is returned, otherwise NULL is returned.
     *
     * @param Mb The number of rows in terms of blocks of the matrix.  There are a total of
     *           Mb * k rows in the matrix.  Must be greater than 0.
     * @param Nb The number of columns in terms of blocks of the matrix.  There are a total of
     *           Nb * l columns in the matrix.  Must be greater than 0.
     * @param k  The row dimension of a block in the sparse matrix.  Must be greater than 0.
     * @param l  The column dimension of a block in the sparse matrix.  Must be greater than 0.
     * @return On success, returns a matrix object that is ready for receiving entries.  If an
     * error occurs, NULL is returned.
     */
    @Generated
    @CFunction
    public static native sparse_matrix_float sparse_matrix_block_create_float(long Mb, long Nb, long k, long l);

    @Generated
    @CFunction
    public static native sparse_matrix_double sparse_matrix_block_create_double(long Mb, long Nb, long k, long l);

    /**
     * Create a sparse matrix object that is stored in block-entry format and is ready
     * to receive values from the various block insert routines.  Blocks are of
     * variable dimensions where the i,j'th block has dimensions K[i] x L[j].
     * <p>
     * Create a sparse matrix object that is stored in block-entry format and is ready
     * to receive values from the various block insert routines.  Blocks are are of
     * variable dimension where the i,j'th block index has a dimension K[i] x L[j].
     * Block-entry format means blocks of dense regions will be stored at block
     * indices i,j.  For point wise format use non block version of create. See the
     * various insert routines for details on inserting values into this matrix
     * object.
     * <p>
     * The dimensions Mb, Nb and all values in K and L must be greater than 0.  On
     * success a valid matrix object is returned, otherwise NULL is returned.
     *
     * @param Mb The number of rows in terms of blocks of the matrix.  Must be greater than 0.
     * @param Nb The number of columns in terms of blocks of the matrix.  Must be greater
     *           than 0.
     * @param K  Array containing row dimensions of the blocks.  The i'th row in terms of blocks
     *           will have a dimension K[i].  K is expected to hold Mb elements.  All values of
     *           K are expected to be greater than 0.
     * @param L  Array containing column dimensions of the blocks.  The j'th column in terms of
     *           blocks will have a dimension L[j].  L is expected to hold Nb elements.  All
     *           values of L are expected to be greater than 0.
     * @return On success, returns a matrix object that is ready for receiving entries.  If an
     * error occurs, NULL is returned.
     */
    @Generated
    @CFunction
    public static native sparse_matrix_float sparse_matrix_variable_block_create_float(long Mb, long Nb, ConstLongPtr K,
            ConstLongPtr L);

    @Generated
    @CFunction
    public static native sparse_matrix_double sparse_matrix_variable_block_create_double(long Mb, long Nb,
            ConstLongPtr K, ConstLongPtr L);

    /**
     * Use to build a sparse matrix by providing a dense block for entry at block
     * location A[bi,bj].  Block size is determined at object creation time.  A must
     * have been created with one of sparse_matrix_block_create_float,
     * sparse_matrix_block_create_double, sparse_matrix_variable_block_create_float, or
     * sparse_matrix_variable_block_create_double.
     * <p>
     * Use to build a sparse matrix by providing a dense block for entry at block
     * location A[bi,bj].  Block size is determined at object creation time.  Given a
     * block dimension of k x l and for location bi,bj, update as:
     * A[bi,bj][i,j] = val[i*row_stride + j*col_stride] for each i in k and each j in
     * l.
     * <p>
     * A must have been created with one of sparse_matrix_block_create_float,
     * sparse_matrix_block_create_double, sparse_matrix_variable_block_create_float, or
     * sparse_matrix_variable_block_create_double.
     * <p>
     * Note that matrix properties cannot be modified after value insertion begins.
     * This includes properties such as specifying a triangular matrix.
     * <p>
     * Insertion can be expensive, generally speaking it is best to do a batch update.
     * Inserted values may be temporarily held internally within the object and only
     * inserted into the sparse format when a later computation triggers a need to
     * insert.
     *
     * @param A          The sparse matrix.  A must have been created with one of
     *                   sparse_matrix_block_create_float, sparse_matrix_block_create_double,
     *                   sparse_matrix_variable_block_create_float, or
     *                   sparse_matrix_variable_block_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if
     *                   not met.  A holds block dimensions (fixed or variable) set with matrix object
     *                   creation routine.
     * @param val        Pointer to block to be inserted at block index location A[bi,bj].  The block is
     *                   of dimension k x l where k and l are set for bi,bj at object creation time.
     *                   The strides between elements for rows and columns are provided in row_stride
     *                   and col_stride.
     * @param row_stride The row stride in number of elements to move from one row to the next for the
     *                   block val.
     * @param col_stride The column stride in number of elements to move from one column to the next for
     *                   the block val.
     * @param bi         The block row index where val is to be inserted.  Indexing is zero based, the
     *                   first block is located at 0,0.  Index is assumed to be within the bounds of the
     *                   matrix object, undefined behavior if not met.
     * @param bj         The block column index where val is to be inserted.  Indexing is zero based, the
     *                   first block is located at 0,0.  Index is assumed to be within the bounds of the
     *                   matrix object, undefined behavior if not met.
     * @return On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
     * returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
     * returned and A is unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_insert_block_float(sparse_matrix_float A, ConstFloatPtr val, long row_stride,
            long col_stride, long bi, long bj);

    @Generated
    @CFunction
    public static native int sparse_insert_block_double(sparse_matrix_double A, ConstDoublePtr val, long row_stride,
            long col_stride, long bi, long bj);

    /**
     * Extract the bi,bj'th block from the sparse matrix A.  A must have been created
     * with one of sparse_matrix_block_create_float, sparse_matrix_block_create_double,
     * sparse_matrix_variable_block_create_float, or
     * sparse_matrix_variable_block_create_double.
     * <p>
     * Extract the bi,bj'th block from the sparse matrix A.
     * <p>
     * A must have been created with one of sparse_matrix_block_create_float,
     * sparse_matrix_block_create_double, sparse_matrix_variable_block_create_float, or
     * sparse_matrix_variable_block_create_double.
     *
     * @param A          The sparse matrix.  A must have been created with one of
     *                   sparse_matrix_block_create_float, sparse_matrix_block_create_double,
     *                   sparse_matrix_variable_block_create_float, or
     *                   sparse_matrix_variable_block_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if
     *                   not met.  A holds block dimensions (fixed or variable) set with matrix object
     *                   creation routine.
     * @param bi         The block row index for value extraction.  Indices are 0 based (first block of
     *                   matrix is A[0,0]).  Indices expected to be in the bounds of matrix dimensions,
     *                   undefined behavior if not met.
     * @param bj         The block column index for value extraction.  Indices are 0 based (first block
     *                   of matrix is A[0,0]).  Indices expected to be in the bounds of matrix
     *                   dimensions, undefined behavior if not met.
     * @param row_stride The row stride in number of elements to move from one row to the next for the
     *                   block val.
     * @param col_stride The column stride in number of elements to move from one column to the next for
     *                   the block val.
     * @param val        Pointer to dense block to place the extracted values.  Expected to be of size
     *                   K x L where K x L is the block size for the matrix object at block index bi,bj.
     *                   This dimensions is set at matrix object creation time.
     * @return On success SPARSE_SUCCESS is return and val has been updated with the block from
     * block index bi,bj. If A creation requirements are not met,
     * SPARSE_ILLEGAL_PARAMETER is returned and val is unchanged.
     */
    @Generated
    @CFunction
    public static native int sparse_extract_block_float(sparse_matrix_float A, long bi, long bj, long row_stride,
            long col_stride, FloatPtr val);

    @Generated
    @CFunction
    public static native int sparse_extract_block_double(sparse_matrix_double A, long bi, long bj, long row_stride,
            long col_stride, DoublePtr val);

    /**
     * Return the dimension of the block for the i'th row of a sparse block matrix.
     * Returns 0 if the matrix was not created with a block create routine.
     */
    @Generated
    @CFunction
    @NInt
    public static native long sparse_get_block_dimension_for_row(VoidPtr A, long i);

    /**
     * Return the dimension of the block for the j'th column of a sparse block matrix.
     * Returns 0 if the matrix was not created with a block create routine.
     */
    @Generated
    @CFunction
    @NInt
    public static native long sparse_get_block_dimension_for_col(VoidPtr A, long j);

    /**
     * Force any recently added values to the matrix to be put into the internal
     * sparse storage format.
     * <p>
     * Force any recently added values to the matrix to be put into the internal
     * sparse storage format.  Values inserted into a matrix object will may not go
     * directly into the sparse representation until needed, for example when a
     * computation occurs.  In some cases is may be beneficial to the caller to know
     * when the cost of the update will occur.  This routine allows the caller to
     * trigger adding values to the internal sparse format.
     * <p>
     * Adding values to the sparse format can be costly, and batch updates to the
     * matrices are recommended.  Similarly, use of this routine may be expensive, so
     * it is best to insert all values of a batch and call this routine once.
     *
     * @param A The sparse matrix, which has had values recently inserted into the object.
     * @return On success, A has all values inserted into the internal sparse representation.
     */
    @Generated
    @CFunction
    public static native int sparse_commit(VoidPtr A);

    /**
     * Returns the value of the given property name.
     * <p>
     * Returns the value of the given property name. See matrix properties enumeration
     * for further property details.
     *
     * @param A     The sparse matrix object.
     * @param pname The property name to get the value of.  See matrix properties enumeration for
     *              options.
     * @return Returns the value of the property for a valid object and property, or 0
     * otherwise.
     */
    @Generated
    @CFunction
    @NInt
    public static native long sparse_get_matrix_property(VoidPtr A, int pname);

    /**
     * Set the given property for a matrix object that has not had any values
     * inserted.
     * <p>
     * Set the given property for the matrix object.  The matrix object must not have
     * had values inserted, else SPARSE_CANNOT_SET_PROPERTY is returned and the
     * property is not set.
     * <p>
     * Certain groups of properties are mutually exclusive and setting multiple values
     * within a group is undefined.
     *
     * @param A     The sparse matrix object.  Note that after elements have been inserted
     *              properties cannot be changed.
     * @param pname The property name to set true.  See matrix properties enumeration for options.
     * @return Returns SPARSE_SUCCESS when property is successfully set, otherwise return
     * SPARSE_CANNOT_SET_PROPERTY.
     */
    @Generated
    @CFunction
    public static native int sparse_set_matrix_property(VoidPtr A, int pname);

    /**
     * Return the number of rows of the matrix.
     */
    @Generated
    @CFunction
    public static native long sparse_get_matrix_number_of_rows(VoidPtr A);

    /**
     * Return the number of columns of the matrix.
     */
    @Generated
    @CFunction
    public static native long sparse_get_matrix_number_of_columns(VoidPtr A);

    /**
     * Return the number of nonzero values in the matrix.
     */
    @Generated
    @CFunction
    @NInt
    public static native long sparse_get_matrix_nonzero_count(VoidPtr A);

    /**
     * Return the number of nonzero values for the i'th row.  If index is out of
     * bounds of the matrix, 0 is returned.
     */
    @Generated
    @CFunction
    @NInt
    public static native long sparse_get_matrix_nonzero_count_for_row(VoidPtr A, long i);

    /**
     * Return the number of nonzero values for the j'th column.  If index is out of
     * bounds of the matrix, 0 is returned.
     */
    @Generated
    @CFunction
    @NInt
    public static native long sparse_get_matrix_nonzero_count_for_column(VoidPtr A, long j);

    /**
     * Release any memory associated with the matrix object.
     * <p>
     * Release any memory associated with the matrix object.  Upon return the object
     * is no longer valid and any use of the object is undefined.
     *
     * @param A The sparse matrix object.
     * @return All memory associated with the matrix object is released and returns
     * SPARSE_SUCCESS.
     */
    @Generated
    @CFunction
    public static native int sparse_matrix_destroy(VoidPtr A);

    /**
     * Return the number of nonzero values in the dense vector x.
     *
     * @param N    The number of elements in the dense vector x.
     * @param x    Pointer to the vector x.
     * @param incx Increment between valid values in the dense vector x.  Negative strides are
     *             supported.
     * @return Return the count of the nonzero values in the vector x.
     */
    @Generated
    @CFunction
    @NInt
    public static native long sparse_get_vector_nonzero_count_float(long N, ConstFloatPtr x, long incx);

    @Generated
    @CFunction
    @NInt
    public static native long sparse_get_vector_nonzero_count_double(long N, ConstDoublePtr x, long incx);

    /**
     * Pack the first nz nonzero values and indices from the dense vector x and
     * place them in y and indy.
     * <p>
     * Pack the first nz nonzero values and indices from the dense vector x and
     * place them in y and indy.  If less than nz nonzero elements are found in the N
     * elements of x, then the last nz - actual_nonzero_count elements of y and indy
     * are unused.  The number of indices written can range from 0 to nz values and
     * the number written is returned.
     *
     * @param N    The number of elements in the dense vector x.
     * @param nz   The number of nonzero values to collect.  If less than nz nonzero elements are
     *             found in the N elements of x, then the last nz - actual_nonzero_count of y and
     *             indy are unused.
     * @param x    Pointer to the dense vector x.
     * @param incx Increment between valid values in the dense vector x.  Negative strides are
     *             supported.
     * @param y    The destination dense storage for nonzero values of x.  Expected to be of size
     *             nz elements.  On return, any nonzero values are placed in this array, if the
     *             actual number of nonzero values is less than nz, then the last
     *             nz - actual_nonzero_count elements are unused.
     * @param indy The destination dense storage for nonzero indices of x.  Expected to be of size
     *             nz elements.  On return, any nonzero indices are placed in this array, if the
     *             actual number of nonzero values is less than nz, then the last
     *             nz - actual_nonzero_count elements are unused.  Returned indices are 0 based
     *             (the first element of a pointer is ptr[0]).
     * @return On success, y and indy are updated with up to the first nz nonzero indices.
     * The number of nonzero values written is returned.
     */
    @Generated
    @CFunction
    @NInt
    public static native long sparse_pack_vector_float(long N, long nz, ConstFloatPtr x, long incx, FloatPtr y,
            LongPtr indy);

    @Generated
    @CFunction
    @NInt
    public static native long sparse_pack_vector_double(long N, long nz, ConstDoublePtr x, long incx, DoublePtr y,
            LongPtr indy);

    /**
     * Extract elements from the sparse vector x into the corresponding location in
     * the dense vector y.  Optionally zero the unused values of y.
     * <p>
     * Extract elements from the sparse vector x into the corresponding location in
     * the dense vector y.  Optionally zero the unused values of y.
     * <p>
     * if (zero) for (i in 0 .. N-1) y[i*incy] = 0;
     * <p>
     * for (i in 0 .. nz-1) if (indx[i] < N) y[indx[i]*incy] = x[i];
     *
     * @param N    The number of elements in the dense vector y.
     * @param nz   The number of nonzero entries in the sparse vector x.
     * @param zero When true, zero the elements of y which do not have nonzero values written to
     *             them.  When false ignore the elements of y which do not have nonzero values
     *             written to them.
     * @param x    Pointer to the dense storage for the values of the sparse vector x.  The
     *             corresponding entry in indx holds the index of the value.  Contains nz values.
     * @param indx Pointer to the dense storage for the index values of the sparse vector x.  The
     *             corresponding entry in x holds the values of the vector.  Contains nz values.
     *             <p>
     *             Indices are always assumed to be stored in ascending order. Additionally,
     *             indices are assumed to be unique.  Undefined behavior if either of these
     *             assumptions are not met.
     *             <p>
     *             All indices are 0 based (the first element of a pointer is ptr[0]).
     * @param y    Pointer to the dense vector y.  Expected to be of size N*abs(incy) elements.
     *             Negative strides are supported.  Note, unlike dense BLAS routines, the pointer
     *             points to the last element when stride is negative. On exit, the entries
     *             described by the indices in indx will be filled with the corresponding values
     *             in x and all other values will be unchanged if parameter zero is false, or set
     *             to zero if parameter zero is true.
     * @param incy Increment between valid values in the dense vector y.  Negative strides are
     *             supported.
     * @return On exit y has been updated with the nonzero values. If nz is less than or
     * equal to zero y is unchanged.
     */
    @Generated
    @CFunction
    public static native void sparse_unpack_vector_float(long N, long nz, boolean zero, ConstFloatPtr x,
            ConstLongPtr indx, FloatPtr y, long incy);

    @Generated
    @CFunction
    public static native void sparse_unpack_vector_double(long N, long nz, boolean zero, ConstDoublePtr x,
            ConstLongPtr indx, DoublePtr y, long incy);

    /**
     * Integrate a function F over ]A,B[.
     * <p>
     * This function provides a set of algorithms (integrators) to compute an approximation S' of the integral S = &int; F(x) dx over the interval ]A,B[.
     * <p>
     * The QNG (simple non-adaptive Gauss-Kronrod integration) and QAG (simple adaptive Gauss-Kronrod integration)
     * integrators are C ports of the QUADPACK library corresponding routines.
     * The QAGS integrator provides the functionality offered by the QAGS and QAGI QUADPACK routines.
     * <p>
     * On success, S' is assumed to verify abs(S-S') &le; max(abs_tolerance, rel_tolerance * abs(S)).
     * The integration algorithms will identify <b>most</b> cases of divergence, slow convergence, and bad behaviour, and report an error.
     * The bounds a,b do not need to verify a &le; b. If the integrator is QAGS, one or both of the interval bounds can be infinite (-INFINITY or +INFINITY).
     * <p>
     * Unless F is known to be smooth enough to guarantee success, it is strongly advised to always check the returned status and absolute error.
     * <p>
     * The QUADPACK library documentation provides a decision tree to select the integrator.
     * Adapted to match the contents of this library, this decision tree becomes:
     *
     * <b>Integration over a finite region</b>
     *
     * <ul>
     * <li>If performance is not a concern and you don’t know much about the specifics of the problem, use QAGS.
     * <li>Otherwise, if the integrand is smooth, use QNG or QAG if the requested tolerance couldn't be reached with QNG.
     * <li>Otherwise, if there are discontinuities or singularities of the integrand or of its derivative, and you know where they are,
     * split the integration range at these points and analyze each subinterval.
     * <li>Otherwise, if the integrand has end point singularities, use QAGS.
     * <li>Otherwise, if the integrand has an oscillatory behavior of nonspecific type, and no singularities, use QAG with 61 points per interval.
     * <li>Otherwise, use QAGS.
     * </ul>
     *
     * <b>Integration over an infinite region</b>
     *
     * <ul>
     * <li>If the integrand decays rapidly to zero, truncate the interval and use the finite interval decision tree.
     * <li>Otherwise, if you are not constrained by computer time, and do not wish to analyze the problem further, use QAGS.
     * <li>Otherwise, if the integrand has a non-smooth behavior in the range, and you know where it occurs, split off these regions and use
     * the appropriate finite range routines to integrate over them. Then begin this tree again to handle the remainder of the region.
     * <li>Otherwise, truncation of the interval, or application of a suitable transformation for reducing the problem to a finite range may be possible.
     * </ul>
     * <p>
     * QUADPACK Reference:
     * Robert Piessens, Elise deDoncker-Kapenga, Christian Ueberhuber, David Kahaner,
     * QUADPACK: A Subroutine Package for Automatic Integration,
     * Springer, 1983, ISBN: 3540125531, LC: QA299.3.Q36.
     *
     * @param f              Function to integrate. Can't be NULL.
     * @param a              First bound of the integration interval. May be +/- INFINITY for QAGS.
     * @param b              Second bound of the integration interval. May be +/- INFINITY for QAGS.
     * @param options        Integration options. Can't be NULL.
     * @param status         If not NULL, <tt>*status</tt> receives QUADRATURE_SUCCESS if the integration was successful, and a negative QUADRATURE_..._ERROR code on failure.
     * @param abs_error      If not NULL, <tt>*abs_error</tt> receives an estimate of the absolute error on the result.
     * @param workspace_size Number of bytes allocated in <tt>workspace</tt>, or 0.
     * @param workspace      If not NULL, points to a work buffer of <tt>workspace_size</tt> bytes. In that case, no additional memory will be allocated.
     *                       If NULL, the function will internally allocate a workspace buffer if one is needed.
     * @return Returns an approximation to the integral.
     */
    @Generated
    @CFunction
    public static native double quadrature_integrate(
            @UncertainArgument("Options: reference, array Fallback: reference") quadrature_integrate_function __f,
            double __a, double __b,
            @UncertainArgument("Options: reference, array Fallback: reference") quadrature_integrate_options options,
            IntPtr status, DoublePtr abs_error, @NUInt long workspace_size, VoidPtr workspace);

    /**
     * Create a convolution layer filter (DEPRECATED,  Use BNNSFilterCreateLayerConvolution)
     * <p>
     * Creates a filter applying the convolution described in <tt>layer_params</tt>.
     * Some combinations of the parameters may not be supported, in which case the call will fail.
     *
     * @param in_desc       Input image stack descriptor
     * @param out_desc      Output image stack descriptor
     * @param layer_params  Layer parameters and weights
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateConvolutionLayer(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSImageStackDescriptor in_desc,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSImageStackDescriptor out_desc,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSConvolutionLayerParameters layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a fully connected layer filter (DEPRECATED,  Use BNNSFilterCreateLayerFullyConnected)
     * <p>
     * Creates a filter applying the fully connected layer described in <tt>layer_params</tt>.
     * Some combinations of the parameters may not be supported, in which case the call will fail.
     *
     * @param in_desc       Input vector descriptor
     * @param out_desc      Output vector descriptor
     * @param layer_params  Layer parameters and weights
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateFullyConnectedLayer(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSVectorDescriptor in_desc,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSVectorDescriptor out_desc,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFullyConnectedLayerParameters layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a pooling layer filter (DEPRECATED,  Use BNNSFilterCreateLayerPooling)
     * <p>
     * Creates a filter applying the pooling layer described in <tt>layer_params</tt>
     * Some combinations of the parameters may not be supported, in which case the call will fail.
     *
     * @param in_desc       Input image stack descriptor
     * @param out_desc      Output image stack descriptor
     * @param layer_params  Layer parameters and weights
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreatePoolingLayer(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSImageStackDescriptor in_desc,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSImageStackDescriptor out_desc,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSPoolingLayerParameters layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Apply a filter
     *
     * @param filter Filter to apply
     * @param in     Pointer to the input data
     * @param out    Pointer to the output data
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFilterApply(VoidPtr filter, ConstVoidPtr in, VoidPtr out);

    /**
     * Apply a filter to several pairs of (input, output) data
     * <p>
     * The filter is applied for each of the <tt>batch_size</tt> inputs, and produces <tt>batch_size</tt> outputs.
     * <tt>in</tt> (resp. <tt>out</tt>) is expected to point to <tt>batch_size</tt> times the input (resp. output) object size defined when the filter was created.
     *
     * @param filter     Filter to apply
     * @param batch_size Number of (input, output) pairs to process
     * @param in         Pointer to the input data
     * @param in_stride  Increment (in values) between inputs
     * @param out        Pointer to the output data
     * @param out_stride Increment (in values) between outputs
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFilterApplyBatch(VoidPtr filter, @NUInt long batch_size, ConstVoidPtr in,
            @NUInt long in_stride, VoidPtr out, @NUInt long out_stride);

    /**
     * Destroy filter
     * <p>
     * Releases all resources allocated for this filter.
     *
     * @param filter Filter to destroy
     */
    @Generated
    @CFunction
    public static native void BNNSFilterDestroy(VoidPtr filter);

    /**
     * Calculates the reciprocal for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to 1/x[i].
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvrecf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the reciprocal for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to 1/x[i].
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvrec(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the quotient of the two source vectors.
     *
     * @param z (output) Output vector of size *n. z[i] is set to y[i]/x[i].
     * @param y (input)  Input vector of size *n, numerators in division.
     * @param x (input)  Input vector of size *n, denominators in division.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvdivf(FloatPtr arg1, ConstFloatPtr arg2, ConstFloatPtr arg3, ConstIntPtr arg4);

    /**
     * Calculates the quotient of the two source vectors.
     *
     * @param z (output) Output vector of size *n. z[i] is set to y[i]/x[i].
     * @param y (input)  Input vector of size *n, numerators in division.
     * @param x (input)  Input vector of size *n, denominators in division.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvdiv(DoublePtr arg1, ConstDoublePtr arg2, ConstDoublePtr arg3, ConstIntPtr arg4);

    /**
     * Calculates the square root for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to sqrt(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsqrtf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the square root for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to sqrt(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsqrt(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the cube root for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to cbrt(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvcbrtf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the cube root for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to cbrt(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvcbrt(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the reciprocal square root for each element of a
     * vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to 1/sqrt(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvrsqrtf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the reciprocal square root for each element of a
     * vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to 1/sqrt(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvrsqrt(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the exponential function e**x for each element of a
     * vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to exp(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvexpf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the exponential function e**x for each element of a
     * vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to exp(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvexp(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates (e**x) - 1 for each element of a vector, with high
     * accuracy around x=0.
     * <p>
     * If x is nearly zero, then the common expression exp(x) - 1.0 will suffer
     * from catastrophic cancellation and the result will have little or no
     * precision.  This function provides an alternative means to do this
     * calculation without the risk of significant loss of precision.
     *
     * @param y (output) Output vector of size *n. y[i] is set to expm1(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     * @see log1pf
     */
    @Generated
    @CFunction
    public static native void vvexpm1f(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates (e**x) - 1 for each element of a vector, with high
     * accuracy around x=0.
     * <p>
     * If x is nearly zero, then the common expression exp(x) - 1.0 will suffer
     * from catastrophic cancellation and the result will have little or no
     * precision.  This function provides an alternative means to do this
     * calculation without the risk of significant loss of precision.
     *
     * @param y (output) Output vector of size *n. y[i] is set to expm1(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     * @see log1p
     */
    @Generated
    @CFunction
    public static native void vvexpm1(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the natural logarithm for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvlogf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the natural logarithm for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvlog(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the logarithm base 10 for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log10(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvlog10f(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the logarithm base 10 for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log10(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvlog10(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates log(1+x) for each element of a vector, with high
     * accuracy around x=0.
     * <p>
     * If x is nearly zero, the expression log(1+x) will be highly inaccurate
     * due to floating point rounding errors in (1+x).
     * This function provides an alternative means to calculate this value with
     * higher accuracy.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log1p(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     * @see expm1f
     */
    @Generated
    @CFunction
    public static native void vvlog1pf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates log(1+x) for each element of a vector, with high
     * accuracy around x=0.
     * <p>
     * If x is nearly zero, the expression log(1+x) will be highly inaccurate
     * due to floating point rounding errors in (1+x).
     * This function provides an alternative means to calculate this value with
     * higher accuracy.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log1p(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     * @see expm1
     */
    @Generated
    @CFunction
    public static native void vvlog1p(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Returns, as a floating-point value, the unbiased floating-point
     * exponent for each element of a vector.
     * <p>
     * For a non-zero finite floating-point number f, logb is defined to be the
     * integer that satisfies abs(f) = significand * 2**logb(f), with significand
     * in [1,2).
     * <p>
     * If x is +/-0, then y is set to -inf.
     * If x is +/-inf, then y is set to +inf.
     * If x is NaN, then y is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log10(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvlogbf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Returns, as a floating-point value, the unbiased floating-point
     * exponent for each element of a vector.
     * <p>
     * For a non-zero finite floating-point number f, logb is defined to be the
     * integer that satisfies abs(f) = significand * 2**logb(f), with significand
     * in [1,2).
     * <p>
     * If x is +/-0, then y is set to -inf.
     * If x is +/-inf, then y is set to +inf.
     * If x is NaN, then y is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log10(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvlogb(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Returns the absolute value for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to fabs(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvfabsf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Returns the absolute value for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to fabs(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvfabs(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates, elementwise, x**y for two vectors x and y.
     * <p>
     * The following special values of x and y produce the given value of z:
     * y            x         z
     * ==============   =======   =======
     * odd integer,<0    +/-0     +/-inf
     * odd integer,>0    +/-0     +/-0
     * otherwise,  <0    +/-0       +inf
     * otherwise,  >0    +/-0       +0
     * +/-inf          -1        1
     * NaN            +1        1
     * +/-0           NaN        1
     * -inf        |x|<1      +inf
     * -inf        |x|>1      +0
     * +inf        |x|<1      +0
     * +inf        |x|>1      +inf
     * odd integer,<0     -inf      -0
     * odd integer,>0     -inf      -inf
     * otherwise,  <0     -inf      +0
     * otherwise,  >0     -inf      +inf
     * <0           +inf      +0
     * >0           +inf      +inf
     * non-integer       <0       NaN
     *
     * @param z (output) Output vector of size *n. z[i] is set to pow(x[i], y[i]).
     * @param y (input)  Input vector of size *n, exponent in calculation.
     * @param x (input)  Input vector of size *n, base in calculation.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvpowf(FloatPtr arg1, ConstFloatPtr arg2, ConstFloatPtr arg3, ConstIntPtr arg4);

    /**
     * Calculates, elementwise, x**y for two vectors x and y.
     * <p>
     * The following special values of x and y produce the given value of z:
     * y            x         z
     * ==============   =======   =======
     * odd integer,<0    +/-0     +/-inf
     * odd integer,>0    +/-0     +/-0
     * otherwise,  <0    +/-0       +inf
     * otherwise,  >0    +/-0       +0
     * +/-inf          -1        1
     * NaN            +1        1
     * +/-0           NaN        1
     * -inf        |x|<1      +inf
     * -inf        |x|>1      +0
     * +inf        |x|<1      +0
     * +inf        |x|>1      +inf
     * odd integer,<0     -inf      -0
     * odd integer,>0     -inf      -inf
     * otherwise,  <0     -inf      +0
     * otherwise,  >0     -inf      +inf
     * <0           +inf      +0
     * >0           +inf      +inf
     * non-integer       <0       NaN
     *
     * @param z (output) Output vector of size *n. z[i] is set to pow(x[i], y[i]).
     * @param y (input)  Input vector of size *n, exponent in calculation.
     * @param x (input)  Input vector of size *n, base in calculation.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvpow(DoublePtr arg1, ConstDoublePtr arg2, ConstDoublePtr arg3, ConstIntPtr arg4);

    /**
     * Calculates, elementwise, x**y for a vector x and a scalar y.
     *
     * @param z (output) Output vector of size *n. z[i] is set to pow(x[i], y).
     * @param y (input)  Input scalar, exponent in calculation.
     * @param x (input)  Input vector of size *n, base in calculation.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvpowsf(FloatPtr arg1, ConstFloatPtr arg2, ConstFloatPtr arg3, ConstIntPtr arg4);

    /**
     * Calculates, elementwise, x**y for a vector x and a scalar y.
     *
     * @param z (output) Output vector of size *n. z[i] is set to pow(x[i], y).
     * @param y (input)  Input scalar, exponent in calculation.
     * @param x (input)  Input vector of size *n, base in calculation.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvpows(DoublePtr arg1, ConstDoublePtr arg2, ConstDoublePtr arg3, ConstIntPtr arg4);

    /**
     * Returns the sine for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to sin(x[i]).
     * @param x (input)  Input vector of size *n, in radians.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsinf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Returns the sine for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to sin(x[i]).
     * @param x (input)  Input vector of size *n, in radians.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsin(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Returns the cosine for each element of a vector.
     * <p>
     * If x[i] is +/-inf, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to cos(x[i]).
     * @param x (input)  Input vector of size *n, in radians.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvcosf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Returns the cosine for each element of a vector.
     * <p>
     * If x[i] is +/-inf, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to cos(x[i]).
     * @param x (input)  Input vector of size *n, in radians.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvcos(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Returns the tangent for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to tan(x[i]).
     * @param x (input)  Input vector of size *n, in radians.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvtanf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Returns the tangent for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to tan(x[i]).
     * @param x (input)  Input vector of size *n, in radians.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvtan(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Returns the principal value of arc sine for each element of a
     * vector.
     * <p>
     * The calculated values are in the range [-pi/2, +pi/2].
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If |x[i]| > 1, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to asin(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvasinf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Returns the principal value of arc sine for each element of a
     * vector.
     * <p>
     * The calculated values are in the range [-pi/2, +pi/2].
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If |x[i]| > 1, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to asin(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvasin(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Returns the principal value of arc cosine for each element of a
     * vector.
     * <p>
     * The calculated values are in the range [0, pi].
     * If x[i] is 1, y[i] is set to +0.
     * If |x[i]| > 1, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to acos(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvacosf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Returns the principal value of arc cosine for each element of a
     * vector.
     * <p>
     * The calculated values are in the range [0, pi].
     * If x[i] is 1, y[i] is set to +0.
     * If |x[i]| > 1, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to acos(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvacos(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Returns the principal value of arc tangent for each element of a
     * vector.
     * <p>
     * The calculated values are in the range [-pi/2, pi/2].
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to +/-pi/2.
     *
     * @param y (output) Output vector of size *n. y[i] is set to atan(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvatanf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Returns the principal value of arc tangent for each element of a
     * vector.
     * <p>
     * The calculated values are in the range [-pi/2, pi/2].
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to +/-pi/2.
     *
     * @param y (output) Output vector of size *n. y[i] is set to atan(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvatan(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates, elementwise, the principal value of the arc tangent
     * of y/x, for two vectors x and y.
     * <p>
     * [@discusssion]
     * The signs of both arguments are used to determine the quadrant of the
     * calculated value.
     * <p>
     * The following special values of x and y produce the given value of z:
     * y         x         z
     * =======   =======   =======
     * +/-0       -0       +/-pi
     * +/-0       +0       +/-0
     * +/-0       <0       +/-pi
     * +/-0       >0       +/-0
     * >0       +/-0      +pi/2
     * <0       +/-0      -pi/2
     * +/-y      -inf      +/-pi       y>0, finite
     * +/-y      +inf      +/-0        y>0, finite
     * +/-inf      x       +/-pi/2      x finite
     * +/-inf     -inf     +/-3pi/4
     * +/-inf     +inf     +/-pi/4
     *
     * @param z (output) Output vector of size *n. z[i] is set to atan2(y,x).
     * @param y (input)  Input vector of size *n.
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvatan2f(FloatPtr arg1, ConstFloatPtr arg2, ConstFloatPtr arg3, ConstIntPtr arg4);

    /**
     * Calculates, elementwise, the principal value of the arc tangent
     * of y/x, for two vectors x and y.
     * <p>
     * [@discusssion]
     * The signs of both arguments are used to determine the quadrant of the
     * calculated value.
     * <p>
     * The following special values of x and y produce the given value of z:
     * y         x         z
     * =======   =======   =======
     * +/-0       -0       +/-pi
     * +/-0       +0       +/-0
     * +/-0       <0       +/-pi
     * +/-0       >0       +/-0
     * >0       +/-0      +pi/2
     * <0       +/-0      -pi/2
     * +/-y      -inf      +/-pi       y>0, finite
     * +/-y      +inf      +/-0        y>0, finite
     * +/-inf      x       +/-pi/2      x finite
     * +/-inf     -inf     +/-3pi/4
     * +/-inf     +inf     +/-pi/4
     *
     * @param z (output) Output vector of size *n. z[i] is set to atan2(y,x).
     * @param y (input)  Input vector of size *n.
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvatan2(DoublePtr arg1, ConstDoublePtr arg2, ConstDoublePtr arg3, ConstIntPtr arg4);

    /**
     * Returns the sine and cosine for each element of a vector.
     *
     * @param z (output) Output vector of size *n. z[i] is set to sin(x[i]).
     * @param y (output) Output vector of size *n. y[i] is set to cos(x[i]).
     * @param x (input)  Input vector of size *n, in radians.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsincosf(FloatPtr arg1, FloatPtr arg2, ConstFloatPtr arg3, ConstIntPtr arg4);

    /**
     * Returns the sine and cosine for each element of a vector.
     *
     * @param z (output) Output vector of size *n. z[i] is set to sin(x[i]).
     * @param y (output) Output vector of size *n. y[i] is set to cos(x[i]).
     * @param x (input)  Input vector of size *n, in radians.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsincos(DoublePtr arg1, DoublePtr arg2, ConstDoublePtr arg3, ConstIntPtr arg4);

    /**
     * Calculates the hyperbolic sine for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to +/-inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to sinh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsinhf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the hyperbolic sine for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to +/-inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to sinh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsinh(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the hyperbolic cosine for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] is set to 1.
     * If x[i] is +/-inf, y[i] is set to +inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to cosh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvcoshf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the hyperbolic cosine for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] is set to 1.
     * If x[i] is +/-inf, y[i] is set to +inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to cosh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvcosh(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the hyperbolic tangent for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to +/-1.
     *
     * @param y (output) Output vector of size *n. y[i] is set to tanh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvtanhf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the hyperbolic tangent for each element of a vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to +/-1.
     *
     * @param y (output) Output vector of size *n. y[i] is set to tanh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvtanh(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the inverse hyperbolic sine for each element of a
     * vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to +/-inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to asinh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvasinhf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the inverse hyperbolic sine for each element of a
     * vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-inf, y[i] is set to +/-inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to asinh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvasinh(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the principal value of inverse hyperbolic cosine for
     * each element of a vector.
     * <p>
     * The calculated values are in the range [0, +inf].
     * If x[i] == 1, y[i] is set to +0.
     * If x[i] < 1, y[i] is set to NaN.
     * If x[i] == +inf, y[i] is set to +inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to acosh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvacoshf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the principal value of inverse hyperbolic cosine for
     * each element of a vector.
     * <p>
     * The calculated values are in the range [0, +inf].
     * If x[i] == 1, y[i] is set to +0.
     * If x[i] < 1, y[i] is set to NaN.
     * If x[i] == +inf, y[i] is set to +inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to acosh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvacosh(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the inverse hyperbolic tangent for each element of a
     * vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-1, y[i] is set to +/-inf.
     * If |x[i]|>1, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to atanh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvatanhf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the inverse hyperbolic tangent for each element of a
     * vector.
     * <p>
     * If x[i] is +/-0, y[i] preserves the signed zero.
     * If x[i] is +/-1, y[i] is set to +/-inf.
     * If |x[i]|>1, y[i] is set to NaN.
     *
     * @param y (output) Output vector of size *n. y[i] is set to atanh(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvatanh(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the integer truncation for each element of a vector.
     * <p>
     * The behavior of this function is equivalent to the libm function truncf().
     * It rounds x[i] to the nearest integer in the direction of zero,
     * equivalent to the C typecast y[i] = (float) (int) x[i].
     *
     * @param y (output) Output vector of size *n. y[i] is set to integer
     *          trunction of x[i].
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvintf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the integer truncation for each element of a vector.
     * <p>
     * The behavior of this function is equivalent to the libm function trunc().
     * It rounds x[i] to the nearest integer in the direction of zero,
     * equivalent to the C typecast y[i] = (double) (int) x[i].
     *
     * @param y (output) Output vector of size *n. y[i] is set to integer
     *          trunction of x[i].
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvint(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the rounding to the nearest integer for each element
     * of a vector.
     * <p>
     * Rounds x[i] to the nearest integer, with ties rounded to even.
     *
     * @param y (output) Output vector of size *n. y[i] is set to the nearest
     *          integer to x[i].
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvnintf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the rounding to the nearest integer for each element
     * of a vector.
     * <p>
     * Rounds x[i] to the nearest integer, with ties rounded to even.
     *
     * @param y (output) Output vector of size *n. y[i] is set to the nearest
     *          integer to x[i].
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvnint(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the ceiling function for each element of a vector.
     * <p>
     * Rounds to smallest integral value not less than x[i]. That is to say,
     * rounds towards +inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to ceil(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvceilf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the ceiling function for each element of a vector.
     * <p>
     * Rounds to smallest integral value not less than x[i]. That is to say,
     * rounds towards +inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to ceil(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvceil(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the floor function for each element of a vector.
     * <p>
     * Rounds to smallest integral value not greater than x[i]. That is to say,
     * rounds towards -inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to floor(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvfloorf(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the floor function for each element of a vector.
     * <p>
     * Rounds to smallest integral value not greater than x[i]. That is to say,
     * rounds towards -inf.
     *
     * @param y (output) Output vector of size *n. y[i] is set to floor(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvfloor(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates, elementwise, the floating-point remainder of y/x,
     * for two vectors x and y.
     * <p>
     * Specifically, the function calculates z=y-k*x, for some integer k such that,
     * if x is non-zero, the result has the same sign as y, and magnitude less than
     * that of x.
     * <p>
     * If y[i] is +/-0, and x[i] is not 0 or NaN, z[i] is set to +/-0.
     * If y[i] is +/-inf, or x[i] is +/-0, z[i] is set to NaN.
     * If x[i] is +/-inf, and y is finite, z[i] is set to y[i].
     * <p>
     * Note that argument labels are switched with respect to the libm function
     * fmod().
     *
     * @param z (output) Output vector of size *n. z[i] is set to fmod(y[i], x[i]).
     * @param y (input)  Input vector of size *n, numerator in calculation.
     * @param x (input)  Input vector of size *n, denominator in calculation.
     * @param n (input)  The number of elements in the vectors x, y and z.
     * @see vvremainderf
     */
    @Generated
    @CFunction
    public static native void vvfmodf(FloatPtr arg1, ConstFloatPtr arg2, ConstFloatPtr arg3, ConstIntPtr arg4);

    /**
     * Calculates, elementwise, the floating-point remainder of y/x,
     * for two vectors x and y.
     * <p>
     * Specifically, the function calculates z=y-k*x, for some integer k such that,
     * if x is non-zero, the result has the same sign as y, and magnitude less than
     * that of x.
     * <p>
     * If y[i] is +/-0, and x[i] is not 0 or NaN, z[i] is set to +/-0.
     * If y[i] is +/-inf, or x[i] is +/-0, z[i] is set to NaN.
     * If x[i] is +/-inf, and y is finite, z[i] is set to y[i].
     * <p>
     * Note that argument labels are switched with respect to the libm function
     * fmod().
     *
     * @param z (output) Output vector of size *n. z[i] is set to fmod(y[i], x[i]).
     * @param y (input)  Input vector of size *n, numerator in calculation.
     * @param x (input)  Input vector of size *n, denominator in calculation.
     * @param n (input)  The number of elements in the vectors x, y and z.
     * @see vvremainder
     */
    @Generated
    @CFunction
    public static native void vvfmod(DoublePtr arg1, ConstDoublePtr arg2, ConstDoublePtr arg3, ConstIntPtr arg4);

    /**
     * Calculates, elementwise, the difference between k*x and y, where
     * k is the nearest integer to y/x.
     * <p>
     * Specifically, the function calculates z=y-k*x, for the integer k nearest the
     * exact value of y/x, with ties rounded to even.
     * The result z satisfies abs(z) <= abs(x)/2.
     * <p>
     * If y-k*x is zero, it is given the same sign as y.
     * <p>
     * If y[i] is +/-inf, or x[i] is +/-0, z[i] is set to NaN.
     * If x[i] is +/-inf, and y is finite, z[i] is set to y[i].
     *
     * @param z (output) Output vector of size *n. z[i] is set to y[i]-k[i]*x[i].
     * @param y (input)  Input vector of size *n, numerator in calculation.
     * @param x (input)  Input vector of size *n, denominator in calculation.
     * @param n (input)  The number of elements in the vectors x, y and z.
     * @see vvfmodf
     */
    @Generated
    @CFunction
    public static native void vvremainderf(FloatPtr arg1, ConstFloatPtr arg2, ConstFloatPtr arg3, ConstIntPtr arg4);

    /**
     * Calculates, elementwise, the difference between k*x and y, where
     * k is the nearest integer to y/x.
     * <p>
     * Specifically, the function calculates z=y-k*x, for the integer k nearest the
     * exact value of y/x, with ties rounded to even.
     * The result z satisfies abs(z) <= abs(x)/2.
     * <p>
     * If y-k*x is zero, it is given the same sign as y.
     * <p>
     * If y[i] is +/-inf, or x[i] is +/-0, z[i] is set to NaN.
     * If x[i] is +/-inf, and y is finite, z[i] is set to y[i].
     *
     * @param z (output) Output vector of size *n. z[i] is set to y[i]-k[i]*x[i].
     * @param y (input)  Input vector of size *n, numerator in calculation.
     * @param x (input)  Input vector of size *n, denominator in calculation.
     * @param n (input)  The number of elements in the vectors x, y and z.
     * @see vvfmod
     */
    @Generated
    @CFunction
    public static native void vvremainder(DoublePtr arg1, ConstDoublePtr arg2, ConstDoublePtr arg3, ConstIntPtr arg4);

    /**
     * Copies, elementwise, the sign of x with the value of y, for two
     * vectors x and y.
     *
     * @param z (output) Output vector of size *n.
     *          z[i] is set to copysign(y[i], x[i]).
     * @param y (input)  Input vector of size *n, used for the magnitude.
     * @param x (input)  Input vector of size *n, used for the sign.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvcopysignf(FloatPtr arg1, ConstFloatPtr arg2, ConstFloatPtr arg3, ConstIntPtr arg4);

    /**
     * Copies, elementwise, the sign of x with the value of y, for two
     * vectors x and y.
     *
     * @param z (output) Output vector of size *n.
     *          z[i] is set to copysign(y[i], x[i]).
     * @param y (input)  Input vector of size *n, used for the magnitude.
     * @param x (input)  Input vector of size *n, used for the sign.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvcopysign(DoublePtr arg1, ConstDoublePtr arg2, ConstDoublePtr arg3, ConstIntPtr arg4);

    /**
     * Determines, elementwise, the next machine representable number
     * from y in the direction of x.
     *
     * @param z (output) Output vector of size *n.
     *          z[i] is set to nextafter(y[i], x[i]).
     * @param y (input)  Input vector of size *n, used for the magnitude.
     * @param x (input)  Input vector of size *n, used for the sign.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvnextafterf(FloatPtr arg1, ConstFloatPtr arg2, ConstFloatPtr arg3, ConstIntPtr arg4);

    /**
     * Determines, elementwise, the next machine representable number
     * from y in the direction of x.
     *
     * @param z (output) Output vector of size *n.
     *          z[i] is set to nextafter(y[i], x[i]).
     * @param y (input)  Input vector of size *n, used for the magnitude.
     * @param x (input)  Input vector of size *n, used for the sign.
     * @param n (input)  The number of elements in the vectors x, y and z.
     */
    @Generated
    @CFunction
    public static native void vvnextafter(DoublePtr arg1, ConstDoublePtr arg2, ConstDoublePtr arg3, ConstIntPtr arg4);

    /**
     * Calculates the base 2 logarithm for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log2(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvlog2f(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the base 2 logarithm for each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to log2(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvlog2(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the base 2 exponential function 2**x for each element
     * of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to exp2(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvexp2f(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the base 2 exponential function 2**x for each element
     * of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to exp2(x[i]).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvexp2(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the sine for pi times each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to sin(x[i]*PI).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsinpif(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the sine for pi times each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to sin(x[i]*PI).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvsinpi(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the cosine for pi times each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to cos(x[i]*PI).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvcospif(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the cosine for pi times each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to cos(x[i]*PI).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvcospi(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the tangent for pi times each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to tan(x[i]*PI).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvtanpif(FloatPtr arg1, ConstFloatPtr arg2, ConstIntPtr arg3);

    /**
     * Calculates the tangent for pi times each element of a vector.
     *
     * @param y (output) Output vector of size *n. y[i] is set to tan(x[i]*PI).
     * @param x (input)  Input vector of size *n.
     * @param n (input)  The number of elements in the vectors x and y.
     */
    @Generated
    @CFunction
    public static native void vvtanpi(DoublePtr arg1, ConstDoublePtr arg2, ConstIntPtr arg3);

    /**
     * [@function] vImageAlphaBlend_Planar8
     * <p>
     * Composite two non-premultiplied planar 8-bit images, to produce a non-premultiplied result.
     * <p>
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          float destColor = (  srcTopColor * srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha * srcBottomColor ) / alpha
     * @/textblock </pre>
     * alpha (the new alpha value for that pixel) is calculated as:
     * <pre>@textblock
     *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
     * @/textblock </pre>
     * For planar data, you need to calculate alpha yourself ahead of time and provide that as an argument to this function.
     * This can be done using:
     * <pre>@textblock
     *          vImagePremultipliedAlphaBlend_Planar8( srcTopAlpha, srcTopAlpha, srcBottomAlpha, alpha, kvImageNoFlags );
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The ARGB versions work for all 4 channel 8-bit / channel image formats with alpha first in memory.
     *
     * @param srcTop         The color image that is composited on top of the bottom image
     * @param srcTopAlpha    The alpha channel corresponding to the srcTop image
     * @param srcBottom      The color image that is below the srcTop image, into which it is blended
     * @param srcBottomAlpha The alpha channel corresponding to the srcBottom image
     * @param alpha          The alpha channel for the destination image. You need to calculate this ahead of time as:
     *                       <pre>@textblock
     *                                vImagePremultipliedAlphaBlend_Planar8( srcTopAlpha, srcTopAlpha, srcBottomAlpha, alpha, kvImageNoFlags );
     *                       @/textblock </pre>
     * @param dest           The non-premultiplied result will be written here.
     * @param flags          The following flags are allowed:
     *                       <pre>@textblock
     *                                kvImageNoFlags          Default operation
     *
     *                                kvImageDoNotTile        Disables internal multithreading. This may be useful if you are writing your own multithreaded tiling engine.
     *                        @/textblock</pre>
     * @return The following result codes may be returned:
     * <pre>@textblock
     *          kvImageNoError                      Success!
     *
     *          kvImageRoiLargerThanInputBuffer     The destination buffer must be no larger than srcTop, srcBottom, srcTopAlpha, srcBottomAlpha and alpha.
     *  @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAlphaBlend_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTopAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottomAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageAlphaBlend_PlanarF
     * <p>
     * Composite two non-premultiplied planar floating-point images, to produce a non-premultiplied result.
     * <p>
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          float destColor = (  srcTopColor * srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha * srcBottomColor ) / alpha
     * @/textblock </pre>
     * alpha (the new alpha value for that pixel) is calculated as:
     * <pre>@textblock
     *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
     * @/textblock </pre>
     * For planar data, you need to calculate alpha yourself ahead of time and provide that as an argument to this function.
     * This can be done using:
     * <pre>@textblock
     *          vImagePremultipliedAlphaBlend_PlanarF( srcTopAlpha, srcTopAlpha, srcBottomAlpha, alpha, kvImageNoFlags );
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The ARGB versions work for all 4 channel 8-bit / channel image formats with alpha first in memory.
     *
     * @param srcTop         The color image that is composited on top of the bottom image
     * @param srcTopAlpha    The alpha channel corresponding to the srcTop image
     * @param srcBottom      The color image that is below the srcTop image, into which it is blended
     * @param srcBottomAlpha The alpha channel corresponding to the srcBottom image
     * @param alpha          The alpha channel for the destination image. You need to calculate this ahead of time as:
     *                       <pre>@textblock
     *                                                vImagePremultipliedAlphaBlend_PlanarF( srcTopAlpha, srcTopAlpha, srcBottomAlpha, alpha, kvImageNoFlags );
     *                       @/textblock </pre>
     * @param dest           The non-premultiplied result will be written here.
     * @param flags          The following flags are allowed:
     *                       <pre>@textblock
     *                                kvImageNoFlags          Default operation
     *
     *                                kvImageDoNotTile        Disables internal multithreading. This may be useful if you are writing your own multithreaded tiling engine.
     *                        @/textblock</pre>
     * @return The following result codes may be returned:
     * <pre>@textblock
     *          kvImageNoError                      Success!
     *
     *          kvImageRoiLargerThanInputBuffer     The destination buffer must be no larger than srcTop, srcBottom, srcTopAlpha, srcBottomAlpha and alpha.
     *  @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAlphaBlend_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTopAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottomAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageAlphaBlend_ARGB8888
     * <p>
     * Composite two non-premultiplied ARGB8888 images, to produce a non-premultiplied result.
     * <p>
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          float destColor = (  srcTopColor * srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha * srcBottomColor ) / alpha
     * @/textblock </pre>
     * alpha (the new alpha value for that pixel) is calculated as:
     * <pre>@textblock
     *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
     * @/textblock </pre>
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The ARGB versions work for all 4 channel 8-bit / channel image formats with alpha first in memory.
     *
     * @param srcTop    The image that is composited on top of the bottom image. The alpha channel must appear first.
     * @param srcBottom The image that is below the srcTop image, into which it is blended. The alpha channel must appear first.
     * @param dest      The non-premultiplied result will be written here.
     * @param flags     The following flags are allowed:
     *                  <pre>@textblock
     *                           kvImageNoFlags          Default operation
     *
     *                           kvImageDoNotTile        Disables internal multithreading. This may be useful if you are writing your own multithreaded tiling engine.
     *                   @/textblock</pre>
     * @return The following result codes may be returned:
     * <pre>@textblock
     *          kvImageNoError                      Success!
     *
     *          kvImageRoiLargerThanInputBuffer     The destination buffer must be no larger than srcTop, srcBottom, srcTopAlpha, srcBottomAlpha and alpha.
     *  @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAlphaBlend_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageAlphaBlend_ARGBFFFF
     * <p>
     * Composite two non-premultiplied ARGBFFFF images, to produce a non-premultiplied result.
     * <p>
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          float destColor = (  srcTopColor * srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha * srcBottomColor ) / alpha
     * @/textblock </pre>
     * alpha (the new alpha value for that pixel) is calculated as:
     * <pre>@textblock
     *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
     * @/textblock </pre>
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The ARGB versions work for all 4 channel float / channel image formats with alpha first in memory.
     *
     * @param srcTop    The image that is composited on top of the bottom image. The alpha channel must appear first.
     * @param srcBottom The image that is below the srcTop image, into which it is blended. The alpha channel must appear first.
     * @param dest      The non-premultiplied result will be written here.
     * @param flags     The following flags are allowed:
     *                  <pre>@textblock
     *                           kvImageNoFlags          Default operation
     *
     *                           kvImageDoNotTile        Disables internal multithreading. This may be useful if you are writing your own multithreaded tiling engine.
     *                   @/textblock</pre>
     * @return The following result codes may be returned:
     * <pre>@textblock
     *          kvImageNoError                      Success!
     *
     *          kvImageRoiLargerThanInputBuffer     The destination buffer must be no larger than srcTop, srcBottom, srcTopAlpha, srcBottomAlpha and alpha.
     *  @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAlphaBlend_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlend_Planar8
     * <p>
     * blend two premultiplied Planar8 images to produce a premultiplied Planar8 result.
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          uint8_t destColor = srcTopColor  + ((255 - srcTopAlpha) * srcBottomColor + 127)/255;
     * @/textblock</pre>
     * Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0, 255].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param srcTop      The top image
     * @param srcTopAlpha The coverage component for the top image (alpha)
     * @param srcBottom   The bottom image
     * @param dest        The result image is written here. This buffer must be preallocated before the function is called.
     *                    <pre>@textblock
     *                         kvImageNoFlags      Default operation
     *
     *                         kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                             this in the context of your own multithreaded tiling engine.
     *                    @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlend_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTopAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlend_PlanarF
     * <p>
     * blend two premultiplied PlanarF images to produce a premultiplied PlanarF result.
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          float destColor = srcTopColor  + (1.0 - srcTopAlpha) * srcBottomColor;
     * @/textblock</pre>
     * Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0.0f, 1.0f].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param srcTop      The top image
     * @param srcTopAlpha The coverage component for the top image (alpha)
     * @param srcBottom   The bottom image
     * @param dest        The result image is written here. This buffer must be preallocated before the function is called.
     *                    <pre>@textblock
     *                         kvImageNoFlags      Default operation
     *
     *                         kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                             this in the context of your own multithreaded tiling engine.
     *                    @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlend_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTopAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlend_ARGB8888
     * <p>
     * blend two premultiplied ARGB8888 images to produce a premultiplied ARGB8888 result.
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          uint8_t destColor = srcTopColor  + ((255 - srcTopAlpha) * srcBottomColor + 127)/255;
     * @/textblock</pre>
     * Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0, 255].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The function will work for all 4 channel 8-bit / channel image formats with alpha first in memory, not just ARGB.
     *
     * @param srcTop    The top image
     * @param srcBottom The bottom image
     * @param dest      The result image is written here. This buffer must be preallocated before the function is called.
     * @param flags     The following flags may be used:
     *                  <pre>@textblock
     *                       kvImageNoFlags      Default operation
     *
     *                       kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                           this in the context of your own multithreaded tiling engine.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlend_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlend_BGRA8888
     * <p>
     * blend two premultiplied BGRA8888 images to produce a premultiplied BGRA8888 result.
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          uint8_t destColor = srcTopColor  + ((255 - srcTopAlpha) * srcBottomColor + 127)/255;
     * @/textblock</pre>
     * Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0, 255].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just BGRA.
     * Also available as vImagePremultipliedAlphaBlend_RGBA8888().
     *
     * @param srcTop    The top image
     * @param srcBottom The bottom image
     * @param dest      The result image is written here. This buffer must be preallocated before the function is called.
     * @param flags     The following flags may be used:
     *                  <pre>@textblock
     *                       kvImageNoFlags      Default operation
     *
     *                       kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                           this in the context of your own multithreaded tiling engine.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlend_BGRA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlend_ARGBFFFF
     * <p>
     * blend two premultiplied ARGBFFFF images to produce a premultiplied ARGBFFFF result.
     *
     * <pre>@textblock
     *          float destColor = srcTopColor  + (1.0 - srcTopAlpha) * srcBottomColor;
     * @/textblock</pre>
     * Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0.0f, 1.0f].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The function will work for all 4 channel float / channel image formats with alpha first in memory, not just ARGB.
     *
     * @param srcTop    The top image
     * @param srcBottom The bottom image
     * @param dest      The result image is written here. This buffer must be preallocated before the function is called.
     * @param flags     The following flags may be used:
     *                  <pre>@textblock
     *                       kvImageNoFlags      Default operation
     *
     *                       kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                           this in the context of your own multithreaded tiling engine.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlend_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlend_BGRAFFFF
     * <p>
     * blend two premultiplied ARGBFFFF images to produce a premultiplied BGRAFFFF result.
     *
     * <pre>@textblock
     *          float destColor = srcTopColor  + (1.0 - srcTopAlpha) * srcBottomColor;
     * @/textblock</pre>
     * Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0.0f, 1.0f].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The function will work for all 4 channel float / channel image formats with alpha first in memory, not just BGRA.
     * Also available as vImagePremultipliedAlphaBlend_RGBAFFFF.
     *
     * @param srcTop    The top image
     * @param srcBottom The bottom image
     * @param dest      The result image is written here. This buffer must be preallocated before the function is called.
     * @param flags     The following flags may be used:
     *                  <pre>@textblock
     *                       kvImageNoFlags      Default operation
     *
     *                       kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                           this in the context of your own multithreaded tiling engine.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlend_BGRAFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlendMultiply_RGBA8888
     * <p>
     * blend two premultiplied RGBA8888 images using the Multiply blend mode to produce a premultiplied RGBA8888 result.
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          uint8_t destColor =((255 -    srcTopAlpha) * srcBottomColor +
     *                              (255 - srcBottomAlpha) * srcTopColor +
     *                               srcTopColor * srcBottomColor + 127)/255;
     * @/textblock</pre>
     * The output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0, 255].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just RGBA.
     * This function corresponds to the multiply blend mode in feBlend in the SVG standard. http://www.w3.org/TR/SVG/filters.html)
     *
     * @param srcTop    The top image
     * @param srcBottom The bottom image
     * @param dest      The result image is written here. This buffer must be preallocated before the function is called.
     * @param flags     The following flags may be used:
     *                  <pre>@textblock
     *                       kvImageNoFlags      Default operation
     *
     *                       kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                           this in the context of your own multithreaded tiling engine.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlendMultiply_RGBA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlendScreen_RGBA8888
     * <p>
     * blend two premultiplied RGBA8888 images using the Screen blend mode to produce a premultiplied RGBA8888 result.
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          uint8_t destColor = CLAMP( srcTopColor + srcBottomcolor - (srcTopColor * srcBottomColor + 127)/255, 0, 255);
     * @/textblock</pre>
     * The output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0, 255].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just RGBA.
     * This function corresponds to the screen blend mode in feBlend in the SVG standard. http://www.w3.org/TR/SVG/filters.html)
     *
     * @param srcTop    The top image
     * @param srcBottom The bottom image
     * @param dest      The result image is written here. This buffer must be preallocated before the function is called.
     * @param flags     The following flags may be used:
     *                  <pre>@textblock
     *                       kvImageNoFlags      Default operation
     *
     *                       kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                           this in the context of your own multithreaded tiling engine.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlendScreen_RGBA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlendDarken_RGBA8888
     * <p>
     * blend two premultiplied RGBA8888 images using the Darken blend mode to produce a premultiplied RGBA8888 result.
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          uint8_t destColor = MIN( topColor +    ((255 - srcTopAlpha) *  srcBotomColor + 127) / 255,
     *                                   bottomColor + ((255 - srcBottomAlpha) * srcTopColor + 127) / 255);
     * @/textblock</pre>
     * The output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0, 255].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just RGBA.
     * This function corresponds to the darken blend mode in feBlend in the SVG standard. http://www.w3.org/TR/SVG/filters.html)
     *
     * @param srcTop    The top image
     * @param srcBottom The bottom image
     * @param dest      The result image is written here. This buffer must be preallocated before the function is called.
     * @param flags     The following flags may be used:
     *                  <pre>@textblock
     *                       kvImageNoFlags      Default operation
     *
     *                       kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                           this in the context of your own multithreaded tiling engine.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlendDarken_RGBA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedAlphaBlendLighten_RGBA8888
     * <p>
     * blend two premultiplied RGBA8888 images using the Lighten blend mode to produce a premultiplied RGBA8888 result.
     * <p>
     * For each color channel:
     * <pre>@textblock
     *          uint8_t destColor = MAX( topColor +    ((255 - srcTopAlpha) *  srcBotomColor + 127) / 255,
     *                                   bottomColor + ((255 - srcBottomAlpha) * srcTopColor + 127) / 255);
     * @/textblock</pre>
     * The output alpha channel (the new alpha value for that pixel) can be calculated as:
     * <pre>@textblock
     *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
     * @/textblock</pre>
     * The alpha values are presumed to be normalized over the range [0, 255].
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just RGBA.
     * This function corresponds to the lighten blend mode in feBlend in the SVG standard. http://www.w3.org/TR/SVG/filters.html)
     *
     * @param srcTop    The top image
     * @param srcBottom The bottom image
     * @param dest      The result image is written here. This buffer must be preallocated before the function is called.
     * @param flags     The following flags may be used:
     *                  <pre>@textblock
     *                       kvImageNoFlags      Default operation
     *
     *                       kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
     *                                           this in the context of your own multithreaded tiling engine.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedAlphaBlendLighten_RGBA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_Planar8
     * <p>
     * Multiply a Planar8 color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * <pre>@textblock
     *     For each color channel:
     *
     *         uint8_t destColor = (src * alpha + 127) / 255;
     *
     *     This function can work in place provided the following are true:
     *         For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     *         If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * @/textblock </pre>
     *
     * @param src   The color data to multiply with alpha
     * @param alpha The alpha data to multiply against src
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already  multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_PlanarF
     * <p>
     * Multiply a PlanarF color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * <pre>@textblock
     *     For each color channel:
     *
     *         float destColor = src * alpha;
     *
     *     This function can work in place provided the following are true:
     *         For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     *         If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * @/textblock </pre>
     *
     * @param src   The color data to multiply with alpha
     * @param alpha The alpha data to multiply against src
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already  multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_ARGB8888
     * <p>
     * Multiply a ARGB8888 color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * <pre>@textblock
     *     For each color channel:
     *
     *         uint8_t destColor = (src * alpha + 127) / 255;
     *         uint8_t destAlpha = alpha;
     *
     *     This function can work in place provided the following are true:
     *         If src overlaps with dest, src->data must be equal to dest->data
     *         If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *                 (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
     * @/textblock </pre>
     * <p>
     * This function will for all 4 channel 8-bit / channel image formats with alpha first in memory.
     * It does not have to be ARGB.
     *
     * @param src   The color data to multiply with alpha
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_ARGBFFFF
     * <p>
     * Multiply a ARGBFFFF color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * <pre>@textblock
     *     For each color channel:
     *
     *         float destColor = src * alpha;
     *         float destAlpha = alpha;
     *
     *     This function can work in place provided the following are true:
     *         If src overlaps with dest, src->data must be equal to dest->data
     *         If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *                 (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
     * @/textblock </pre>
     * <p>
     * This function will for all 4 channel float / channel image formats with alpha first in memory.
     * It does not have to be ARGB.
     *
     * @param src   The color data to multiply with alpha
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_RGBA8888
     * <p>
     * Multiply a RGBA8888 color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * <pre>@textblock
     *     For each color channel:
     *
     *         uint8_t destColor = (src * alpha + 127) / 255;
     *         uint8_t destAlpha = alpha;
     *
     *     This function can work in place provided the following are true:
     *         If src overlaps with dest, src->data must be equal to dest->data
     *         If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *                 (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
     * @/textblock </pre>
     * <p>
     * This function will for all 4 channel 8-bit / channel image formats with alpha last in memory.
     * It does not have to be RGBA. Also available as vImagePremultiplyData_BGRA8888().
     *
     * @param src   The color data to multiply with alpha
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_RGBA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_RGBAFFFF
     * <p>
     * Multiply a RGBAFFFF color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * <pre>@textblock
     *     For each color channel:
     *
     *         float destColor = src * alpha;
     *         float destAlpha = alpha;
     *
     *     This function can work in place provided the following are true:
     *         If src overlaps with dest, src->data must be equal to dest->data
     *         If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *                 (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
     * @/textblock </pre>
     * <p>
     * This function will for all 4 channel float / channel image formats with alpha first in memory.
     * It does not have to be RGBA. Also available as vImagePremultiplyData_BGRAFFFF().
     *
     * @param src   The color data to multiply with alpha
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_RGBAFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_ARGB16U
     * <p>
     * Multiply a unsigned 16-bit ARGB color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * <pre>@textblock
     *     For each color channel:
     *
     *         uint16_t destColor = (src * alpha + 32767) / 65535;
     *         uint16_t destAlpha = alpha;
     *
     *     This function can work in place provided the following are true:
     *         If src overlaps with dest, src->data must be equal to dest->data
     *         If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *                 (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
     * @/textblock </pre>
     * <p>
     * This function will for all 4 channel uint16_t / channel image formats with alpha first in memory.
     * It does not have to be ARGB.
     *
     * @param src   The color data to multiply with alpha
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_ARGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_RGBA16U
     * <p>
     * Multiply a unsigned 16-bit RGBA color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * <pre>@textblock
     *     For each color channel:
     *
     *         uint16_t destColor = (src * alpha + 32767) / 65535;
     *         uint16_t destAlpha = alpha;
     *
     *     This function can work in place provided the following are true:
     *         If src overlaps with dest, src->data must be equal to dest->data
     *         If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *                 (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
     * @/textblock </pre>
     * <p>
     * This function will for all 4 channel uint16_t / channel image formats with alpha last in memory.
     * It does not have to be RGBA. Also available as vImagePremultiplyData_BGRA16U().
     *
     * @param src   The color data to multiply with alpha
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_RGBA16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_ARGB16Q12
     * <p>
     * Multiply a signed 16Q12 fixed-point ARGB color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * For each color in each pixel:
     * <pre>@textblock
     *         int16_t destColor = CLAMP((src * alpha + 2048) / 4096, INT16_MIN, INT16_MAX);
     *         int16_t destAlpha = alpha;
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * If src overlaps with dest, src->data must be equal to dest->data
     * If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
     * <p>
     * This function will for other 4 channel 16Q12 / channel image formats with alpha first in memory.
     * It does not have to be ARGB.
     *
     * @param src   The color data to multiply with alpha
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_ARGB16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultiplyData_RGBA16Q12
     * <p>
     * Multiply a signed 16Q12 RGBA color channel by its corresponding alpha
     * <p>
     * This function multiplies color channels by the alpha channel.
     * For each color in each pixel:
     * <pre>@textblock
     *         int16_t destColor = CLAMP((src * alpha + 2048) / 4096, INT16_MIN, INT16_MAX);
     *         int16_t destAlpha = alpha;
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * If src overlaps with dest, src->data must be equal to dest->data
     * If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
     * <p>
     * This function will for all 4 channel 16Q12 / channel image formats with alpha last in memory.
     * It does not have to be RGBA.
     *
     * @param src   The color data to multiply with alpha
     * @param dest  A preallocated vImage_Buffer where the results are written
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                      kvImageNoFlags                      Default operation
     *
     *                      kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
     *                                                          the work in your own tiling engine.
     *              @/textblock </pre>
     * @return The following result codes may occur:
     * <pre>@textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
     *                                             dimensions in src and alpha
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultiplyData_RGBA16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_Planar8
     * <p>
     * Divide alpha from a premultiplied Planar8 images
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         uint8_t destColor = ( MIN(src_color, alpha) * 255 + alpha/2) / alpha;
     * @/textblock </pre>
     * ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
     * In the division by zero case, the returned color value is 0.
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data.
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param src   The planar8 input color channel
     * @param alpha The planar8 input alpha channel
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_PlanarF
     * <p>
     * Divide alpha from a premultiplied PlanarF images
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         float destColor = destColor / alpha;   // according to current rounding mode
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data.
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param src   The planarF input color channel
     * @param alpha The planarF input alpha channel
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_ARGB8888
     * <p>
     * Divide the alpha channel from the color channels in a ARGB8888 image
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         uint8_t destColor = ( MIN(src_color, alpha) * 255 + alpha/2) / alpha;
     *         uint8_t destAlpha = alpha;
     *     @/textblock </pre>
     * <p>
     * ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
     * In the division by zero case, the returned color value is 0.
     * <p>
     * The positioning of only the alpha channel is important for interleaved formats for these functions.
     * This function will work with other channel orders that have alpha first.
     * <p>
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data
     * src->rowBytes must be equal to dest->rowBytes
     *
     * @param src   The input inmage
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_RGBA8888
     * <p>
     * Divide the alpha channel from the color channels in a RGBA8888 image
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         uint8_t destColor = ( MIN(src_color, alpha) * 255 + alpha/2) / alpha;
     *         uint8_t destAlpha = alpha;
     *     @/textblock </pre>
     * <p>
     * ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
     * In the division by zero case, the returned color value is 0.
     * <p>
     * The positioning of only the alpha channel is important for interleaved formats for these functions.
     * This function will work with other channel orders that have alpha last. The function is also available as vImageUnpremultiplyData_BGRA8888.
     * <p>
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data
     * src->rowBytes must be equal to dest->rowBytes
     *
     * @param src   The input inmage
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_RGBA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_ARGBFFFF
     * <p>
     * Divide the alpha channel from the color channels in a ARGBFFFF image
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         float destColor = destColor / alpha;
     *         float destAlpha = alpha;
     *     @/textblock </pre>
     * <p>
     * The positioning of only the alpha channel is important for interleaved formats for these functions.
     * This function will work with other channel orders that have alpha first.
     * <p>
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data
     * src->rowBytes must be equal to dest->rowBytes
     *
     * @param src   The input inmage
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_RGBAFFFF
     * <p>
     * Divide the alpha channel from the color channels in a RGBAFFFF image
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         float destColor = destColor / alpha;
     *         float destAlpha = alpha;
     *     @/textblock </pre>
     * <p>
     * The positioning of only the alpha channel is important for interleaved formats for these functions.
     * This function will work with other channel orders that have alpha last. It is also available as vImageUnpremultiplyData_BGRAFFFF().
     * <p>
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data
     * src->rowBytes must be equal to dest->rowBytes
     *
     * @param src   The input inmage
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_RGBAFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_ARGB16U
     * <p>
     * Divide the alpha channel from the color channels in a ARGB16U image
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         uint16_t destColor = ( MIN(src_color, alpha) * 65535 + alpha/2) / alpha;
     *         uint16_t destAlpha = alpha;
     *     @/textblock </pre>
     * <p>
     * ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
     * In the division by zero case, the returned color value is 0.
     * <p>
     * The positioning of only the alpha channel is important for interleaved formats for these functions.
     * This function will work with other channel orders that have alpha first.
     * <p>
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data
     * src->rowBytes must be equal to dest->rowBytes
     *
     * @param src   The input inmage
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_ARGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_RGBA16U
     * <p>
     * Divide the alpha channel from the color channels in a RGBA16U image
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         uint16_t destColor = ( MIN(src_color, alpha) * 65535 + alpha/2) / alpha;
     *         uint16_t destAlpha = alpha;
     *     @/textblock </pre>
     * <p>
     * ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
     * In the division by zero case, the returned color value is 0.
     * <p>
     * The positioning of only the alpha channel is important for interleaved formats for these functions.
     * This function will work with other channel orders that have alpha last. The function is also available as vImageUnpremultiplyData_BGRA16U.
     * <p>
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data
     * src->rowBytes must be equal to dest->rowBytes
     *
     * @param src   The input inmage
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_RGBA16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_ARGB16Q12
     * <p>
     * Divide the alpha channel from the color channels in a ARGB16Q12 image
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         int16_t destColor = ( MIN(src_color, alpha) * 4096 + alpha/2) / alpha;
     *         int16_t destAlpha = alpha;
     *     @/textblock </pre>
     * <p>
     * ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
     * In the division by zero case, the returned color value is 0.
     * <p>
     * The positioning of only the alpha channel is important for interleaved formats for these functions.
     * This function will work with other channel orders that have alpha first.
     * <p>
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data
     * src->rowBytes must be equal to dest->rowBytes
     *
     * @param src   The input inmage
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_ARGB16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageUnpremultiplyData_RGBA16Q12
     * <p>
     * Divide the alpha channel from the color channels in a RGBA16Q12 image
     * <p>
     * This function divides color channels by the alpha channel.
     * For each color channel:
     * <pre>@textblock
     *         int16_t destColor = ( MIN(src_color, alpha) * 4096 + alpha/2) / alpha;
     *         int16_t destAlpha = alpha;
     *     @/textblock </pre>
     * <p>
     * ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
     * In the division by zero case, the returned color value is 0.
     * <p>
     * The positioning of only the alpha channel is important for interleaved formats for these functions.
     * This function will work with other channel orders that have alpha last.
     * <p>
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data
     * src->rowBytes must be equal to dest->rowBytes
     *
     * @param src   The input inmage
     * @param dest  A preallocated planar8 destination buffer into which the result will be written.'
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                                  kvImageNoFlags          Default operation
     *
     *                                  kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *                     kvImageNoError                      Success
     *
     *                     kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageUnpremultiplyData_RGBA16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedConstAlphaBlend_Planar8
     * <p>
     * Blend two Planar8 premultiplied images with an extra image-wide alpha for the top image
     * <p>
     * This is a premultiplied alpha compositing function using a constant for alpha over the whole image.
     * Color data from both images is presumed to be already premultiplied by its own per-pixel alpha.
     * For calculations involving 8-bit integer data, the calculation is done with an additional rounding step
     * followed by division by 255:
     * <pre>@textblock
     *          uint8_t destColor = (srcTopColor * constAlpha * 255  + (255*255 - srcTopAlpha * constAlpha) * srcBottomColor + 127*255) / (255*255);
     *          uint8_t destAlpha =  (srcTopAlpha * constAlpha * 255 + (255*255 - srcTopAlpha * constAlpha) * srcBottomAlpha + 127*255 ) / (255*255);
     * @/textblock</pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param srcTop      The top image
     * @param constAlpha  An extra alpha to apply to the entire top image
     * @param srcTopAlpha The alpha channel for the top image
     * @param srcBottom   The bottom image
     * @param dest        A preallocate vImage_Buffer where the result will be written
     * @param flags       The following flags are allowed:
     *                    <pre>@textblock
     *                             kvImageNoFlags          Default operation
     *
     *                             kvImageDoNotTile        Turn off internal multithreading
     *                    @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *          kvImageNoError                      Success
     *
     *          kvImageRoiLargerThanInputBuffer     The destination buffer height or width is larger than the corresponding dimension in
     *                                              srcTop, srcTopAlpha or srcBottom
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedConstAlphaBlend_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop, byte constAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTopAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedConstAlphaBlend_PlanarF
     * <p>
     * Blend two PlanarF premultiplied images with an extra image-wide alpha for the top image
     * <p>
     * This is a premultiplied alpha compositing function using a constant for alpha over the whole image.
     * Color data from both images is presumed to be already premultiplied by its own per-pixel alpha.
     * <pre>@textblock
     *          float destColor = srcTopColor * constAlpha  + (1.0 - srcTopAlpha  * constAlpha) * srcBottomColor;
     *          float alpha =  srcTopAlpha * constAlpha + (1.0 - srcTopAlpha * constAlpha) * srcBottomAlpha
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param srcTop      The top image
     * @param constAlpha  An extra alpha to apply to the entire top image
     * @param srcTopAlpha The alpha channel for the top image
     * @param srcBottom   The bottom image
     * @param dest        A preallocate vImage_Buffer where the result will be written
     * @param flags       The following flags are allowed:
     *                    <pre>@textblock
     *                             kvImageNoFlags          Default operation
     *
     *                             kvImageDoNotTile        Turn off internal multithreading
     *                    @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *          kvImageNoError                      Success
     *
     *          kvImageRoiLargerThanInputBuffer     The destination buffer height or width is larger than the corresponding dimension in
     *                                              srcTop, srcTopAlpha or srcBottom
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedConstAlphaBlend_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop, float constAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTopAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedConstAlphaBlend_ARGB8888
     * <p>
     * Blend two ARGB8888 premultiplied images with an extra image-wide alpha for the top image
     * <p>
     * This is a premultiplied alpha compositing function using a constant for alpha over the whole image.
     * Color data from both images is presumed to be already premultiplied by its own per-pixel alpha.
     * For calculations involving 8-bit integer data, the calculation is done with an additional rounding step
     * followed by division by 255:
     * <pre>@textblock
     *          uint8_t destColor = (srcTopColor * constAlpha * 255  + (255*255 - srcTopAlpha * constAlpha) * srcBottomColor + 127*255) / (255*255);
     *          uint8_t destAlpha =  (srcTopAlpha * constAlpha * 255 + (255*255 - srcTopAlpha * constAlpha) * srcBottomAlpha + 127*255 ) / (255*255);
     * @/textblock</pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The  function will work for all 4 channel 8-bit / channel image formats with alpha first in memory, not just ARGB.
     *
     * @param srcTop     The top image
     * @param constAlpha An extra alpha to apply to the entire top image
     * @param srcBottom  The bottom image
     * @param dest       A preallocate vImage_Buffer where the result will be written
     * @param flags      The following flags are allowed:
     *                   <pre>@textblock
     *                            kvImageNoFlags          Default operation
     *
     *                            kvImageDoNotTile        Turn off internal multithreading
     *                   @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *          kvImageNoError                      Success
     *
     *          kvImageRoiLargerThanInputBuffer     The destination buffer height or width is larger than the corresponding dimension in
     *                                              srcTop, srcTopAlpha or srcBottom
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedConstAlphaBlend_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop, byte constAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImagePremultipliedConstAlphaBlend_ARGBFFFF
     * <p>
     * Blend two ARGBFFFF premultiplied images with an extra image-wide alpha for the top image
     * <p>
     * This is a premultiplied alpha compositing function using a constant for alpha over the whole image.
     * Color data from both images is presumed to be already premultiplied by its own per-pixel alpha.
     * For calculations involving 8-bit integer data, the calculation is done with an additional rounding step
     * followed by division by 255:
     * <pre>@textblock
     *          float destColor = srcTopColor * constAlpha  + (1.0 - srcTopAlpha  * constAlpha) * srcBottomColor;
     *          float alpha =  srcTopAlpha * constAlpha + (1.0 - srcTopAlpha * constAlpha) * srcBottomAlpha
     * @/textblock</pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * The function will work for all 4 channel float / channel image formats with alpha first in memory, not just ARGB.
     *
     * @param srcTop     The top image
     * @param constAlpha An extra alpha to apply to the entire top image
     * @param srcBottom  The bottom image
     * @param dest       A preallocate vImage_Buffer where the result will be written
     * @param flags      The following flags are allowed:
     *                   <pre>@textblock
     *                            kvImageNoFlags          Default operation
     *
     *                            kvImageDoNotTile        Turn off internal multithreading
     *                   @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *          kvImageNoError                      Success
     *
     *          kvImageRoiLargerThanInputBuffer     The destination buffer height or width is larger than the corresponding dimension in
     *                                              srcTop, srcTopAlpha or srcBottom
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePremultipliedConstAlphaBlend_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop, float constAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageAlphaBlend_NonpremultipliedToPremultiplied_Planar8
     * <p>
     * Blend a non-premultiplied top Planar8 image into a premultiplied Planar8 bottom image and return a premultiplied Planar8 result.
     * <p>
     * Top buffer is non-premultiplied. Bottom buffer is premultiplied. Dest buffer is premultiplied. Works in place.
     * <pre>@textblock
     *      result = (srcTop * srctopAlpha + (255 - srcTopAlpha) * bottomAlpha + 127 ) / 255;
     * @/textblock </pre>
     * This function will work in place as long as the src and dest buffer overlap exactly.
     * The src buffers must be at least as large as the dest buffer in each dimension. (src.height >= dest.height && src.width >= dest.width)
     * <p>
     * To calculate the alpha result for the Planar cases, use
     * <pre>@textblock
     *      vImagePremultipliedAlphaBlend_Planar8( srcTopAlpha, srcTopAlpha, srcBottomAlpha, dest, flags );
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param srcTop      Planar8 non-premultiplied color channel for top image
     * @param srcTopAlpha Planar8 alpha channel for top image
     * @param srcBottom   Planar8 premultiplied color channel for bottom image
     * @param dest        Planar8 premultiplied result. Must be preallocated before the call is made.
     * @param flags       The following flags are allowed:
     *                    <pre> @textblock
     *                             kvImageNoFlags          Default operation.
     *
     *                             kvImageDoNotTile        Disable internal multithreading.
     *                         @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
     *      @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAlphaBlend_NonpremultipliedToPremultiplied_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTopAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageAlphaBlend_NonpremultipliedToPremultiplied_PlanarF
     * <p>
     * Blend a non-premultiplied top PlanarF image into a premultiplied PlanarF bottom image and return a premultiplied PlanarF result.
     * <p>
     * Top buffer is non-premultiplied. Bottom buffer is premultiplied. Dest buffer is premultiplied. Works in place.
     * <pre>@textblock
     *      result = srcTop * srcTopAlpha + (1 - srcTopAlpha) * srcBottom
     * @/textblock </pre>
     * This function will work in place as long as the src and dest buffer overlap exactly.
     * The src buffers must be at least as large as the dest buffer in each dimension. (src.height >= dest.height && src.width >= dest.width)
     * <p>
     * To calculate the alpha result for the Planar cases, use
     * <pre>@textblock
     *      vImagePremultipliedAlphaBlend_PlanarF( srcTopAlpha, srcTopAlpha, srcBottomAlpha, dest, flags );
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param srcTop      Planar8 non-premultiplied color channel for top image
     * @param srcTopAlpha Planar8 alpha channel for top image
     * @param srcBottom   Planar8 premultiplied color channel for bottom image
     * @param dest        Planar8 premultiplied result. Must be preallocated before the call is made.
     * @param flags       The following flags are allowed:
     *                    <pre> @textblock
     *                             kvImageNoFlags          Default operation.
     *
     *                             kvImageDoNotTile        Disable internal multithreading.
     *                         @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
     *      @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAlphaBlend_NonpremultipliedToPremultiplied_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTopAlpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGB8888
     * <p>
     * Blend a non-premultiplied top ARGB8888 image into a premultiplied ARGB8888 bottom image and return a premultiplied ARGB8888 result.
     * <p>
     * Top buffer is non-premultiplied. Bottom buffer is premultiplied. Dest buffer is premultiplied. Works in place.
     * <pre>@textblock
     *      result = (srcTop * srctopAlpha + (255 - srcTopAlpha) * bottomAlpha + 127 ) / 255;
     * @/textblock </pre>
     * This function will work in place as long as the src and dest buffer overlap exactly.
     * The src buffers must be at least as large as the dest buffer in each dimension. (src.height >= dest.height && src.width >= dest.width)
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * This function will work with any channel order with alpha first, not just ARGB.
     *
     * @param srcTop    Planar8 non-premultiplied color channel for top image
     * @param srcBottom Planar8 premultiplied color channel for bottom image
     * @param dest      Planar8 premultiplied result. Must be preallocated before the call is made.
     * @param flags     The following flags are allowed:
     *                  <pre> @textblock
     *                           kvImageNoFlags          Default operation.
     *
     *                           kvImageDoNotTile        Disable internal multithreading.
     *                       @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
     *      @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGBFFFF
     * <p>
     * Blend a non-premultiplied top ARGBFFFF image into a premultiplied ARGBFFFF bottom image and return a premultiplied ARGBFFFF result.
     * <p>
     * Top buffer is non-premultiplied. Bottom buffer is premultiplied. Dest buffer is premultiplied. Works in place.
     * <pre>@textblock
     *      result = srcTop * srcTopAlpha + (1 - srcTopAlpha) * srcBottom
     * @/textblock </pre>
     * This function will work in place as long as the src and dest buffer overlap exactly.
     * The src buffers must be at least as large as the dest buffer in each dimension. (src.height >= dest.height && src.width >= dest.width)
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * This function will work with any channel order with alpha first, not just ARGB.
     *
     * @param srcTop    Planar8 non-premultiplied color channel for top image
     * @param srcBottom Planar8 premultiplied color channel for bottom image
     * @param dest      Planar8 premultiplied result. Must be preallocated before the call is made.
     * @param flags     The following flags are allowed:
     *                  <pre> @textblock
     *                           kvImageNoFlags          Default operation.
     *
     *                           kvImageDoNotTile        Disable internal multithreading.
     *                       @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *          kvImageNoError                      Success.
     *
     *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
     *      @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcTop,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcBottom,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageClipToAlpha_Planar8
     * <p>
     * Clamp a Planar8 color buffer to be less than or equal to alpha
     * <p>
     * For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
     * <pre>@textblock
     *         color_result = MIN( color, alpha )
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param src   The color image to clip
     * @param alpha The alpha channel
     * @param dest  A preallocated buffer to receive the results.
     * @param flags The following flags are allowed:
     *              <pre> @textblock
     *                      kvImageNoFlags          Default operation.
     *
     *                      kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                             dimensions in srcTop, srcTopAlpha and srcBottom.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageClipToAlpha_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageClipToAlpha_PlanarF
     * <p>
     * Clamp a PlanarF color buffer to be less than or equal to alpha
     * <p>
     * For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
     * <pre>@textblock
     *         color_result = MIN( color, alpha )
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param src   The color image to clip
     * @param alpha The alpha channel
     * @param dest  A preallocated buffer to receive the results.
     * @param flags The following flags are allowed:
     *              <pre> @textblock
     *                      kvImageNoFlags          Default operation.
     *
     *                      kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                             dimensions in srcTop, srcTopAlpha and srcBottom.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageClipToAlpha_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageClipToAlpha_ARGB8888
     * <p>
     * Clamp a ARGB8888 color buffer to be less than or equal to alpha
     * <p>
     * For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
     * <pre>@textblock
     *         alpha_result = alpha
     *         color_result = MIN( color, alpha )
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * This function will work for any channel order with alpha first, not just ARGB.
     *
     * @param src   The color image to clip
     * @param dest  A preallocated buffer to receive the results.
     * @param flags The following flags are allowed:
     *              <pre> @textblock
     *                      kvImageNoFlags          Default operation.
     *
     *                      kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                             dimensions in srcTop, srcTopAlpha and srcBottom.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageClipToAlpha_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageClipToAlpha_ARGBFFFF
     * <p>
     * Clamp a ARGBFFFF color buffer to be less than or equal to alpha
     * <p>
     * For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
     * <pre>@textblock
     *         alpha_result = alpha
     *         color_result = MIN( color, alpha )
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * This function will work for any channel order with alpha first, not just ARGB.
     *
     * @param src   The color image to clip
     * @param dest  A preallocated buffer to receive the results.
     * @param flags The following flags are allowed:
     *              <pre> @textblock
     *                      kvImageNoFlags          Default operation.
     *
     *                      kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                             dimensions in srcTop, srcTopAlpha and srcBottom.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageClipToAlpha_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageClipToAlpha_RGBA8888
     * <p>
     * Clamp a RGBA8888 color buffer to be less than or equal to alpha
     * <p>
     * For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
     * <pre>@textblock
     *         alpha_result = alpha
     *         color_result = MIN( color, alpha )
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * This function will work for any channel order with alpha last, not just RGBA. Also available as vImageClipToAlpha_BGRA8888().
     *
     * @param src   The color image to clip
     * @param dest  A preallocated buffer to receive the results.
     * @param flags The following flags are allowed:
     *              <pre> @textblock
     *                      kvImageNoFlags          Default operation.
     *
     *                      kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                             dimensions in srcTop, srcTopAlpha and srcBottom.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageClipToAlpha_RGBA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageClipToAlpha_RGBAFFFF
     * <p>
     * Clamp a RGBAFFFF color buffer to be less than or equal to alpha
     * <p>
     * For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
     * <pre>@textblock
     *         alpha_result = alpha
     *         color_result = MIN( color, alpha )
     * @/textblock </pre>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * This function will work for any channel order with alpha last, not just RGBA. Also available as vImageClipToAlpha_BGRAFFFF().
     *
     * @param src   The color image to clip
     * @param dest  A preallocated buffer to receive the results.
     * @param flags The following flags are allowed:
     *              <pre> @textblock
     *                      kvImageNoFlags          Default operation.
     *
     *                      kvImageDoNotTile        Disable internal multithreading.
     *                  @/textblock </pre>
     * @return The following error codes may occur:
     * <pre> @textblock
     *         kvImageNoError                      Success.
     *
     *         kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
     *                                             dimensions in srcTop, srcTopAlpha and srcBottom.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageClipToAlpha_RGBAFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvolve_Planar8
     * <p>
     * General convolution on a Planar8 image.
     * <p>
     * This filter applies a convolution filter of your choosing to a Planar8 image.
     * For each pixel:
     * <pre>@textblock
     *         for each pixel[y][x] in image{
     *             int sum = 0;
     *
     *             // Calculate weighted average over kernel area
     *             for each kernel_element[i][j] in kernel{
     *                 sum += kernel_element[i][j] *
     *                         pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                              [x+j+srcOffsetToROI_X- kernel_width/2];
     *             }
     *             // Correct for the scaling introduced by multiplying by the weights table
     *             sum = (sum + divisor/2) / divisor;
     *
     *             // write out result
     *             result[y][x] = CLAMP(sum, 0, 255);
     *         }
     *     @/textblock </pre>
     * (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
     * However, in practice it is passed in as a contiguous 1D array of size kernel_height *
     * kernel_width.)
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
     *                         For example, for a simple 3x3 blur, it might be:
     *                         <pre>@textblock
     *                                                 const int16_t kernel[9] = { 1, 2, 1,
     *                                                                             2, 4, 2,
     *                                                                             1, 2, 1 };
     *                                                 @/textblock </pre>
     *                         <p>
     *                         The kernel values may not sum in any combination to be outside the range
     *                         [-2**23, 2**23), or modulo overflow in the accumulator may result.
     * @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param divisor          The weighted sum of nearby pixels is typically a large number, which must be corrected
     *                         to fit back into the image format of the destination image. The correction factor
     *                         is passed in as divisor here, and is divided from the sum before the result is
     *                         returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
     *                         is 0, 1 will be used instead.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageNullPointerArgument  kernel may not be NULL
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvolve_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstShortPtr kernel, int kernel_height,
            int kernel_width, int divisor, byte backgroundColor, int flags);

    /**
     * [@function] vImageConvolve_PlanarF
     * <p>
     * General convolution on a PlanarF image.
     * <p>
     * This filter applies a convolution filter of your choosing to a PlanarF image.
     * For each pixel:
     * <pre>@textblock
     *         for each pixel[y][x] in image{
     *             float sum = 0;
     *
     *             // Calculate weighted average over kernel area
     *             for each kernel_element[i][j] in kernel{
     *                 sum += kernel_element[i][j] *
     *                         pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                              [x+j+srcOffsetToROI_X- kernel_width/2];
     *             }
     *
     *             // write out result
     *             result[y][x] = sum;
     *         }
     *     @/textblock </pre>
     * (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
     * However, in practice it is passed in as a contiguous 1D array of size kernel_height *
     * kernel_width.)
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
     *                         For example, for a simple 3x3 blur, it might be:
     *                         <pre>@textblock
     *                                                 const float kernel[9] =   { 1./16, 2./16, 1./16,
     *                                                                             2./16, 4./16, 2./16,
     *                                                                             1./16, 2./16, 1./16 };
     *                                                 @/textblock </pre>
     * @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageNullPointerArgument  kernel may not be NULL
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvolve_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernel, int kernel_height,
            int kernel_width, float backgroundColor, int flags);

    /**
     * [@function] vImageConvolveWithBias_Planar8
     * <p>
     * General convolution on a Planar8 image with added bias.
     * <p>
     * This filter applies a convolution filter of your choosing to a Planar8 image.
     * For each pixel:
     * <pre>@textblock
     *         for each pixel[y][x] in image{
     *             int sum = 0;
     *
     *             // Calculate weighted average over kernel area
     *             for each kernel_element[i][j] in kernel{
     *                 sum += kernel_element[i][j] *
     *                         pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                              [x+j+srcOffsetToROI_X- kernel_width/2];
     *             }
     *             // Correct for the scaling introduced by multiplying by the weights table
     *             sum = (sum + bias) / divisor;
     *
     *             // write out result
     *             result[y][x] = CLAMP(sum, 0, 255);
     *         }
     *     @/textblock </pre>
     * (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
     * However, in practice it is passed in as a contiguous 1D array of size kernel_height *
     * kernel_width.)
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
     *                         For example, for a simple 3x3 blur, it might be:
     *                         <pre>@textblock
     *                                                 const int16_t kernel[9] = { 1, 2, 1,
     *                                                                             2, 4, 2,
     *                                                                             1, 2, 1 };
     *                                                 @/textblock </pre>
     *                         <p>
     *                         The kernel values may not sum in any combination to be outside the range
     *                         [-2**23, 2**23), or modulo overflow in the accumulator may result.
     * @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param divisor          The weighted sum of nearby pixels is typically a large number, which must be corrected
     *                         to fit back into the image format of the destination image. The correction factor
     *                         is passed in as divisor here, and is divided from the sum before the result is
     *                         returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
     *                         is 0, 1 will be used instead.
     * @param bias             This value is added to the sum of weighted pixels before the divisor is applied.
     *                         It can serve to both control rounding and adjust the brightness of the result.
     *                         A large bias (e.g 128 * divisor) may be required for some kernels to return
     *                         representable results, such as edge detection filters.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageNullPointerArgument  kernel may not be NULL
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvolveWithBias_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstShortPtr kernel, int kernel_height,
            int kernel_width, int divisor, int bias, byte backgroundColor, int flags);

    /**
     * [@function] vImageConvolveWithBias_PlanarF
     * <p>
     * General convolution on a PlanarF image with added bias.
     * <p>
     * This filter applies a convolution filter of your choosing to a PlanarF image.
     * For each pixel:
     * <pre>@textblock
     *         for each pixel[y][x] in image{
     *             float sum = bias;
     *
     *             // Calculate weighted average over kernel area
     *             for each kernel_element[i][j] in kernel{
     *                 sum += kernel_element[i][j] *
     *                         pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                              [x+j+srcOffsetToROI_X- kernel_width/2];
     *             }
     *
     *             // write out result
     *             result[y][x] = sum;
     *         }
     *     @/textblock </pre>
     * (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
     * However, in practice it is passed in as a contiguous 1D array of size kernel_height *
     * kernel_width.)
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
     *                         For example, for a simple 3x3 blur, it might be:
     *                         <pre>@textblock
     *                                                 const float kernel[9] =   { 1./16, 2./16, 1./16,
     *                                                                             2./16, 4./16, 2./16,
     *                                                                             1./16, 2./16, 1./16 };
     *                                                 @/textblock </pre>
     * @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param bias             This value is added to the sum of weighted pixels.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageNullPointerArgument  kernel may not be NULL
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvolveWithBias_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernel, int kernel_height,
            int kernel_width, float bias, float backgroundColor, int flags);

    /**
     * [@function] vImageRichardsonLucyDeConvolve_Planar8
     * <p>
     * Perform N iterations of a Lucy-Richardson deconvolution on Planar8 data
     * <p>
     * This routine iteratively uses the following formula:
     * <pre>@textblock
     *        e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )
     *
     *        where:
     *              e[0] = the observed image (src parameter)
     *              e[n] = the result of the nth iteration
     *              psf  = point spread function (kernel for call to convolution)
     *                x    = multiply operator
     *              '*'  = convolution operator
     *      @/textblock </pre>
     * <p>
     * The work in these functions is currently done internally with floating point precision. If you plan to call this function multiple times
     * (rather than with iterationCount > 1) on 8-bit per channel images, you can save some computation by converting the 8-bit image data to
     * single precision floating-point yourself using something like vImageConvert_Planar8toPlanarF and iterating on the appropriate
     * floating-point Richardson Lucy variant. Convert back, when you are done.
     * <p>
     * Does not work in place.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
     *                         For example, for a simple 3x3 blur, it might be:
     *                         <pre>@textblock
     *                                                  const int16_t kernel[9] = { 1, 2, 1,
     *                                                                              2, 4, 2,
     *                                                                              1, 2, 1 };
     *                                                  @/textblock </pre>
     *                         <p>
     *                         This is psf0 in the formula given in the discussion.
     * @param kernel2          A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
     *                         This is psf1 in the formula given in the discussion.
     * @param kernel_height    The height of the 2D table of weights passed in as kernel1. It must be an odd number.
     * @param kernel_width     The width of the 2D table of weights passed in as kernel1. It must be an odd number.
     * @param kernel_height2   The height of the 2D table of weights passed in as kernel2. It must be an odd number.
     * @param kernel_width2    The width of the 2D table of weights passed in as kernel2. It must be an odd number.
     * @param divisor          The divisor to use to correct for the volume under kernel.
     * @param divisor2         The divisor to use to correct for the volume under kernel2.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param iterationCount   The number of Richardson-Lucy iterations to perform on the data before returning.
     *                         If 0, the src buffer is coped to dest.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                      kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                  copy the corresponding source pixel to the destination. This
     *                                                                  will result in a ring off unconvolved content at the edges
     *                                                                  and convolved content in the middle.
     *
     *                                      kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                  For a blur filter this will look like the edges of the image
     *                                                                  have been blurred into a particular color. This is usually
     *                                                                  appropriate when the color of the surface onto which the image
     *                                                                  will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                  as a background color, and let the downstream image compositor
     *                                                                  blend in the background color. In this case, the result image
     *                                                                  should be treated as a premultiplied image.
     *
     *                                      kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                  This is better when the image is drawn into a frame or other
     *                                                                  context where the background is not expected to contribute to
     *                                                                  the final content.
     *
     *                                      kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                  simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                  Because of the complication at the edges, this edging mode can
     *                                                                  be significantly slower than the others. It can be numerically
     *                                                                  unstable if the sum over any rectangular subsection of the kernel
     *                                                                  is zero, which can result in division by zero during the computation.
     *                                                                  The results for this edging mode are usually quite visually similar
     *                                                                  to kvImageEdgeExtend.
     *
     *                                      kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                  size of the temp buffer needed for this set of parameters. Does
     *                                                                  not touch the src or dest image.
     *
     *                                      kvImageDoNotTile            Disable internal multithreading.
     *
     *                              @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *          kvImageNoError              Success.
     *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                      the temp buffer to use with this function and this set of
     *                                      parameters.
     *
     *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                          to corresponding dimensions of the source buffer.
     *
     *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *          kvImageNullPointerArgument  kernel may not be NULL
     *
     *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
     *      @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageRichardsonLucyDeConvolve_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstShortPtr kernel, ConstShortPtr kernel2,
            int kernel_height, int kernel_width, int kernel_height2, int kernel_width2, int divisor, int divisor2,
            byte backgroundColor, int iterationCount, int flags);

    /**
     * [@function] vImageRichardsonLucyDeConvolve_PlanarF
     * <p>
     * Perform N iterations of a Lucy-Richardson deconvolution on PlanarF data
     * <p>
     * This routine iteratively uses the following formula:
     * <pre>@textblock
     *        e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )
     *
     *        where:
     *              e[0] = the observed image (src parameter)
     *              e[n] = the result of the nth iteration
     *              psf  = point spread function (kernel for call to convolution)
     *                x    = multiply operator
     *              '*'  = convolution operator
     *      @/textblock </pre>
     * <p>
     * Does not work in place.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
     *                         For example, for a simple 3x3 blur, it might be:
     *                         <pre>@textblock
     *                                                  const float kernel[9] =   { 1./16, 2./16, 1./16,
     *                                                                              2./16, 4./16, 2./16,
     *                                                                              1./16, 2./16, 1./16 };
     *                                                  @/textblock </pre>
     *                         <p>
     *                         This is psf0 in the formula given in the discussion.
     * @param kernel2          A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
     *                         This is psf1 in the formula given in the discussion.
     * @param kernel_height    The height of the 2D table of weights passed in as kernel1. It must be an odd number.
     * @param kernel_width     The width of the 2D table of weights passed in as kernel1. It must be an odd number.
     * @param kernel_height2   The height of the 2D table of weights passed in as kernel2. It must be an odd number.
     * @param kernel_width2    The width of the 2D table of weights passed in as kernel2. It must be an odd number.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param iterationCount   The number of Richardson-Lucy iterations to perform on the data before returning.
     *                         If 0, the src buffer is coped to dest.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                      kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                  copy the corresponding source pixel to the destination. This
     *                                                                  will result in a ring off unconvolved content at the edges
     *                                                                  and convolved content in the middle.
     *
     *                                      kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                  For a blur filter this will look like the edges of the image
     *                                                                  have been blurred into a particular color. This is usually
     *                                                                  appropriate when the color of the surface onto which the image
     *                                                                  will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                  as a background color, and let the downstream image compositor
     *                                                                  blend in the background color. In this case, the result image
     *                                                                  should be treated as a premultiplied image.
     *
     *                                      kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                  This is better when the image is drawn into a frame or other
     *                                                                  context where the background is not expected to contribute to
     *                                                                  the final content.
     *
     *                                      kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                  simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                  Because of the complication at the edges, this edging mode can
     *                                                                  be significantly slower than the others. It can be numerically
     *                                                                  unstable if the sum over any rectangular subsection of the kernel
     *                                                                  is zero, which can result in division by zero during the computation.
     *                                                                  The results for this edging mode are usually quite visually similar
     *                                                                  to kvImageEdgeExtend.
     *
     *                                      kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                  size of the temp buffer needed for this set of parameters. Does
     *                                                                  not touch the src or dest image.
     *
     *                                      kvImageDoNotTile            Disable internal multithreading.
     *
     *                              @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *          kvImageNoError              Success.
     *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                      the temp buffer to use with this function and this set of
     *                                      parameters.
     *
     *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                          to corresponding dimensions of the source buffer.
     *
     *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *          kvImageNullPointerArgument  kernel may not be NULL
     *
     *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
     *      @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageRichardsonLucyDeConvolve_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernel, ConstFloatPtr kernel2,
            int kernel_height, int kernel_width, int kernel_height2, int kernel_width2, float backgroundColor,
            int iterationCount, int flags);

    /**
     * [@function] vImageBoxConvolve_Planar8
     * <p>
     * Special purpose box convolution on a Planar8 image.
     * <p>
     * This filter applies a box filter to a Planar8 image.  A box filter uses a much faster algorithm
     * than a standard convolution, and may be a good solution for real time application of large blur
     * radii against images.
     * For each pixel:
     * <pre>@textblock
     *         vImagePixelCount kernel_area = kernel_height * kernel_width;
     *         for each pixel[y][x] in image{
     *             int sum = 0;
     *
     *             // Calculate unweighted average over kernel area
     *             for each kernel_element[i][j] in kernel{
     *                 sum += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                             [x+j+srcOffsetToROI_X- kernel_width/2];
     *             }
     *             // Correct for the scaling introduced by multiplying by the weights table
     *             sum = (sum + kernel_area/2) / kernel_area;
     *
     *             // write out result
     *             result[y][x] = CLAMP(sum, 0, 255);
     *         }
     *     @/textblock </pre>
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageBoxConvolve_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, int kernel_height, int kernel_width,
            byte backgroundColor, int flags);

    /**
     * [@function] vImageTentConvolve_Planar8
     * <p>
     * Special purpose tent convolution on a Planar8 image.
     * <p>
     * This filter applies a tent filter to a Planar8 image.  A tent filter uses a much faster algorithm
     * than a standard convolution, and may be a good solution for real time application of large blur
     * radii against images.
     * For each pixel:
     * <pre>@textblock
     *         for each pixel[y][x] in image{
     *             int sum = 0;
     *             int divisor = 0;
     *
     *             // Calculate weighted average over kernel area
     *             for each kernel_element[i][j] in kernel{
     *                 sum += kernel_element[i][j] *
     *                         pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                              [x+j+srcOffsetToROI_X- kernel_width/2];
     *                 divisor += kernel_element[i][j];
     *             }
     *
     *             // Correct for the scaling introduced by multiplying by the weights table
     *             sum = (sum + divisor/2) / divisor;
     *
     *             // write out result
     *             result[y][x] = CLAMP(sum, 0, 255);
     *         }
     *     @/textblock </pre>
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
     *
     *         kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageTentConvolve_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, int kernel_height, int kernel_width,
            byte backgroundColor, int flags);

    /**
     * [@function] vImageClip_PlanarF
     * <p>
     * Clips the pixel values of an image in PlanarF format, using the provided minimum and maximum values.
     * <p>
     * For each pixel, do the following:
     * [@code]
     * if( pixel > maxFloat )
     * pixel = maxFloat;
     * if( pixel < minFloat )
     * pixel = minFloat;
     * [@endcode]
     * <p>
     * This function can work in place provided the following are true:
     * If src overlaps with dest, src->data must be equal to dest->data and src->rowBytes >= dest->rowBytes
     * If an overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * [@note] This function may be used for multichannel image formats, such as ARGBFFFF.
     * Scale the vImage_Buffer.width to compensate for the extra channels.
     *
     * @param src      A pointer to a vImage buffer structure that contains the source image whose data you want to clip.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a allocated buffer to receive the result pixels.
     * @param maxFloat A maximum pixel value. The function clips larger values to this value in the destination image.
     * @param minFloat A minimum pixel value. The function clips smaller values to this value in the destination image.
     * @param flags    \p kvImageNoFlags      Default operation.
     *                 \p kvImageDoNotTile    Disable internal multithreading.
     * @return kvImageNoError                      Success
     * @return kvImageRoiLargerThanInputBuffer     The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageClip_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, float maxFloat,
            float minFloat, int flags);

    /**
     * [@function] vImageConvert_Planar8toPlanarF
     * <p>
     * Convert an array of 8 bit integer data to floating point data.
     * <p>
     * For each pixel, do the following:
     * [@code]
     * float result = (maxFloat - minFloat) * (float) srcPixel / 255.0  + minFloat
     * [@endcode]
     * <p>
     * You can use this for ARGB8888 -> ARGBFFFF conversions by simply multiplying the width of the vImage_Buffer by 4 (for 4 channels)
     * <p>
     * [@note] Does not work in place.
     *
     * @param src      A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing the source pixels.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a allocated buffer to receive the result pixels.
     * @param maxFloat A maximum float value.
     * @param minFloat A minimum float value.
     * @param flags    \p kvImageNoFlags                      Default operation.
     *                 \p kvImageDoNotTile                    Disable internal multithreading.
     *                 \p kvImagePrintDiagnosticsToConsole    Directs the function to print diagnostic information to the console in the event of failure.
     * @return kvImageNoError                     Success
     * @return kvImageUnknownFlagsBit             Not all vImage flags are understood by this function. See description of flags parameter for supported flags.
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8toPlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, float maxFloat,
            float minFloat, int flags);

    /**
     * [@function] vImageConvert_PlanarFtoPlanar8
     * <p>
     * Convert an array of floating point data to 8 bit integer data.
     * <p>
     * For each pixel, do the following:
     * [@code]
     * uint8_t result = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel - minFloat ) / (maxFloat - minFloat) + 0.5f );
     * [@endcode]
     * <p>
     * You can use this for ARGBFFFF -> ARGB8888 conversions by simply multiplying the width of the vImage_Buffer by 4 (for 4 channels)
     *
     * @param src      A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing the source pixels.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a allocated buffer to receive the result pixels.
     * @param maxFloat A maximum float value.
     * @param minFloat A minimum float value.
     * @param flags    \p kvImageNoFlags      Default operation
     *                 \p kvImageDoNotTile    Disable internal multithreading.  You should use this if you are doing your own threading / tiling.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_PlanarFtoPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, float maxFloat,
            float minFloat, int flags);

    /**
     * [@function] vImageConvert_PlanarFtoPlanar8_dithered
     * <p>
     * Convert an array of floating point data to 8 bit integer data with dithering.
     * <p>
     * For each pixel, do the following:
     * [@code]
     * uint8_t result = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel - minFloat ) / (maxFloat - minFloat) + random_float[0,1) );
     * [@endcode]
     * <p>
     * The \p dither parameter must be one of the following flags:
     * \p kvImageConvert_DitherNone Same as vImageConvert_PlanarFtoPlanar8(). Rounds to nearest.
     * <p>
     * \p kvImageConvert_DitherOrdered Pre-computed blue noise is added to the image before rounding to the values in
     * the destination format.  The offset into this blue noise is randomized per-call to avoid visible artifacts
     * if you do your own tiling or call the function on sequential frames of video.
     * <p>
     * \p kvImageConvert_DitherOrderedReproducible Pre-computed blue noise is added to the image before rounding to the
     * values in the destination format.  The offset into the blue noise is the same for every call to allow users
     * to get reproducible results. Fine for still images. For video kvImageConvert_DitherOrdered is a better choice.
     * <p>
     * The ordered dither methods may be further influenced by shaping the distribution of the noise using the gaussian and uniform options below.
     * These options are OR-ed with kvImageConvert_DitherOrdered / kvImageConvert_DitherOrderedReproducible:
     * <p>
     * \p kvImageConvert_OrderedGaussianBlue When using an ordered dither pattern, distribute the noise according to a gaussian
     * distribution. This generally gives more pleasing images --  less noisy and perhaps a little more saturated -- but color
     * fidelity can suffer. Its effect is between kvImageConvert_DitherNone and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
     * This is the default for kvImageConvert_DitherOrdered and kvImageConvert_DitherOrderedReproducible.
     * <p>
     * \p kvImageConvert_OrderedUniformBlue When using an ordered dither pattern, distribute the noise uniformly. This generally gives
     * best color fidelity, but the resulting image is noisier and more obviously dithered. This is usually the best choice when low
     * bitdepth content is drawn next to high bitdepth content and in other circumstances where subtle changes to color arising from the conversion
     * could be easily noticed. It may be a poor choice when the image is likely to be enlarged -- this would cause the noise to become
     * more evident-- and for very flat / synthetic content with little inherent noise. The enlargement problem may be avoided by enlarging
     * first at high bitdepth, then convert to lower bitdepth.
     * <p>
     * [@note] "Blue" noise does not look blue, nor does it operate solely on the blue color channel. Blue noise is monochrome noise that is added to all color
     * channels equally. The name arises from blue light, which has a higher frequency than other colors of visible light. Thus, blue noise is noise which is
     * weighted heavily towards high frequencies. Low frequency noise tends to have visible shapes in it that would become apparent in an image if it was added in,
     * so it is excluded from the dither pattern.
     * <p>
     * [@warning] Unlike vImageConvert_PlanarFtoPlanar8, vImageConvert_PlanarFtoPlanar8_dithered usually should not be used for
     * multichannel data. Otherwise the dithering will occur in the chrominance dimensions and the noise will cause
     * grain with varying hue.
     * <p>
     * [@note] This function can work in place provided the following are true:
     * If src overlaps with dest, src->data must be equal to dest->data and src->rowBytes >= dest->rowBytes.
     * If an overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags.
     *
     * @param src      A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing the source pixels.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a allocated buffer to receive the result pixels.
     * @param maxFloat The encoding for 1.0 in the src buffer, full intensity. Typically, this is 1.0 for floating-point data in the range[0,1] but if your data is [0,65535] then you would pass 65535.0f here.
     * @param minFloat The encoding for 0.0 in the src buffer, no light.  Typically this is 0.0 for floating-point data in the range [0,1], but if your data is [-.5,0.5] then you would pass -0.5f here.
     * @param dither   The type of random noise to use for the dither. See discussion for more details.
     * @param flags    The following flags are honored:
     *                 \p kvImageNoFlags              Default operation.
     *                 \p kvImageDoNotTile            Disable internal multithreading, if any.
     *                 \p kvImageGetTempBufferSize    Returns 0. Does no work. Does not touch data.
     * @return \p kvImageNoError                      Success
     * @return \p kvImageRoiLargerThanInputBuffer     The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     * @return \p kvImageUnknownFlagsBit              Not all vImage flags are understood by this function. See description of flags parameter for supported flags.
     * @return \p kvImageInvalidParameter             An unknown / unsupported dithering mode was requested.
     * @see vImageConvert_PlanarFtoPlanar8
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_PlanarFtoPlanar8_dithered(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, float maxFloat,
            float minFloat, int dither, int flags);

    /**
     * [@function] vImageConvert_Planar8toARGB8888
     * <p>
     * Interleave 4 planar 8 bit integer buffers to make an interleaved 4 channel ARGB8888 buffer.
     * <p>
     * For each pixel in { srcA, srcR, srcG, srcB }, do the following:
     * [@code]
     * Pixel_88888 result = { pixelFromSrcA, pixelFromSrcR, pixelFromSrcG, pixelFromSrcB };
     * [@endcode]
     * <p>
     * This function may be used to create other channel orderings such as RGBA8888 by passing in the planar8 images in the alternate order.
     * <p>
     * [@note] Does not work in place.
     *
     * @param srcA  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing A source pixels.
     * @param srcR  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing R source pixels.
     * @param srcG  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing G source pixels.
     * @param srcB  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing B source pixels.
     * @param dest  A pointer to a valid and initialized vImage_Buffer struct, that points to a allocated buffer to receive the result pixels.
     * @param flags \p kvImageNoFlags      Default operation
     *              \p kvImageDoNotTile    Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8toARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcA,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcR,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcG,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcB,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_PlanarFtoARGBFFFF
     * <p>
     * Interleave 4 planar floating point buffers to make an interleaved 4 channel ARGBFFFF buffer.
     * <p>
     * For each pixel in { srcA, srcR, srcG, srcB }, do the following:
     * [@code]
     * Pixel_FFFF result = { pixelFromSrcA, pixelFromSrcR, pixelFromSrcG, pixelFromSrcB };
     * [@endcode]
     * <p>
     * This function may be used to create other channel orderings such as RGBAFFFF by passing in the planar8 images in the alternate order.
     * <p>
     * [@note] Does not work in place.
     *
     * @param srcA  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing A source pixels.
     * @param srcR  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing R source pixels.
     * @param srcG  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing G source pixels.
     * @param srcB  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing B source pixels.
     * @param dest  A pointer to a valid and initialized vImage_Buffer struct, that points to a allocated buffer to receive the result pixels.
     * @param flags \p kvImageNoFlags      Default operation
     *              \p kvImageDoNotTile    Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_PlanarFtoARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcA,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcR,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcG,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcB,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_ARGB8888toPlanar8
     * <p>
     * Deinterleave an ARGB8888 interleaved vImage_Buffer to form 4 planar 8-bit integer buffers.
     * <p>
     * For each pixel in srcARGB, do the following:
     * [@code]
     * Pixel_8 destAResult = srcARGBPixel[0];
     * Pixel_8 destRResult = srcARGBPixel[1];
     * Pixel_8 destGResult = srcARGBPixel[2];
     * Pixel_8 destBResult = srcARGBPixel[3];
     * [@endcode]
     * <p>
     * This function may be used to deinterleave other channel orderings such as RGBA8888 by passing in the planar8 images in the alternate order.
     * <p>
     * [@note] Does not work in place.
     *
     * @param srcARGB A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixels.
     * @param destA   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing A destination pixels.
     * @param destR   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing R destination pixels.
     * @param destG   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing G destination pixels.
     * @param destB   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing B destination pixels.
     * @param flags   \p kvImageNoFlags      Default operation
     *                \p kvImageDoNotTile    Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB8888toPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcARGB,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destA,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destR,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destG,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destB, int flags);

    /**
     * [@function] vImageConvert_ARGBFFFFtoPlanarF
     * <p>
     * Deinterleave an ARGBFFFF interleaved vImage_Buffer to form 4 planar floating point buffers.
     * <p>
     * For each pixel in srcARGB, do the following:
     * [@code]
     * Pixel_F destAResult = srcARGBPixel[0];
     * Pixel_F destRResult = srcARGBPixel[1];
     * Pixel_F destGResult = srcARGBPixel[2];
     * Pixel_F destBResult = srcARGBPixel[3];
     * [@endcode]
     * <p>
     * This function may be used to deinterleave other channel orderings such as RGBAFFFF by passing in the planar8 images in the alternate order.
     * <p>
     * [@note] Does not work in place.
     *
     * @param srcARGB A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixels.
     * @param destA   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing A destination pixels.
     * @param destR   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing R destination pixels.
     * @param destG   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing G destination pixels.
     * @param destB   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing B destination pixels.
     * @param flags   \p kvImageNoFlags      Default operation
     *                \p kvImageDoNotTile    Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGBFFFFtoPlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcARGB,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destA,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destR,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destG,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destB, int flags);

    /**
     * vImageConvert_ChunkyToPlanar8
     * vImageConvert_PlanarToChunky8
     * vImageConvert_ChunkyToPlanarF
     * vImageConvert_PlanarToChunkyF
     * <p>
     * These functions convert between nearly arbitrary interleaved data formats that vImage
     * doesn't support to/from planar data formats that it does support.
     * N planar arrays are interleaved to make (or are made made by deinterleaving)
     * a N channel packed interleaved buffer with pixels that are {srcStrideBytes, destStrideBytes}
     * bytes in size. Valid data channels are assumed to be at the front of each interleaved pixel.
     * <p>
     * Will not work in place
     * <p>
     * Performance advisory:
     * =====================
     * These functions are too flexible to vectorize every case. When appropriate, it is suggested you use the other
     * special purpose conversion functions. If you know what your data formats are ahead of time, it is
     * likely you can write your own special purpose conversion function that is faster, even in scalar code.
     * These functions are provided as a convenience.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ChunkyToPlanar8(Ptr<ConstVoidPtr> srcChannels,
            Ptr<ConstPtr<vImage_Buffer>> destPlanarBuffers, int channelCount, @NUInt long srcStrideBytes,
            @NUInt long srcWidth, @NUInt long srcHeight, @NUInt long srcRowBytes, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_PlanarToChunky8(Ptr<ConstPtr<vImage_Buffer>> srcPlanarBuffers,
            Ptr<VoidPtr> destChannels, int channelCount, @NUInt long destStrideBytes, @NUInt long destWidth,
            @NUInt long destHeight, @NUInt long destRowBytes, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ChunkyToPlanarF(Ptr<ConstVoidPtr> srcChannels,
            Ptr<ConstPtr<vImage_Buffer>> destPlanarBuffers, int channelCount, @NUInt long srcStrideBytes,
            @NUInt long srcWidth, @NUInt long srcHeight, @NUInt long srcRowBytes, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_PlanarToChunkyF(Ptr<ConstPtr<vImage_Buffer>> srcPlanarBuffers,
            Ptr<VoidPtr> destChannels, int channelCount, @NUInt long destStrideBytes, @NUInt long destWidth,
            @NUInt long destHeight, @NUInt long destRowBytes, int flags);

    /**
     * [@function] vImageConvert_16SToF
     * <p>
     * Convert a planar vImage_Buffer of 16 bit signed integers to a buffer containing floating point values.
     * <p>
     * For each 16 bit pixel in src, do the following:
     * [@code]
     * float result = (float) srcPixel * scale + offset;
     * [@endcode]
     * <p>
     * To convert 4 channel interleaved signed 16 bit data to ARGBFFFF, simply multiply the vImage_Buffer.width by 4.
     * <p>
     * [@note] Does not work in place.
     *
     * @param src    A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing source pixels.
     * @param dest   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param scale  A scale value in the conversion.
     * @param offset A offset value in the conversion.
     * @param flags  \p kvImageNoFlags                     Default operation
     *               \p kvImageDoNotTile                   Disable internal multithreading.
     * @return kvImageNoError                       Success
     * @return kvImageRoiLargerThanInputBuffer      The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16SToF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, float offset,
            float scale, int flags);

    /**
     * [@function] vImageConvert_16UToF
     * <p>
     * Convert a planar vImage_Buffer of 16 bit unsigned integers to a buffer containing floating point values.
     * <p>
     * For each 16 bit pixel in src, do the following:
     * [@code]
     * float result = (float) srcPixel * scale + offset;
     * [@endcode]
     * <p>
     * To convert 4 channel interleaved signed 16 bit data to ARGBFFFF, simply multiply the vImage_Buffer.width by 4.
     * <p>
     * [@note] Does not work in place.
     *
     * @param src    A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing source pixels.
     * @param dest   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param scale  A scale value in the conversion.
     * @param offset A offset value in the conversion.
     * @param flags  \p kvImageNoFlags                     Default operation
     *               \p kvImageDoNotTile                   Disable internal multithreading.
     * @return kvImageNoError                       Success
     * @return kvImageRoiLargerThanInputBuffer      The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16UToF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, float offset,
            float scale, int flags);

    /**
     * [@function] vImageConvert_FTo16S
     * <p>
     * Convert a planar vImage_Buffer of floating point values to a buffer of 16 bit signed integers.
     * <p>
     * For each floating point pixel in src, do the following:
     * [@code]
     * int16_t result = SATURATED_CLIP_SHRT_MIN_to_SHRT_MAX( (srcPixel - offset) / scale  + 0.5f);
     * [@endcode]
     * <p>
     * Programmer's note:
     * The scale and offset here are designed to be the same offset and scale used for the vImageConvert_16SToF conversion.
     * For a lossless round trip (within the limits of floating point precision), use the same scale and offset values
     * in both directions:
     * <p>
     * vImageConvert_16SToF( int16_buffer, float_buffer, myOffset, myScale, kvImageNoFlags );   //Convert to float
     * vImageConvert_FTo16S( float_buffer, int16_buffer, myOffset, myScale, kvImageNoFlags );   //Convert back to int16_t
     * <p>
     * [@note] Works in place, as long as src->data == dest->data and src->rowBytes == dest->rowBytes.
     * [@note] To convert multichannel interleaved floating point formats (e.g. ARGBFFFF) to a multichannel 16-bit image format with the same channel ordering, simply multiply the vImage_Buffer.width by the number of channels.
     *
     * @param src    A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing source pixels.
     * @param dest   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param scale  A scale value in the conversion.
     * @param offset A offset value in the conversion.
     * @param flags  \p kvImageNoFlags                     Default operation
     *               \p kvImageDoNotTile                   Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_FTo16S(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, float offset,
            float scale, int flags);

    /**
     * [@function] vImageConvert_FTo16U
     * <p>
     * Convert a planar vImage_Buffer of floating point values to a buffer of 16 bit unsigned integers.
     * <p>
     * For each floating point pixel in src, do the following:
     * [@code]
     * uint16_t result = SATURATED_CLIP_0_to_USHRT_MAX( (srcPixel - offset) / scale  + 0.5f);
     * [@endcode]
     * <p>
     * Programmer's note:
     * The scale and offset here are designed to be the same offset and scale used for the vImageConvert_16UToF conversion.
     * For a lossless round trip (within the limits of floating point precision), use the same scale and offset values
     * in both directions:
     * <p>
     * vImageConvert_16UToF( int16_buffer, float_buffer, myOffset, myScale, kvImageNoFlags );   //Convert to float
     * vImageConvert_FTo16U( float_buffer, int16_buffer, myOffset, myScale, kvImageNoFlags );   //Convert back to uint16_t
     * <p>
     * [@note] Works in place, as long as src->data == dest->data and src->rowBytes == dest->rowBytes.
     * <p>
     * [@note] To convert multichannel interleaved floating point formats (e.g. ARGBFFFF) to a multichannel 16-bit image format with the same channel ordering, simply multiply the vImage_Buffer.width by the number of channels.
     *
     * @param src    A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing source pixels.
     * @param dest   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param scale  A scale value in the conversion.
     * @param offset A offset value in the conversion.
     * @param flags  \p kvImageNoFlags                     Default operation.
     *               \p kvImageDoNotTile                   Disable internal multithreading.
     * @return kvImageNoError                     Success.
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_FTo16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, float offset,
            float scale, int flags);

    /**
     * [@function] vImageConvert_16Uto16F
     * <p>
     * Convert from 16 bit unsigned integer to 16 bit float format.
     * <p>
     * For each floating point pixel in src, do the following:
     * [@code]
     * destPixel[x] = ConvertToPlanar16F(srcPixel[x]);
     * [@endcode]
     * <p>
     * The 16 bit floating point format is half-precision floating point
     * (a.k.a.  IEEE-754 binary16, OpenCL half, GL_ARB_half_float_pixel, OpenEXR half).
     * It has a layout as follows:
     * <p>
     * 16 bits:  seeeeemmmmmmmmmm
     * <p>
     * 1-bit sign | 5 bits of exponent, with a bias of 15 | 10 bits of significand
     * (with 11 bits of significance due to the implicit 1 bit)
     * <p>
     * NaNs, Infinities and denormals are supported.
     * Per IEEE-754, all signaling NaNs are quieted during the conversion. (OpenEXR-1.2.1 converts SNaNs to SNaNs.)
     * To set/inspect the current IEEE-754 rounding mode, please see appropriate utilities in fenv.h.
     * <p>
     * [@note] This routine will work in place provided that src.data == dest.data
     * and src.rowBytes >= dest.rowBytes. However, when src.rowBytes > dest.rowBytes
     * in-place will only work if you pass kvImageDoNotTile.
     * <p>
     * [@note] To use this with interleaved data, multiply vImage_Buffer.width by 4.
     *
     * @param src   A pointer to a vImage_Buffer that references the source pixels.
     * @param dest  A pointer to a vImage_Buffer that references the destination pixels.
     * @param flags \p kvImageDoNotTile    Turns off internal multithreading.
     * @return \p kvImageNoError                      Success!
     * @return \p kvImageRoiLargerThanInputBuffer     The source buffer must have a height and
     * width at least as large as the destination buffer.
     * @return \p kvImageNullPointerArgument          src or dest pointer is NULL.
     * @return \p kvImageUnknownFlagsBit              Unknown flag was passed.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16Uto16F(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_16Fto16U
     * <p>
     * Convert from 16 bit float to 16 bit unsigned integer format.
     * <p>
     * For each floating point pixel in src, do the following:
     * [@code]
     * destPixel[x] = ConvertToPlanar16U(srcPixel[x]);
     * [@endcode]
     * <p>
     * The 16 bit floating point format is half-precision floating point
     * (a.k.a.  IEEE-754 binary16, OpenCL half, GL_ARB_half_float_pixel, OpenEXR half).
     * It has a layout as follows:
     * <p>
     * 16 bits:  seeeeemmmmmmmmmm
     * <p>
     * 1-bit sign | 5 bits of exponent, with a bias of 15 | 10 bits of significand
     * (with 11 bits of significance due to the implicit 1 bit)
     * <p>
     * NaNs, Infinities and denormals are supported.
     * Per IEEE-754, all signaling NaNs are quieted during the conversion. (OpenEXR-1.2.1 converts SNaNs to SNaNs.)
     * To set/inspect the current IEEE-754 rounding mode, please see appropriate utilities in fenv.h
     * <p>
     * [@note] This routine will work in place provided that src.data == dest.data
     * and src.rowBytes >= dest.rowBytes. However, when src.rowBytes > dest.rowBytes
     * in-place will only work if you pass kvImageDoNotTile.
     * <p>
     * [@note] To use this with interleaved data, multiply vImage_Buffer.width by 4
     *
     * @param src   A pointer to a vImage_Buffer that references the source pixels.
     * @param dest  A pointer to a vImage_Buffer that references the destination pixels.
     * @param flags \p kvImageDoNotTile    Turns off internal multithreading.
     * @return \p kvImageNoError              Success!
     * @return \p kvImageRoiLargerThanInputBuffer   The source buffer must have a height and
     * width at least as large as the destination buffer.
     * @return \p kvImageNullPointerArgument  src or dest pointer is NULL.
     * @return \p kvImageUnknownFlagsBit      Unknown flag was passed.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16Fto16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_12UTo16U
     * <p>
     * Converts 12U to 16U
     * <p>
     * For each floating point pixel in src, do the following:
     * [@code]
     * uint8_t *srcRow = srcData;
     * uint16_t *destRow = destData;
     * <p>
     * //Load 2 12-bit values
     * t0 = (srcRow[0] << 16) | (srcRow[1] << 8) | srcRow [2];
     * srcRow += 3;
     * <p>
     * //Separate each of 12-bit
     * t1 = t0 & 0xfff;
     * t0 >>= 12;
     * <p>
     * //Convert and store
     * destRow[0] = (t0 * 65535U + (t0 << 4) + 2055U) >> 12;
     * destRow[1] = (t1 * 65535U + (t1 << 4) + 2055U) >> 12;
     * destRow += 2;
     * [@endcode]
     * <p>
     * [@note] This routine will not work in place.
     *
     * @param src   A pointer to a vImage_Buffer that references 12-bit source pixels
     * @param dest  A pointer to a vImage_Buffer that references 16-bit destination pixels.
     * @param flags \p kvImageDoNotTile    Turns off internal multithreading.
     * @return \p kvImageNoError                      Success!
     * @return \p kvImageRoiLargerThanInputBuffer     The source buffer must have a height and
     * width at least as large as the destination buffer.
     * @return \p kvImageNullPointerArgument          src, dest or table pointer is NULL.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_12UTo16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_16UTo12U
     * <p>
     * Converts 16U to 12U
     * <p>
     * For each floating point pixel in src, do the following:
     * [@code]
     * uint16_t *srcRow = srcData;
     * uint8_t *destRow = destData;
     * <p>
     * // 2 16-bit in 4-bytes
     * t0 = srcRow[0];
     * t1 = srcRow[1];
     * srcRow += 2;
     * <p>
     * t0 = (t0 * 4095 + 32767 + (t0 >> 4)) >> 16;
     * t1 = (t1 * 4095 + 32767 + (t1 >> 4)) >> 16;
     * <p>
     * t0 <<= 12;
     * t0 |= t1;
     * <p>
     * // 2 12-bit in 3-bytes
     * destRow[0] = t0 >> 16;
     * destRow[1] = t0 >> 8;
     * destRow[2] = t0;
     * destRow += 3;
     * [@endcode]
     * <p>
     * [@note] This routine will not work in place.
     *
     * @param src   A pointer to a vImage_Buffer that references 12-bit source pixels
     * @param dest  A pointer to a vImage_Buffer that references 16-bit destination pixels.
     * @param flags \p kvImageDoNotTile         Turns off internal multithreading.
     * @return \p kvImageNoError                      Success!
     * @return \p kvImageRoiLargerThanInputBuffer     The source buffer must have a height and
     * width at least as large as the destination buffer.
     * @return \p kvImageNullPointerArgument          src, dest or table pointer is NULL.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16UTo12U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageOverwriteChannels_ARGB8888
     * <p>
     * Overwrites one or more planes of an ARGB8888 image buffer with the provided planar buffer.
     * <p>
     * For each pixel in src, do the following:
     * [@code]
     * // Set up a uint32_t mask - 0xFF where the pixels should be conserved
     * // Load and splat the src pixel
     * uint32_t srcPixel = newSrc->data[x];
     * uint32_t result = origSrc->data[x];
     * srcPixel |= srcPixel << 8;
     * srcPixel |= srcPixel << 16;
     * <p>
     * // Select for the channels based on the mask
     * srcPixel &= ~mask;
     * result &= mask;
     * <p>
     * // combine the two and store
     * dest->data[x] = srcPixel | result;
     * [@endcode]
     * <p>
     * origSrc and dest may overlap, if they share the same origin.
     * origSrc should be at least as big as dest
     * <p>
     * origSrc and dest can be the same buffer
     * This function may be used with other channel orderings (e.g. origSrc -> a RGBA8888 buffer) by adjusting the order of the bits in the copyMask.
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data.
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags.
     *
     * @param newSrc   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing planar source pixel that we will overwrite with.
     * @param origSrc  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixel that we will overwrite into.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param copyMask A mask to copy plane : 0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue
     * @param flags    \p kvImageNoFlags          Default operation
     *                 \p kvImageDoNotTile        Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageOverwriteChannels_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer newSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer origSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, byte copyMask,
            int flags);

    /**
     * [@function] vImageOverwriteChannels_ARGBFFFF
     * <p>
     * Overwrites one or more planes of an ARGBFFFF image buffer with the provided planar buffer.
     * <p>
     * For each pixel in src, do the following:
     * [@code]
     * // Set up a uint32_t mask for which channels to use -1U where the pixels should not be conserved
     * uint32_t    a = origSrc->data[0] & maskA;
     * uint32_t    r = origSrc->data[1] & maskR;
     * uint32_t    g = origSrc->data[2] & maskG;
     * uint32_t    b = origSrc->data[3] & maskB;
     * uint32_t    colorA = newSrc->data[0];
     * uint32_t    colorR = colorA & ~maskR;
     * uint32_t    colorG = colorA & ~maskG;
     * uint32_t    colorB = colorA & ~maskB;
     * colorA &= ~maskA;
     * <p>
     * dest->data[0] = colorA | a;
     * dest->data[1] = colorR | r;
     * dest->data[2] = colorG | g;
     * dest->data[3] = colorB | b;
     * [@endcode]
     * <p>
     * origSrc and dest may overlap, if they share the same origin.
     * origSrc should be at least as big as dest
     * <p>
     * origSrc and dest can be the same buffer
     * This function may be used with other channel orderings (e.g. origSrc -> a RGBAFFFF buffer) by adjusting the order of the bits in the copyMask.
     * <p>
     * This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data.
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags.
     *
     * @param newSrc   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing planar source pixel that we will overwrite with.
     * @param origSrc  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixel that we will overwrite into.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param copyMask A mask to copy plane : 0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue
     * @param flags    \p kvImageNoFlags          Default operation
     *                 \p kvImageDoNotTile        Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageOverwriteChannels_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer newSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer origSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, byte copyMask,
            int flags);

    /**
     * [@function] vImageOverwriteChannelsWithScalar_Planar8
     * <p>
     * Fill the dest buffer with the scalar value.
     *
     * @param scalar A scalar value to fill the destination buffer.
     * @param dest   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param flags  \p kvImageNoFlags          Default operation
     *               \p kvImageDoNotTile        Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageOverwriteChannelsWithScalar_Planar8(byte scalar,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageOverwriteChannelsWithScalar_PlanarF
     * <p>
     * Fill the dest buffer with the scalar value.
     *
     * @param scalar A scalar value to fill the destination buffer.
     * @param dest   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param flags  \p kvImageNoFlags          Default operation
     *               \p kvImageDoNotTile        Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageOverwriteChannelsWithScalar_PlanarF(float scalar,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageOverwriteChannelsWithScalar_Planar16S
     * <p>
     * Fill the dest buffer with the scalar value.
     *
     * @param scalar A scalar value to fill the destination buffer.
     * @param dest   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param flags  \p kvImageNoFlags          Default operation
     *               \p kvImageDoNotTile        Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageOverwriteChannelsWithScalar_Planar16S(short scalar,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageOverwriteChannelsWithScalar_Planar16U
     * <p>
     * Fill the dest buffer with the scalar value.
     *
     * @param scalar A scalar value to fill the destination buffer.
     * @param dest   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param flags  \p kvImageNoFlags          Default operation
     *               \p kvImageDoNotTile        Disable internal multithreading.
     * @return kvImageNoError                     Success
     * @return kvImageRoiLargerThanInputBuffer    The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageOverwriteChannelsWithScalar_Planar16U(char scalar,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageExtractChannel_ARGB8888
     * <p>
     * Extract one channel from a 4-channel interleaved 8-bit per component buffer
     * <p>
     * This is the opposite operation from vImageOverwriteChannels_ARGB8888. It reads one component
     * from the four channel 8-bit per component buffer and writes it into a Planar8 buffer.
     * <p>
     * For each pixel i in src:
     * [@code]
     * Pixel_8888 *src_pixel;
     * Pixel_8 *dest_pixel;
     * <p>
     * dest_pixel[i] = src_pixel[i][channelIndex];
     * [@endcode]
     *
     * @param src          A valid pointer to a vImage_Buffer struct which describes a 8-bit per component, four channel buffer.
     *                     It does not have to be ARGB8888. It can be BGRA, RGBA, CMYK, etc.
     * @param dest         A valid pointer to a vImage_Buffer struct which describes a 8-bit per component, one channel buffer.
     *                     The buffer pointed to by dest should be allocated by you. It will be overwritten with one of the
     *                     channels.  This function does work in place, so long as the rowBytes is the same for src and dest
     *                     images and the start address also matches.
     * @param channelIndex The index of the channel to extract. For alpha in a ARGB image, this is 0.  For alpha in a BGRA image, this is 3.
     * @param flags        \p kvImageDoNotTile
     *                     \p kvImageGetTempBufferSize
     *                     \p kvImagePrintDiagnosticsToConsole
     * @return \p kvImageNoError                      Success. However, see also 0 below, if the kvImageGetTempBufferSize flag is passed.
     * @return \p 0                                   If the kvImageGetTempBufferSize flag is passed, this function returns 0 and does no work.
     * @return \p kvImageRoiLargerThanInputBuffer     The destination height or width is larger than the src height or width, respectively.
     * @return \p kvImageUnknownFlagsBit              A flag was used which was not among the approved set of flags. See flags param description above.
     * @return \p kvImageInvalidParameter             channelIndex must be in the range [0,3]
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageExtractChannel_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NInt long channelIndex, int flags);

    /**
     * [@function] vImageExtractChannel_ARGB16U
     * <p>
     * Extract one channel from a 4-channel interleaved 16-bit per component buffer.
     * <p>
     * vImageExtractChannel_ARGB16U reads one component from the four channel 16-bit per component buffer
     * and writes it into a Planar16U buffer.  Since this just copies data around, the data may be any
     * 16-bit per component data type, including signed 16 bit integers and half-precision floating point,
     * of any endianness. Likewise, the channel order does not need to be ARGB. RGBA, BGRA, CMYK, etc. all work.
     * <p>
     * For each pixel i in src:
     * [@code]
     * Pixel_ARGB_16U *src_pixel;
     * Pixel_16U *dest_pixel;
     * <p>
     * dest_pixel[i] = src_pixel[i][channelIndex];
     * [@endcode]
     *
     * @param src          A valid pointer to a vImage_Buffer struct which describes a 16-bit per component, four channel buffer.
     *                     It does not have to be ARGB16U. It can be BGRA, RGBA, CMYK, etc. The data can be any 16-bit per component
     *                     type such as int16_t or half-precision floating-point. Data must be at least 2-byte aligned.
     * @param dest         A valid pointer to a vImage_Buffer struct which describes a 16-bit per component, one channel buffer.
     *                     The buffer pointed to by dest should be allocated by you. It will be overwritten with one of the
     *                     channels.  This function does work in place, so long as the rowBytes is the same for src and dest
     *                     images and the start address also matches. The data returned will be in the same format (uint16_t,
     *                     int16_t, half-float, etc.) as the data provided in the src format, except that only a single channel
     *                     is present. Data must be at least 2-byte aligned.
     * @param channelIndex The index of the channel to extract. For alpha in a ARGB image, this is 0.  For alpha in a BGRA image, this is 3.
     * @param flags        The following flags are allowed:  kvImageDoNotTile, kvImageGetTempBufferSize, kvImageNoFlags, kvImagePrintDiagnosticsToConsole
     * @return kvImageNoError                     Success. However, see also 0 below, if the kvImageGetTempBufferSize flag is passed.
     * @return 0                                  If the kvImageGetTempBufferSize flag is passed, this function returns 0 and does no work.
     * @return kvImageRoiLargerThanInputBuffer    The destination height or width is larger than the src height or width, respectively.
     * @return kvImageUnknownFlagsBit             A flag was used which was not among the approved set of flags. See flags param description above.
     * @return kvImageInvalidParameter            channelIndex must be in the range [0,3]
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageExtractChannel_ARGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NInt long channelIndex, int flags);

    /**
     * [@function] vImageExtractChannel_ARGBFFFF
     * <p>
     * Extract one channel from a 4-channel interleaved 32-bit per component buffer
     * <p>
     * This is the opposite operation from vImageOverwriteChannels_ARGBFFFF. It reads one component
     * from the four channel 32-bit per component buffer and writes it into a PlanarF buffer. NaNs and
     * and sNaNs are not modified. Sign of zero shall be preserved.
     * <p>
     * For each pixel i in src:
     * [@code]
     * Pixel_FFFF *src_pixel;
     * Pixel_F *dest_pixel;
     * <p>
     * dest_pixel[i] = src_pixel[i][channelIndex];
     * [@endcode]
     *
     * @param src          A valid pointer to a vImage_Buffer struct which describes a 32-bit per component, four channel buffer.
     *                     It does not have to be ARGBFFFF. It can be BGRA, RGBA, CMYK, etc. of any endianness. Data must be at
     *                     least 4-byte aligned.
     * @param dest         A valid pointer to a vImage_Buffer struct which describes a 32-bit per component, one channel buffer.
     *                     The buffer pointed to by dest should be allocated by you. It will be overwritten with one of the
     *                     channels.  This function does work in place, so long as the rowBytes is the same for src and dest
     *                     images and the start address also matches. Data must be at least 4 byte aligned.
     * @param channelIndex The index of the channel to extract. For alpha in a ARGB image, this is 0.  For alpha in a BGRA image, this is 3.
     * @param flags        The following flags are allowed:  kvImageDoNotTile, kvImageGetTempBufferSize, kvImageNoFlags, kvImagePrintDiagnosticsToConsole
     * @return kvImageNoError                     Success. However, see also 0 below, if the kvImageGetTempBufferSize flag is passed.
     * @return 0                                  If the kvImageGetTempBufferSize flag is passed, this function returns 0 and does no work.
     * @return kvImageRoiLargerThanInputBuffer    The destination height or width is larger than the src height or width, respectively.
     * @return kvImageUnknownFlagsBit             A flag was used which was not among the approved set of flags. See flags param description above.
     * @return kvImageInvalidParameter            channelIndex must be in the range [0,3]
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageExtractChannel_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NInt long channelIndex, int flags);

    /**
     * [@function] vImageOverwriteChannelsWithScalar_ARGB8888
     * <p>
     * Overwrites the pixels of one or more planes of an ARGB8888 image buffer with the provided scalar value.
     * <p>
     * Fill the color channels (as indicated by copyMask) with the scalar value.
     * <p>
     * For each pixel in src:
     * [@code]
     * Pixel_8888 srcPixel, destPixel;
     * int mask;
     * int i;
     * <p>
     * mask = 0x8;
     * for( i = 0; i < 4; i++ )
     * {
     * if( copyMask & mask )
     * destPixel[i] = scalar;
     * else
     * destPixel[i] = srcPixel[i]
     * <p>
     * mask = mask >> 1;
     * }
     * [@endcode]
     * <p>
     * Bits 0-27 of copyMask must be 0.
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data and src->rowBytes >= dest->rowBytes
     * If overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * [@note] These functions may be used for images with other channel orderings such as RGBA8888 by adjusting the ordering of the bits in copyMask.
     *
     * @param scalar   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing scalar value that we will overwrite with.
     * @param src      A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixel that we will overwrite into.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param copyMask A mask to copy plane : 0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue
     * @param flags    \p kvImageNoFlags          Default operation
     *                 \p kvImageDoNotTile        Disable internal multithreading.  You should use this if you are doing your own threading / tiling.
     * @return kvImageNoError                         Success
     * @return kvImageInvalidParameter                When copyMask > 15 which is invalid.
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     * @see vImageOverwriteChannelsWithPixel_ARGB8888
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageOverwriteChannelsWithScalar_ARGB8888(byte scalar,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, byte copyMask,
            int flags);

    /**
     * [@function] vImageOverwriteChannelsWithScalar_ARGBFFFF
     * <p>
     * Overwrites the pixels of one or more planes of an ARGBFFFF image buffer with the provided scalar value.
     * <p>
     * Fill the color channels (as indicated by copyMask) with the scalar value.
     * <p>
     * For each pixel in src:
     * [@code]
     * Pixel_FFFF srcPixel, destPixel;
     * int mask;
     * int i;
     * <p>
     * mask = 0x8;
     * for( i = 0; i < 4; i++ )
     * {
     * if( copyMask & mask )
     * destPixel[i] = scalar;
     * else
     * destPixel[i] = srcPixel[i]
     * <p>
     * mask = mask >> 1;
     * }
     * [@endcode]
     * <p>
     * Bits 0-27 of copyMask must be 0.
     * This function can work in place provided the following are true:
     * src->data must be equal to dest->data and src->rowBytes >= dest->rowBytes
     * If overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * [@note] These functions may be used for images with other channel orderings such as RGBAFFFF by adjusting the ordering of the bits in copyMask.
     *
     * @param scalar   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing scalar value that we will overwrite with.
     * @param src      A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixel that we will overwrite into.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param copyMask A mask to copy plane : 0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue
     * @param flags    \p kvImageNoFlags          Default operation
     *                 \p kvImageDoNotTile        Disable internal multithreading.  You should use this if you are doing your own threading / tiling.
     * @return kvImageNoError                         Success
     * @return kvImageInvalidParameter                When copyMask > 15 which is invalid.
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     * @see vImageOverwriteChannelsWithPixel_ARGBFFFF
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageOverwriteChannelsWithScalar_ARGBFFFF(float scalar,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, byte copyMask,
            int flags);

    /**
     * [@function] vImageConvert_ARGBFFFFtoRGBFFF
     * <p>
     * Convert 4-channel ARGB buffer to a 3-channel RGB one, by removing the alpha (1st) channel.
     * [@note] This routine will work in place.
     *
     * @param src   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing source pixels.
     * @param dest  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param flags \p kvImageNoFlags          Default operation
     *              \p kvImageDoNotTile        Disable internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGBFFFFtoRGBFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_RGBAFFFFtoRGBFFF
     * <p>
     * Convert 4-channel RGBA buffer to a 3-channel RGB one, by removing the alpha (last) channel.
     * [@note] This routine will work in place.
     *
     * @param src   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing source pixels.
     * @param dest  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param flags \p kvImageNoFlags          Default operation
     *              \p kvImageDoNotTile        Disable internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBAFFFFtoRGBFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_BGRAFFFFtoRGBFFF
     * <p>
     * Convert 4-channel BGRA buffer to a 3-channel RGB one, by removing the alpha (last) channel and reordering the remaining..
     * [@note] This routine will work in place.
     *
     * @param src   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing source pixels.
     * @param dest  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param flags \p kvImageNoFlags          Default operation
     *              \p kvImageDoNotTile        Disable internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_BGRAFFFFtoRGBFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_RGBFFFtoARGBFFFF
     * <p>
     * Convert/pack a float RGB buffer with a corresponding alpha channel buffer or an alpha factor into a ARGB buffer.
     * <p>
     * a = a corresponding pixel from the alpha channel buffer, if it exists, or a fixed factor
     * For each pixel (r,g,b) in src with alpha a, do the following:
     * [@code]
     * if (premultiply!=0) dest = (a,r*a,g*a,b*a);
     * else dest = (a,r,g,b);
     * [@endcode]
     * <p>
     * [@note] This routine will not work in place.
     *
     * @param rgbSrc   A pointer to a vImage_Buffer that references the source RGB pixels.  Unchanged on exit.
     * @param aSrc     A pointer to a vImage_Buffer that references the source alpha channel. Unchanged on exit.
     * @param alpha    If aSrc is non-NULL, this parameter is ignored.
     *                 If aSrc is NULL, the value is used for the alpha channel of every pixel.
     * @param argbDest A pointer to a vImage_Buffer that references where to write the converted ARGB data.
     * @param flags    \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                     Success!
     * @return kvImageNullPointerArgument         rgbSrc or argbDest is NULL.
     * @return kvImageUnknownFlagsBit             Unknown flag was passed to the function.
     * @return kvImageRoiLargerThanInputBuffer    The source buffer must have a size (in both height and width)
     * no less than the destination buffers.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBFFFtoARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg2, float arg3,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg4, boolean arg5,
            int flags);

    /**
     * [@function] vImageConvert_RGBFFFtoRGBAFFFF
     * <p>
     * Convert/pack a float RGB buffer with a corresponding alpha channel buffer or an alpha factor into a RGBA buffer.
     * <p>
     * a = a corresponding pixel from the alpha channel buffer, if it exists, or a fixed factor
     * For each pixel (r,g,b) in src with alpha a, do the following:
     * [@code]
     * if (premultiply!=0) dest = (r*a,g*a,b*a,a);
     * else dest = (r,g,b,a);
     * [@endcode]
     * <p>
     * [@note] This routine will not work in place.
     *
     * @param rgbSrc   A pointer to a vImage_Buffer that references the source RGB pixels.  Unchanged on exit.
     * @param aSrc     A pointer to a vImage_Buffer that references the source alpha channel. Unchanged on exit.
     * @param alpha    If aSrc is non-NULL, this parameter is ignored.
     *                 If aSrc is NULL, the value is used for the alpha channel of every pixel.
     * @param rgbaDest A pointer to a vImage_Buffer that references where to write the converted RGBA data.
     * @param flags    \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                     Success!
     * @return kvImageNullPointerArgument         rgbSrc or rgbaDest is NULL.
     * @return kvImageUnknownFlagsBit             Unknown flag was passed to the function.
     * @return kvImageRoiLargerThanInputBuffer    The source buffer must have a size (in both height and width)
     * no less than the destination buffers.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBFFFtoRGBAFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg2, float arg3,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg4, boolean arg5,
            int flags);

    /**
     * [@function] vImageConvert_RGBFFFtoBGRAFFFF
     * <p>
     * Convert/pack a float RGB buffer with a corresponding alpha channel buffer or an alpha factor into a BGRA buffer.
     * <p>
     * a = a corresponding pixel from the alpha channel buffer, if it exists, or a fixed factor
     * For each pixel (r,g,b) in src with alpha a, do the following:
     * [@code]
     * if (premultiply!=0) dest = (b*a,g*a,r*a,a);
     * else dest = (b,g,r,a);
     * [@endcode]
     * <p>
     * [@note] This routine will not work in place.
     *
     * @param rgbSrc   A pointer to a vImage_Buffer that references the source RGB pixels.  Unchanged on exit.
     * @param aSrc     A pointer to a vImage_Buffer that references the source alpha channel. Unchanged on exit.
     * @param alpha    If aSrc is non-NULL, this parameter is ignored.
     *                 If aSrc is NULL, the value is used for the alpha channel of every pixel.
     * @param bgraDest A pointer to a vImage_Buffer that references where to write the converted BGRA data.
     * @param flags    \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                     Success!
     * @return kvImageNullPointerArgument         rgbSrc or bgraDest is NULL.
     * @return kvImageUnknownFlagsBit             Unknown flag was passed to the function.
     * @return kvImageRoiLargerThanInputBuffer    The source buffer must have a size (in both height and width)
     * no less than the destination buffers.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBFFFtoBGRAFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg2, float arg3,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg4, boolean arg5,
            int flags);

    /**
     * [@function] vImageConvert_ARGB1555toPlanar8
     * <p>
     * Convert from 16 bit/pixel ARGB1555 to 8-bit/channel Planar8 format.
     * <p>
     * For each pixel x in src->data:
     * [@code]
     * destA->data[x] =  1bitAlphaChannel * 255;
     * destR->data[x] = (5bitRedChannel   * 255 + 15) / 31;
     * destG->data[x] = (5bitGreenChannel * 255 + 15) / 31;
     * destB->data[x] = (5bitBlueChannel  * 255 + 15) / 31;
     * [@endcode]
     * <p>
     * [@note] This function will not work in place.
     *
     * @param src   A pointer to a vImage_Buffer that references the ARGB source channels.
     * @param destA A pointer to a vImage_Buffer that references the destination planar 8-bit alpha channel.
     * @param destR A pointer to a vImage_Buffer that references the destination planar 8-bit R channel.
     * @param destG A pointer to a vImage_Buffer that references the destination planar 8-bit G channel.
     * @param destB A pointer to a vImage_Buffer that references the destination planar 8-bit B channel.
     * @param flags \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageBufferSizeMismatch              When the dimension of alpha / red / green / blue are not same.
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB1555toPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destA,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destR,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destG,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destB, int flags);

    /**
     * [@function] vImageConvert_ARGB1555toARGB8888
     * <p>
     * Convert from 16 bit/pixel ARGB1555 to 32 bit/pixel ARGB8888 format.
     * <p>
     * For each pixel x in src:
     * [@code]
     * Pixel8 alpha =  1bitAlphaChannel * 255;
     * Pixel8 red   = (5bitRedChannel   * 255 + 15) / 31;
     * Pixel8 green = (5bitGreenChannel * 255 + 15) / 31;
     * Pixel8 blue  = (5bitBlueChannel  * 255 + 15) / 31;
     * dest->data[x] = {alpha, red, green, blue};
     * [@endcode]
     * <p>
     * [@note] This function will not work in place.
     *
     * @param src   A pointer to a vImage_Buffer that references the ARGB source channels.
     * @param dest  A pointer to a vImage_Buffer that references the destination ARGB channels.
     * @param flags \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB1555toARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_Planar8toARGB1555
     * <p>
     * Convert from 8-bit/channel Planar8 to 16 bit/pixel ARGB1555 format.
     * <p>
     * For each pixel x:
     * [@code]
     * uint32_t alpha = (srcA->data[x]      + 127) / 255;
     * uint32_t red   = (srcR->data[x] * 31 + 127) / 255;
     * uint32_t green = (srcG->data[x] * 31 + 127) / 255;
     * uint32_t blue  = (srcB->data[x] * 31 + 127) / 255;
     * dest->data[x] =  (alpha << 15) | (red << 10) | (green << 5) | blue;
     * [@endcode]
     * <p>
     * [@note] This function will not work in place.
     *
     * @param srcA  A pointer to a vImage_Buffer that references the 8-bit alpha source channel.
     * @param srcR  A pointer to a vImage_Buffer that references the 8-bit R source channel.
     * @param srcG  A pointer to a vImage_Buffer that references the 8-bit G source channel.
     * @param srcB  A pointer to a vImage_Buffer that references the 8-bit B source channel.
     * @param dest  A pointer to a vImage_Buffer that references the ARGB destination channels.
     * @param flags \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageBufferSizeMismatch              When the dimension of alpha / red / green / blue are not same.
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8toARGB1555(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcA,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcR,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcG,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcB,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_ARGB8888toARGB1555
     * <p>
     * Convert between 32 bit/pixel ARGB8888 to 16 bit/pixel ARGB1555 format.
     * <p>
     * For each pixel x in src:
     * [@code]
     * uint32_t alpha = (8bitAlphaChannel      + 127) / 255;
     * uint32_t red   = (8bitRedChannel   * 31 + 127) / 255;
     * uint32_t green = (8bitGreenChannel * 31 + 127) / 255;
     * uint32_t blue  = (8bitBlueChannel  * 31 + 127) / 255;
     * dest->data[x] =  (alpha << 15) | (red << 10) | (green << 5) | blue;
     * [@endcode]
     * <p>
     * [@note] This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data and buf->rowBytes >= dest->rowBytes.
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags.
     *
     * @param src   A pointer to a vImage_Buffer that references the source channels.
     * @param dest  A pointer to a vImage_Buffer that references the destination channels.
     * @param flags \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB8888toARGB1555(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_RGBA5551toRGBA8888
     * <p>
     * Convert from 16 bit/pixel RGBA5551 to 32 bit/pixel RGBA8888 format.
     * <p>
     * For each pixel x in src:
     * [@code]
     * Pixel8 red   = (5bitRedChannel   * 255 + 15) / 31;
     * Pixel8 green = (5bitGreenChannel * 255 + 15) / 31;
     * Pixel8 blue  = (5bitBlueChannel  * 255 + 15) / 31;
     * Pixel8 alpha =  1bitAlphaChannel * 255;
     * dest->data[x] = {red, green, blue, alpha};
     * [@endcode]
     * <p>
     * [@note] This function will not work in place.
     *
     * @param src   A pointer to a vImage_Buffer that references the RGBA source channels.
     * @param dest  A pointer to a vImage_Buffer that references the destination RGBA channels.
     * @param flags \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBA5551toRGBA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_RGBA8888toRGBA5551
     * <p>
     * Convert between 32 bit/pixel RGBA8888 to 16 bit/pixel RGBA5551 format.
     * <p>
     * For each pixel x in src:
     * [@code]
     * uint32_t red   = (8bitRedChannel   * 31 + 127) / 255;
     * uint32_t green = (8bitGreenChannel * 31 + 127) / 255;
     * uint32_t blue  = (8bitBlueChannel  * 31 + 127) / 255;
     * uint32_t alpha = (8bitAlphaChannel      + 127) / 255;
     * dest->data[x] =  (red << 11) | (green << 6) | (blue << 1) | alpha;
     * [@endcode]
     * <p>
     * [@note] This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data and buf->rowBytes >= dest->rowBytes.
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags.
     *
     * @param src   A pointer to a vImage_Buffer that references the source channels.
     * @param dest  A pointer to a vImage_Buffer that references the destination channels.
     * @param flags \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBA8888toRGBA5551(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_ARGB8888toARGB1555_dithered
     * <p>
     * Convert between 32 bit/pixel ARGB8888 to 16 bit/pixel ARGB1555 format with dithering.
     * <p>
     * Similar to vImageConvert_ARGB8888toARGB1555, except the result is dithered instead of round to nearest.
     * This method should provide more accurate (overall) color reproduction and less banding in low-frequency regions of the image.
     * <p>
     * [@note] This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data and buf->rowBytes >= dest->rowBytes.
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags.
     *
     * @param src    A pointer to a vImage_Buffer that references the source channels.
     * @param dest   A pointer to a vImage_Buffer that references the destination channels.
     * @param dither A dithering method which should be kvImageConvert_DitherOrdered or kvImageConvert_DitherOrderedReproducible.
     * @param flags  \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     * @see vImageConvert_ARGB8888toARGB1555
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB8888toARGB1555_dithered(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int dither, int flags);

    /**
     * [@function] vImageConvert_RGBA8888toRGBA5551_dithered
     * <p>
     * Convert between 32 bit/pixel RGBA8888 to 16 bit/pixel RGBA5551 format with dithering.
     * <p>
     * Similar to vImageConvert_RGBA8888toRGBA5551, except the result is dithered instead of round to nearest.
     * This method should provide more accurate (overall) color reproduction and less banding in low-frequency regions of the image.
     * <p>
     * [@note] This function can work in place provided the following are true:
     * For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data and buf->rowBytes >= dest->rowBytes.
     * If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags.
     *
     * @param src    A pointer to a vImage_Buffer that references the source channels.
     * @param dest   A pointer to a vImage_Buffer that references the destination channels.
     * @param dither A dithering method which should be kvImageConvert_DitherOrdered or kvImageConvert_DitherOrderedReproducible.
     * @param flags  \p kvImageDoNotTile            Turns off internal multithreading.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBA8888toRGBA5551_dithered(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int dither, int flags);

    /**
     * Convert from 16 bit/pixel RGB565 to 32 bit/pixel ARGB8888 or RGBA8888 or
     * BGRA8888 formats.  For each pixel:
     * <p>
     * Pixel8 alpha = alpha;
     * Pixel8 red   = (5bitRedChannel   * 255 + 15) / 31;
     * Pixel8 green = (6bitGreenChannel * 255 + 31) / 63;
     * Pixel8 blue  = (5bitBlueChannel  * 255 + 15) / 31;
     * <p>
     * The following flags are allowed:
     * kvImageDoNotTile            Disables internal threading.  You may want
     * to use this if you have your own threading
     * scheme and need to avoid interference.
     * <p>
     * kvImageGetTempBufferSize    Does no work and returns zero, as this
     * function does not use a temp buffer.
     * <p>
     * Return values:
     * kvImageNoError              Success
     * kvImageUnknownFlagsBit      No work was done because an unknown bit was
     * set in the flags parameter.
     * kvImageBufferSizeMismatch   No work was done because the source
     * image isn't large enough to cover the
     * destination image.
     * <p>
     * <p>
     * These functions do not operate in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB565toARGB8888(byte alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB565toRGBA8888(byte alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB565toBGRA8888(byte alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB565toRGB888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * Convert from 32 bit/pixel ARGB8888 or RGBA8888 or BGRA8888 formats
     * to 16 bit/pixel RGB565. for each pixel:
     * <p>
     * uint32_t red   = (8bitRedChannel   * 31 + 127) / 255;
     * uint32_t green = (8bitGreenChannel * 63 + 127) / 255;
     * uint32_t blue  = (8bitBlueChannel  * 31 + 127) / 255;
     * uint16_t RGB565pixel =  (red << 11) | (green << 5) | blue;
     * <p>
     * The following flags are allowed:
     * kvImageDoNotTile            Disables internal threading.  You may want
     * to use this if you have your own threading
     * scheme and need to avoid interference.
     * <p>
     * kvImageGetTempBufferSize    Does no work and returns zero, as this
     * function does not use a temp buffer.
     * <p>
     * Return values:
     * kvImageNoError                     Success
     * kvImageUnknownFlagsBit             No work was done because an unknown bit was
     * set in the flags parameter.
     * kvImageRoiLargerThanInputBuffer    No work was done because the source
     * image isn't large enough to cover the
     * destination image.
     * <p>
     * These functions operate in place, provided that src->data == dest->data,
     * src->rowBytes >= dest->rowBytes, and the kvImageDoNotTile flag is used
     * if src->rowBytes > dest->rowBytes.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB8888toRGB565(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBA8888toRGB565(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_BGRA8888toRGB565(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * vImageConvert_RGB888toRGB565_dithered
     * vImageConvert_ARGB8888toRGB565_dithered
     * vImageConvert_RGBA8888toRGB565_dithered
     * vImageConvert_BGRA8888toRGB565_dithered
     *
     * @param dither A dithering method which should be kvImageConvert_DitherOrdered or kvImageConvert_DitherOrderedReproducible.
     *               <p>
     *               Convert from RGB888 or ARGB8888 or RGBA8888 or BGRA8888 formats
     *               to 16 bit/pixel RGB565 with dithering. For each pixel:
     *               <p>
     *               uint32_t red   = (8bitRedChannel   * (31 << 8) + 127) / 255;
     *               uint32_t green = (8bitGreenChannel * (63 << 8) + 127) / 255;
     *               uint32_t blue  = (8bitBlueChannel  * (31 << 8) + 127) / 255;
     *               red   += dither_noise + (1 << 7);
     *               green += dither_noise + (1 << 7);
     *               blue  += dither_noise + (1 << 7);
     *               red    = red >> 8;
     *               green  = green >> 8;
     *               blue   = blue >> 8;
     *               uint16_t RGB565pixel =  (red << 11) | (green << 5) | blue;
     *               <p>
     *               The following flags are allowed:
     *               kvImageDoNotTile            Disables internal threading.  You may want
     *               to use this if you have your own threading
     *               scheme and need to avoid interference.
     *               <p>
     *               kvImageGetTempBufferSize    Does no work and returns zero, as this
     *               function does not use a temp buffer.
     *               <p>
     *               Return values:
     *               kvImageNoError                     Success
     *               kvImageUnknownFlagsBit             No work was done because an unknown bit was
     *               set in the flags parameter.
     *               kvImageRoiLargerThanInputBuffer    No work was done because the source
     *               image isn't large enough to cover the
     *               destination image.
     *               <p>
     *               These functions operate in place, provided that src->data == dest->data,
     *               src->rowBytes >= dest->rowBytes, and the kvImageDoNotTile flag is used
     *               if src->rowBytes > dest->rowBytes.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB888toRGB565_dithered(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int dither, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB8888toRGB565_dithered(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int dither, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBA8888toRGB565_dithered(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int dither, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_BGRA8888toRGB565_dithered(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int dither, int flags);

    /**
     * Convert between 16 bit/pixel RGB565 and Planar8 formats.  For the forward
     * conversion, for each pixel:
     * <p>
     * Pixel8 red   = (5bitRedChannel   * 255 + 15) / 31;
     * Pixel8 green = (6bitGreenChannel * 255 + 31) / 63;
     * Pixel8 blue  = (5bitBlueChannel  * 255 + 15) / 31;
     * <p>
     * For the reverse conversion, for each pixel:
     * <p>
     * uint32_t red   = (8bitRedChannel   * 31 + 127) / 255;
     * uint32_t green = (8bitGreenChannel * 63 + 127) / 255;
     * uint32_t blue  = (8bitBlueChannel  * 31 + 127) / 255;
     * uint16_t RGB565pixel =  (red << 11) | (green << 5) | blue;
     * <p>
     * The following flags are allowed:
     * kvImageDoNotTile            Disables internal threading.  You may want
     * to use this if you have your own threading
     * scheme and need to avoid interference.
     * <p>
     * kvImageGetTempBufferSize    Does no work and returns zero, as this
     * function does not use a temp buffer.
     * <p>
     * Return values:
     * kvImageNoError                     Success
     * kvImageUnknownFlagsBit             No work was done because an unknown bit was
     * set in the flags parameter.
     * kvImageRoiLargerThanInputBuffer    No work was done because the source
     * image isn't large enough to cover the
     * destination image.
     * <p>
     * These functions do not operate in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB565toPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destR,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destG,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer destB, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8toRGB565(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcR,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcG,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcB,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_RGBA5551toRGB565
     * <p>
     * Convert from RGBA5551 to RGB565 image format
     * <p>
     * Convert (with loss of alpha) from RGBA5551 to RGB565 format.
     * If you need something fancier done with alpha first, such as unpremultiplication or flattening, convert to 8 bit per channel first.
     * Both RGB565 and RGBA5551 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
     * little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
     *
     * @param src   A pointer to a vImage_Buffer struct which describes a memory region full of RGBA5551 pixels
     * @param dest  A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by RGB565 pixels
     * @param flags The following flags are understood by this function:
     *
     *              <pre>
     *              @textblock
     *              kvImageNoFlags                      Default operation.
     *
     *              kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
     *              many such operations going concurrently, and in cases where it is desirable to keep
     *              CPU utilization to a single core.
     *
     *              kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
     *              @/textblock
     *              </pre>
     * @return <pre>
     * @textblock
     * kvImageNoError                         Success
     *
     * kvImageRoiLargerThanInputBuffer        dest->height > src->height OR dest->width > src->width.  There are not enough pixels to fill the destination buffer.
     * @/textblock
     * </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBA5551toRGB565(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_ARGB1555toRGB565
     * <p>
     * Convert from ARGB1555 to RGB565 image format
     * <p>
     * Convert (with loss of alpha) from ARGB1555 to RGB565 format.
     * If you need something fancier done with alpha first, such as unpremultiplication or flattening, convert to 8 bit per channel first.
     * Both RGB565 and ARGB1555 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
     * little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
     *
     * @param src   A pointer to a vImage_Buffer struct which describes a memory region full of ARGB1555 pixels
     * @param dest  A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by RGB565 pixels
     * @param flags The following flags are understood by this function:
     *
     *              <pre>
     *              @textblock
     *              kvImageNoFlags                      Default operation.
     *
     *              kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
     *              many such operations going concurrently, and in cases where it is desirable to keep
     *              CPU utilization to a single core.
     *
     *              kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
     *              @/textblock
     *              </pre>
     * @return <pre>
     * @textblock
     * kvImageNoError                         Success
     *
     * kvImageRoiLargerThanInputBuffer        dest->height > src->height OR dest->width > src->width.  There are not enough pixels to fill the destination buffer.
     * @/textblock
     * </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB1555toRGB565(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_RGB565toRGBA5551
     * <p>
     * Convert from RGB565 to RGBA5551 image format
     * <p>
     * Convert from RGB565 to RGBA5551 format.  The new alpha is set to 1.
     * Both RGB565 and RGBA5551 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
     * little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
     *
     * @param src    A pointer to a vImage_Buffer struct which describes a memory region full of RGB565 pixels
     * @param dest   A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by RGBA5551 pixels
     * @param dither A dithering method for the green channel.   Options:
     *               <p>
     *               kvImageConvert_DitherNone - apply no dithering; input values
     *               are rounded to the nearest value representable in the
     *               destination format.
     *               kvImageConvert_DitherOrdered - pre-computed blue noise is
     *               added to the image before rounding to the values in
     *               the destination format.  The offset into this blue
     *               noise is randomized per-call to avoid visible artifacts
     *               if you do your own tiling or call the function on
     *               sequential frames of video.
     *               kvImageConvert_DitherOrderedReproducible - pre-computed
     *               blue noise is added to the image before rounding to the
     *               values in the destination format.  The offset into the
     *               blue noise is the same for every call to allow users
     *               to get reproducible results.
     *               <p>
     *               The ordered dither methods may be further influenced by shaping the
     *               distribution of the noise using the gaussian and uniform options below.
     *               These options are OR-ed with kvImageConvert_DitherOrdered / kvImageCon-
     *               vert_DitherOrderedReproducible:
     *               <p>
     *               kvImageConvert_OrderedGaussianBlue - when using an ordered dither
     *               pattern, distribute the noise according to a gaussian
     *               distribution. This generally gives more pleasing images --
     *               less noisy and perhaps a little more saturated -- but color
     *               fidelity can suffer. Its effect is between kvImageConvert_DitherNone
     *               and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
     *               This is the default for kvImageConvert_DitherOrdered and
     *               kvImageConvert_DitherOrderedReproducible.
     *               <p>
     *               kvImageConvert_OrderedUniformBlue - when using an ordered dither
     *               pattern, distribute the noise uniformly. This generally gives
     *               best color fidelity, but the resulting image is noisier and more
     *               obviously dithered. This is usually the best choice when low
     *               bitdepth content is drawn next to high bitdepth content and in other
     *               circumstances where subtle changes to color arising from the conversion
     *               could be easily noticed. It may be a poor choice when the image
     *               is likely to be enlarged -- this would cause the noise to become
     *               more evident-- and for very flat / synthetic content with little
     *               inherent noise. The enlargement problem may be avoided by enlarging
     *               first at high bitdepth, then convert to lower bitdepth.
     *               <p>
     *               To clarify: "Blue" noise is not blue, nor does it operate solely on the blue
     *               color channel. Blue noise is monochrome noise that is added to all color
     *               channels equally. The name arises from blue light, which has a higher frequency
     *               than other colors of visible light. Thus, blue noise is noise which is
     *               weighted heavily towards high frequencies. Low frequency noise tends to have
     *               visible shapes in it that would become apparent in an image if it was added in,
     *               so it is excluded from the dither pattern.
     * @param flags  The following flags are understood by this function:
     *
     *               <pre>
     *               @textblock
     *               kvImageNoFlags                      Default operation.
     *
     *               kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
     *               many such operations going concurrently, and in cases where it is desirable to keep
     *               CPU utilization to a single core.
     *
     *               kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
     *               @/textblock
     *               </pre>
     * @return <pre>
     * @textblock
     * kvImageNoError                          Success
     *
     * kvImageRoiLargerThanInputBuffer         dest->height > src->height OR dest->width > src->width.  There are not enough pixels to fill the destination buffer.
     *
     * kvImageInvalidParameter                 Invalid / unknown dither value
     * @/textblock
     * </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB565toRGBA5551(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int dither,
            int flags);

    /**
     * [@function] vImageConvert_RGB565toARGB1555
     * <p>
     * Convert from RGB565 to ARGB1555 image format
     * <p>
     * Convert from RGB565 to ARGB1555 format.  The new alpha is set to 1.
     * Both RGB565 and ARGB1555 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
     * little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
     *
     * @param src    A pointer to a vImage_Buffer struct which describes a memory region full of RGB565 pixels
     * @param dest   A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by ARGB1555 pixels
     * @param dither A dithering method for the green channel.   Options:
     *               <p>
     *               kvImageConvert_DitherNone - apply no dithering; input values
     *               are rounded to the nearest value representable in the
     *               destination format.
     *               kvImageConvert_DitherOrdered - pre-computed blue noise is
     *               added to the image before rounding to the values in
     *               the destination format.  The offset into this blue
     *               noise is randomized per-call to avoid visible artifacts
     *               if you do your own tiling or call the function on
     *               sequential frames of video.
     *               kvImageConvert_DitherOrderedReproducible - pre-computed
     *               blue noise is added to the image before rounding to the
     *               values in the destination format.  The offset into the
     *               blue noise is the same for every call to allow users
     *               to get reproducible results.
     *               <p>
     *               The ordered dither methods may be further influenced by shaping the
     *               distribution of the noise using the gaussian and uniform options below.
     *               These options are OR-ed with kvImageConvert_DitherOrdered / kvImageCon-
     *               vert_DitherOrderedReproducible:
     *               <p>
     *               kvImageConvert_OrderedGaussianBlue - when using an ordered dither
     *               pattern, distribute the noise according to a gaussian
     *               distribution. This generally gives more pleasing images --
     *               less noisy and perhaps a little more saturated -- but color
     *               fidelity can suffer. Its effect is between kvImageConvert_DitherNone
     *               and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
     *               This is the default for kvImageConvert_DitherOrdered and
     *               kvImageConvert_DitherOrderedReproducible.
     *               <p>
     *               kvImageConvert_OrderedUniformBlue - when using an ordered dither
     *               pattern, distribute the noise uniformly. This generally gives
     *               best color fidelity, but the resulting image is noisier and more
     *               obviously dithered. This is usually the best choice when low
     *               bitdepth content is drawn next to high bitdepth content and in other
     *               circumstances where subtle changes to color arising from the conversion
     *               could be easily noticed. It may be a poor choice when the image
     *               is likely to be enlarged -- this would cause the noise to become
     *               more evident-- and for very flat / synthetic content with little
     *               inherent noise. The enlargement problem may be avoided by enlarging
     *               first at high bitdepth, then convert to lower bitdepth.
     *               <p>
     *               To clarify: "Blue" noise is not blue, nor does it operate solely on the blue
     *               color channel. Blue noise is monochrome noise that is added to all color
     *               channels equally. The name arises from blue light, which has a higher frequency
     *               than other colors of visible light. Thus, blue noise is noise which is
     *               weighted heavily towards high frequencies. Low frequency noise tends to have
     *               visible shapes in it that would become apparent in an image if it was added in,
     *               so it is excluded from the dither pattern.
     * @param flags  The following flags are understood by this function:
     *
     *               <pre>
     *               @textblock
     *               kvImageNoFlags                      Default operation.
     *
     *               kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
     *               many such operations going concurrently, and in cases where it is desirable to keep
     *               CPU utilization to a single core.
     *
     *               kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
     *               @/textblock
     *               </pre>
     * @return <pre>
     * @textblock
     * kvImageNoError                          Success
     *
     * kvImageRoiLargerThanInputBuffer               dest->height > src->height OR dest->width > src->width.  There are not enough pixels to fill the destination buffer.
     *
     * kvImageInvalidParameter                 Invalid / unknown dither value
     * @/textblock
     * </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB565toARGB1555(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int dither,
            int flags);

    /**
     * Convert between 16 bit floats to 32 bit float format.
     * The 16 bit floating point format is identical to OpenEXR. It has a layout as follows:
     * <p>
     * 16 bits:  seeeeemmmmmmmmmm
     * <p>
     * 1-bit sign | 5 bits of exponent, with a bias of 15 | 10 bits of significand (with 11 bits of significance due to the implicit 1 bit)
     * <p>
     * NaNs, Infinities and denormals are supported.
     * Per IEEE-754, all signaling NaNs are quieted during the conversion. (OpenEXR-1.2.1 converts SNaNs to SNaNs.)
     * In the float->16 bit float direction, rounding occurs according to the IEEE-754 standard and current IEEE-754 rounding mode.
     * To set/inspect the current IEEE-754 rounding mode, please see appropriate utilities in fenv.h
     * <p>
     * vImageConvert_Planar16FtoPlanarF does not work in place.
     * vImageConvert_PlanarFtoPlanar16F does work in place, though the contents of the unused half of the buffer are undefined
     * In which case:
     * src->data must be equal to dest->data  and src->rowBytes >= dest->rowBytes
     * If src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * These functions may also be used with multichannel images formats, such as RGBAFFFF by scaling the width by the number of channels.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                         Success
     * kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar16FtoPlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_PlanarFtoPlanar16F(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * vImageConvert_Planar8toPlanar16F
     * <p>
     * Convert from 8 bit integer to 16 bit float format.
     * <p>
     * destPixel[x] = ConvertToPlanar16F(srcPixel[x]);
     * <p>
     * The range for conversion is [0,255] -> (half) [0.0, 1.0]
     * <p>
     * The 16 bit floating point format is half-precision floating point
     * (a.k.a.  IEEE-754 binary16, OpenCL half, GL_ARB_half_float_pixel, OpenEXR half).
     * It has a layout as follows:
     * <p>
     * 16 bits:  seeeeemmmmmmmmmm
     * <p>
     * 1-bit sign | 5 bits of exponent, with a bias of 15 | 10 bits of significand
     * (with 11 bits of significance due to the implicit 1 bit)
     * <p>
     * Operands:
     * ---------
     * src             A pointer to a vImage_Buffer that references the source pixels
     * <p>
     * dest            A pointer to a vImage_Buffer that references the destination pixels
     * <p>
     * flags           The following flags are allowed:
     * <p>
     * kvImageDoNotTile            Turns off internal multithreading. You may
     * wish to do this if you have your own
     * multithreading scheme to avoid having the
     * two interfere with one another.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                  Success!
     * kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height.
     * kvImageNullPointerArgument      src or dest pointer is NULL.
     * kvImageUnknownFlagsBit            Unexpected flag was passed.
     * <p>
     * This routine will work in place as long as the scan lines overlap exactly.
     * <p>
     * You can use this for ARGB8888 -> ARGB16F conversions by simply multiplying
     * the width of the vImage_Buffer by 4 (for 4 channels)
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8toPlanar16F(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * vImageConvert_Planar16FtoPlanar8
     * <p>
     * Convert from 16 bit float to 8 bit integer format.
     * <p>
     * destPixel[x] = ROUND_TO_INTEGER( SATURATED_CLAMP_0_to_255( 255.0f * (srcPixel[x])));
     * <p>
     * The ROUND_TO_INTEGER function is round to nearest integer (ties go to the even result).
     * <p>
     * The 16 bit floating point format is half-precision floating point
     * (a.k.a.  IEEE-754 binary16, OpenCL half, GL_ARB_half_float_pixel, OpenEXR half).
     * It has a layout as follows:
     * <p>
     * 16 bits:  seeeeemmmmmmmmmm
     * <p>
     * 1-bit sign | 5 bits of exponent, with a bias of 15 | 10 bits of significand
     * (with 11 bits of significance due to the implicit 1 bit)
     * <p>
     * All NaNs are converted to 0.
     * To set/inspect the current IEEE-754 rounding mode, please see appropriate utilities in fenv.h
     * <p>
     * Operands:
     * ---------
     * src             A pointer to a vImage_Buffer that references the source pixels
     * <p>
     * dest            A pointer to a vImage_Buffer that references the destination pixels
     * <p>
     * flags           The following flags are allowed:
     * <p>
     * kvImageDoNotTile            Turns off internal multithreading. You may
     * wish to do this if you have your own
     * multithreading scheme to avoid having the
     * two interfere with one another.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                  Success!
     * kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height.
     * kvImageNullPointerArgument      src or dest pointer is NULL.
     * kvImageUnknownFlagsBit            Unexpected flag was passed.
     * <p>
     * This routine will work in place as long as the scan lines overlap exactly.
     * <p>
     * You can use this for ARGB16F -> ARGB8888 conversions by simply multiplying
     * the width of the vImage_Buffer by 4 (for 4 channels)
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar16FtoPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * vImageConvert_16UToPlanar8
     * Convert a planar (or interleaved -- multiply vImage_Buffer.width by 4) vImage_Buffer of 16 bit unsigned shorts to a buffer containing 8 bit integer values.
     * For each 16 bit pixel in src:
     * <p>
     * uint8_t result = (srcPixel * 255 + 32767) / 65535;
     * <p>
     * To convert 4 channel interleaved unsigned 16 bit data to ARGB_8888, simply multiply the vImage_Buffer.width by 4.
     * <p>
     * This can work in place, though the contents of the unused half of the buffer are undefined
     * In which case:
     * src->data must be equal to dest->data  and src->rowBytes >= dest->rowBytes
     * If src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * This function may also be used with multichannel images formats, such as RGBA16U -> RGBA8888 by scaling the width by the number of channels.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                         Success
     * kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16UToPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * vImageConvert_Planar8To16U:
     * Convert a planar (or interleaved -- multiply vImage_Buffer.width by 4) vImage_Buffer of 8-bit integer values to a buffer of 16 bit unsigned ints.
     * For each 8-bit pixel in src:
     * <p>
     * uint16_t result = (srcPixel * 65535 + 127 ) / 255;
     * <p>
     * will not work in place.
     * This function may also be used with multichannel images formats, such as RGBA8888 -> RGBA16U  by scaling the width by the number of channels.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                         Success
     * kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8To16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * Convert RGB to ARGB
     * <p>
     * If premultiply != 0, then
     * <p>
     * r = (a * r + 127) / 255
     * g = (a * g + 127) / 255
     * b = (a * b + 127) / 255
     * <p>
     * will not work in place.
     * Pass NULL for aSrc to use alpha instead.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                         Success
     * kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB888toARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg2, byte arg3,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg4, boolean arg5,
            int arg6);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB888toRGBA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg2, byte arg3,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg4, boolean arg5,
            int arg6);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB888toBGRA8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg2, byte arg3,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg4, boolean arg5,
            int arg6);

    /**
     * Convert 4 channel buffer to a 3 channel one, by removing the 1st channel.
     * The R,G and B channels are simply copied into the new buffer.
     * <p>
     * This can work in place, though the contents of the unused half of the buffer are undefined
     * In which case:
     * src->data must be equal to dest->data  and src->rowBytes >= dest->rowBytes
     * If src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                         Success
     * kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB8888toRGB888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg2, int arg3);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBA8888toRGB888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg2, int arg3);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_BGRA8888toRGB888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer arg2, int arg3);

    /**
     * Convert 3 planar buffers to a 3 channel interleave buffer.
     * <p>
     * Does not work in place
     * This may be used to produce other channel orderings by changing the order of the planar buffers passed into the function.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                         Success
     * kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8toRGB888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer planarRed,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer planarGreen,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer planarBlue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbDest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_PlanarFtoRGBFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer planarRed,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer planarGreen,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer planarBlue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbDest, int flags);

    /**
     * Convert a 3 channel interleave buffer to 3 planar buffers.
     * <p>
     * Does not work in place
     * This may be used to consume other channel orderings by changing the order of the planar buffers passed into the function.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                         Success
     * kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB888toPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer redDest,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer greenDest,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blueDest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBFFFtoPlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer redDest,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer greenDest,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blueDest, int flags);

    /**
     * [@function] vImageSelectChannels_ARGB8888
     * <p>
     * Does the same thing as vImageOverwriteChannels_ARGB8888 except that the newSrc buffer is in ARGB8888.
     * <p>
     * For each pixel in src, do the following:
     * [@code]
     * // Generate intMask to be 0xff for the channels that we want copy from newSrc to origSrc.
     * uint32_t    t = *(uint32_t*)newSrc;
     * uint32_t    b = *(uint32_t*)origSrc;
     * <p>
     * t  = (t & intMask ) | (b & ~intMask );
     * <p>
     * *(uint32_t*)dest = t;
     * [@endcode]
     * <p>
     * If the appropriate copyMask bit is set, then the color channel from newSrc is used. Otherwise the color channel from origSrc is used.
     * We note that functions of this kind only exist for interleaved buffers. If you had been using planar data, this would just be a pointer swap.
     * This will work for other channel orderings, such as RGBA8888.  You need to adjust the ordering of the bits in copyMask to compensate.
     * This can work in place provided that for each buffer "buf" that overlaps with dest:
     * buf->data must be equal to dest->data and buf->rowBytes >= dest->rowBytes
     * If buf has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param newSrc   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixel that we will overwrite with.
     * @param origSrc  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixel that we will overwrite into.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param copyMask A mask to copy plane : 0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue
     * @param flags    \p kvImageNoFlags          Default operation
     *                 \p kvImageDoNotTile        Disable internal multithreading.  You should use this if you are doing your own threading / tiling.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageSelectChannels_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer newSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer origSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, byte copyMask,
            int flags);

    /**
     * [@function] vImageSelectChannels_ARGBFFFF
     * <p>
     * Does the same thing as vImageOverwriteChannels_ARGBFFFF except that the newSrc buffer is in ARGBFFFF
     * <p>
     * For each pixel in src, do the following:
     * [@code]
     * // Generate intMask to be 0xffffffff for the channels that we want copy from newSrc to origSrc.
     * float    t = *(float*)newSrc;
     * float    b = *(float*)origSrc;
     * <p>
     * t  = (t & intMask ) | (b & ~intMask );
     * <p>
     * *(float*)dest = t;
     * [@endcode]
     * <p>
     * If the appropriate copyMask bit is set, then the color channel from newSrc is used. Otherwise the color channel from origSrc is used.
     * We note that functions of this kind only exist for interleaved buffers. If you had been using planar data, this would just be a pointer swap.
     * This will work for other channel orderings, such as RGBAFFFF.  You need to adjust the ordering of the bits in copyMask to compensate.
     * This can work in place provided that for each buffer "buf" that overlaps with dest:
     * buf->data must be equal to dest->data and buf->rowBytes >= dest->rowBytes
     * If buf has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
     *
     * @param newSrc   A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixel that we will overwrite with.
     * @param origSrc  A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing ARGB source pixel that we will overwrite into.
     * @param dest     A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing destination pixels.
     * @param copyMask A mask to copy plane : 0x8  -- alpha, 0x4 -- red, 0x2 --- green, 0x1 --- blue
     * @param flags    \p kvImageNoFlags          Default operation
     *                 \p kvImageDoNotTile        Disable internal multithreading.  You should use this if you are doing your own threading / tiling.
     * @return kvImageNoError                         Success
     * @return kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageSelectChannels_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer newSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer origSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, byte copyMask,
            int flags);

    /**
     * The following functions interleave the planar buffers pointed to by red, green and blue, with the scalar value in alpha, to
     * create a ARGB, BGRA or RGBA  four channel interleaved buffer.  These functions do not work in place.  Per all vImage functions
     * channel order is defined as memory order.
     * <p>
     * Flags:
     * kvImageGetTempBufferSize    returns 0. Does no work.
     * kvImageDoNotTile            Disables internal multithreading, if any.
     * <p>
     * Other flags cause the function to return kvImageUnknownFlagsBit.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                         Success
     * kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8ToXRGB8888(byte alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8ToBGRX8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red, byte alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_PlanarFToXRGBFFFF(float alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_PlanarFToBGRXFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red, float alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * The following functions de-interleave a XRGB, BGRX, or RGBX four-channel
     * buffer to create three planar buffers red, green, and blue, discarding
     * the fourth channel.  These functions do not work in place.  As with all
     * vImage functions, channel order is memory order.
     * <p>
     * Flags:
     * kvImageGetTempBufferSize    Returns 0, does nothing.
     * kvImageDoNotTile            Disables internal multithreading.
     * <p>
     * Other flags cause the function to return kvImageUnknownFlagsBit.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                         Success
     * kvImageBufferSizeMismatch              When the size of destination dimensions are different.
     * kvImageRoiLargerThanInputBuffer        The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_XRGB8888ToPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_BGRX8888ToPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_XRGBFFFFToPlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_BGRXFFFFToPlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red, int flags);

    /**
     * vImageConvert_RGB16UtoARGB16U
     * <p>
     * Convert RGB16U -> ARGB16U
     * <p>
     * <p>
     * vImageConvert_RGB16UtoRGBA16U
     * <p>
     * Convert RGB16U -> RGBA16U
     * <p>
     * <p>
     * vImageConvert_RGB16UtoBGRA16U
     * <p>
     * Convert RGB16U -> BGRA16U
     * <p>
     * <p>
     * Each channel is 16 bit unsigned.
     * 3-channel interleaved pixel buffers that contains RGB and 1 planar pixel buffer for A or
     * 'alpha' value are combined to create 4-channel interleaved pixel buffer.
     * 'premultiply' determines if this function will premultiply alpha value(s) to RGB values.
     * <p>
     * if (aSrc != NULL)
     * {
     * if (premultiply)
     * {
     * r = (aSrc[i] * rgb[i*3+0] + 32767) / 65535
     * g = (aSrc[i] * rgb[i*3+1] + 32767) / 65535
     * b = (aSrc[i] * rgb[i*3+2] + 32767) / 65535
     * <p>
     * argbDest[i*4+0] = aSrc[i];
     * argbDest[i*4+1] = r;
     * argbDest[i*4+2] = g;
     * argbDest[i*4+3] = b;
     * }
     * else
     * {
     * argbDest[i*4+0] = aSrc[i];
     * argbDest[i*4+1] = rgb[i*3+0];
     * argbDest[i*4+2] = rgb[i*3+1];
     * argbDest[i*4+3] = rgb[i*3+2];
     * }
     * }
     * else
     * {
     * if (premultiply)
     * {
     * r = (alpha * rgb[i*3+0] + 32767) / 65535
     * g = (alpha * rgb[i*3+1] + 32767) / 65535
     * b = (alpha * rgb[i*3+2] + 32767) / 65535
     * <p>
     * argbDest[i*4+0] = alpha;
     * argbDest[i*4+1] = r;
     * argbDest[i*4+2] = g;
     * argbDest[i*4+3] = b;
     * }
     * else
     * {
     * argbDest[i*4+0] = alpha;
     * argbDest[i*4+1] = rgb[i*3+0];
     * argbDest[i*4+2] = rgb[i*3+1];
     * argbDest[i*4+3] = rgb[i*3+2];
     * }
     * }
     * <p>
     * Operands:
     * ---------
     * rgbSrc : A pointer to vImage_Buffer that references RGB interleaved source pixels
     * <p>
     * aSrc : A pointer to vImage_Buffer that references A planar source pixels
     * <p>
     * alpha : A single alpha value
     * <p>
     * argbDest / rgbaDest / bgraDest : A pointer to vImage_Buffer that references ARGB / RGBA / BGRA interleaved destination pixels
     * <p>
     * Flags:
     * ------
     * kvImageGetTempBufferSize    Returns 0. Does no work.
     * kvImageDoNotTile            Disables internal multithreading, if any.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                     Is returned when there was no error.
     * kvImageRoiLargerThanInputBuffer    Is returned when src.width < dest.width || src.height < dest.height.
     * kvImageUnknownFlagsBit             Is returned when there is a unknown flag.
     * <p>
     * This function will not work in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB16UtoARGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer aSrc, char alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer argbDest,
            boolean premultiply, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB16UtoRGBA16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer aSrc, char alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbaDest,
            boolean premultiply, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB16UtoBGRA16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer aSrc, char alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer bgraDest,
            boolean premultiply, int flags);

    /**
     * vImageConvert_ARGB16UtoRGB16U
     * <p>
     * Convert ARGB16U -> RGB16U
     * <p>
     * <p>
     * vImageConvert_RGBA16UtoRGB16U
     * <p>
     * Convert RGBA16U -> RGB16U
     * <p>
     * <p>
     * vImageConvert_BGRA16UtoRGB16U
     * <p>
     * Convert BGRA16U -> RGB16U
     * <p>
     * <p>
     * Each channel is 16-bit unsigned
     * 4-channel interleaved pixel buffer becomes 3-channel interleaved pixel buffer by skipping to copy
     * the first channel in 4-channel interleaved pixel buffer.
     * <p>
     * rgbDest[i*3+0] = argbSrc[i*4+1];
     * rgbDest[i*3+1] = argbSrc[i*4+2];
     * rgbDest[i*3+2] = argbSrc[i*4+3];
     * <p>
     * Operands:
     * ---------
     * argbSrc / rgbaSrc / bgraSrc : A pointer to vImage_Buffer that references ARGB / RGBA / BGRA interleaved source pixels
     * <p>
     * rgbDest : A pointer to vImage_Buffer that references RGB interleaved destination pixels
     * <p>
     * Flags:
     * ------
     * kvImageGetTempBufferSize    Returns 0. Does no work.
     * kvImageDoNotTile            Disables internal multithreading, if any.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                     Is returned when there was no error.
     * kvImageRoiLargerThanInputBuffer    Is returned when src.width < dest.width || src.height < dest.height.
     * kvImageUnknownFlagsBit             Is returned when there is a unknown flag.
     * <p>
     * vImageConvert_RGBA16UtoRGB16U() can work in place if (argbSrc.data == rgbDest.data) && (argbSrc.rowBytes == rgbDest.rowBytes)
     * Rest of cases in these 3 functions will not work in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB16UtoRGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer argbSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbDest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGBA16UtoRGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbaSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbDest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_BGRA16UtoRGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer bgraSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbDest, int flags);

    /**
     * vImageConvert_Planar16UtoARGB16U
     * <p>
     * Convert Planar16U -> ARGB16U
     * <p>
     * <p>
     * Each channel is 16-bit unsigned
     * 4 planar pixel buffers are combined to create 4-channel interleaved pixel buffers.
     * <p>
     * argbDest[i*4+0] = aSrc[i];
     * argbDest[i*4+1] = rSrc[i];
     * argbDest[i*4+2] = gSrc[i];
     * argbDest[i*4+3] = bSrc[i];
     * <p>
     * This function can be used to create any channel order from 4 planar pixel buffers to interleaved
     * pixel buffers.
     * <p>
     * Operands:
     * ---------
     * aSrc : A pointer to vImage_Buffer that references A planar source pixels
     * <p>
     * rSrc : A pointer to vImage_Buffer that references R planar source pixels
     * <p>
     * gSrc : A pointer to vImage_Buffer that references G planar source pixels
     * <p>
     * bSrc : A pointer to vImage_Buffer that references B planar source pixels
     * <p>
     * argbDest : A pointer to vImage_Buffer that references ARGB interleaved destination pixels
     * <p>
     * Flags:
     * ------
     * kvImageGetTempBufferSize    Returns 0. Does no work.
     * kvImageDoNotTile            Disables internal multithreading, if any.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                     Is returned when there was no error.
     * kvImageRoiLargerThanInputBuffer    Is returned when src.width < dest.width || src.height < dest.height.
     * kvImageUnknownFlagsBit             Is returned when there is a unknown flag.
     * <p>
     * This function will not work in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar16UtoARGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer aSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer gSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer bSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer argbDest, int flags);

    /**
     * vImageConvert_ARGB16UtoPlanar16U
     * <p>
     * Convert ARGB16U -> Planar16U
     * <p>
     * <p>
     * Each channel is 16-bit unsigned
     * Each channel of 4-channel interleaved pixel buffer are copied into its planar pixel buffer.
     * <p>
     * aDest[i] = argbSrc[i*4+0];
     * rDest[i] = argbSrc[i*4+1];
     * gDest[i] = argbSrc[i*4+2];
     * bDest[i] = argbSrc[i*4+3];
     * <p>
     * This function can be used to create any channel order from interleaved pixel buffers to 4 planar
     * pixel buffers.
     * <p>
     * Operands:
     * ---------
     * argbSrc : A pointer to vImage_Buffer that references ARGB interleaved source pixels
     * <p>
     * aDest : A pointer to vImage_Buffer that references A planar destination pixels
     * <p>
     * rDest : A pointer to vImage_Buffer that references R planar destination pixels
     * <p>
     * gDest : A pointer to vImage_Buffer that references G planar destination pixels
     * <p>
     * bDest : A pointer to vImage_Buffer that references B planar destination pixels
     * <p>
     * Flags:
     * ------
     * kvImageGetTempBufferSize    Returns 0. Does no work.
     * vImageDoNotTile            Disables internal multithreading, if any.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                     Is returned when there was no error.
     * kvImageRoiLargerThanInputBuffer    Is returned when src.width < dest.width || src.height < dest.height.
     * kvImageUnknownFlagsBit             Is returned when there is a unknown flag.
     * <p>
     * This function will not work in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB16UtoPlanar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer argbSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer aDest,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rDest,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer gDest,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer bDest, int flags);

    /**
     * vImageConvert_Planar16UtoRGB16U
     * <p>
     * Planar16U -> RGB16U
     * <p>
     * <p>
     * Each channel is 16-bit unsigned
     * 3 planar pixel buffers are combined to create 3-channel interleaved pixel buffer.
     * <p>
     * rgbDest[i*3+0] = rSrc[i];
     * rgbDest[i*3+1] = gSrc[i];
     * rgbDest[i*3+2] = bSrc[i];
     * <p>
     * This function can be used to create any channel order from 3 planar pixel buffers to interleaved
     * pixel buffers.
     * <p>
     * Operands:
     * ---------
     * rSrc : A pointer to vImage_Buffer that references R planar source pixels
     * <p>
     * gSrc : A pointer to vImage_Buffer that references G planar source pixels
     * <p>
     * bSrc : A pointer to vImage_Buffer that references B planar source pixels
     * <p>
     * rgbDest : A pointer to vImage_Buffer that references RGB interleaved destination pixels
     * <p>
     * Flags:
     * ------
     * kvImageGetTempBufferSize    Returns 0. Does no work.
     * kvImageDoNotTile            Disables internal multithreading, if any.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                     Is returned when there was no error.
     * kvImageRoiLargerThanInputBuffer    Is returned when src.width < dest.width || src.height < dest.height.
     * kvImageUnknownFlagsBit             Is returned when there is a unknown flag.
     * <p>
     * This function will not work in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar16UtoRGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer gSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer bSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbDest, int flags);

    /**
     * vImageConvert_RGB16UtoPlanar16U
     * <p>
     * Planar16U <- RGB16U
     * <p>
     * Each channel is 16-bit unsigned
     * Each channel of 3-channel interleaved pixel buffer are copied into its planar pixel buffer.
     * <p>
     * rDest[i] = rgbSrc[i*3+0];
     * gDest[i] = rgbSrc[i*3+1];
     * bDest[i] = rgbSrc[i*3+2];
     * <p>
     * This function can be used to create any channel order from interleaved pixel buffers to 3 planar
     * pixel buffers.
     * <p>
     * Operands:
     * ---------
     * rgbSrc : A pointer to vImage_Buffer that references RGB interleaved source pixels
     * <p>
     * rDest : A pointer to vImage_Buffer that references R planar destination pixels
     * <p>
     * gDest : A pointer to vImage_Buffer that references G planar destination pixels
     * <p>
     * bDest : A pointer to vImage_Buffer that references B planar destination pixels
     * <p>
     * Flags:
     * ------
     * kvImageGetTempBufferSize    Returns 0. Does no work.
     * kvImageDoNotTile            Disables internal multithreading, if any.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                     Is returned when there was no error.
     * kvImageRoiLargerThanInputBuffer    Is returned when the height and width of the source are less than the height and width of the destination buffer, respectively.
     * kvImageUnknownFlagsBit             Is returned when there is a unknown flag.
     * <p>
     * This function will not work in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB16UtoPlanar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rgbSrc,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer rDest,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer gDest,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer bDest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar16UtoPlanar8_dithered(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int dither,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB16UtoRGB888_dithered(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int dither,
            int flags);

    /**
     * vImageByteSwap_Planar16U
     * <p>
     * This function does byteswap 16-bit pixel.
     * <p>
     * Operands:
     * ---------
     * src  : A pointer to vImage_Buffer that references 16-bit source pixels.
     * dest : A pointer to vImage_Buffer that references 16-bit destination pixels.
     * <p>
     * Flags:
     * ------
     * kvImageGetTempBufferSize    Returns 0. Does no work.
     * kvImageDoNotTile            Disables internal multithreading, if any.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                     Is returned when there was no error.
     * kvImageRoiLargerThanInputBuffer    Is returned when the height and width of the source are less than the height and width of the destination buffer, respectively.
     * kvImageUnknownFlagsBit             Is returned when there is a unknown flag.
     * <p>
     * This function can work in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageByteSwap_Planar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * vImageConvert_Planar1toPlanar8
     * vImageConvert_Planar2toPlanar8
     * vImageConvert_Planar4toPlanar8
     * <p>
     * These functions convert from 1-, 2-, or 4-bit per pixel to 8-bit per pixel
     * planar formats.
     * <p>
     * Function Arguments:
     * -------------------
     * src         Pointer to the source vImage_Buffer object.  Because the
     * source pixel format is smaller than a byte, there are
     * multiple pixels in each byte of the data buffer.  These
     * pixels are interpreted as being in big endian order (i.e.
     * the low-indexed pixel is in the high-order bits of the
     * byte).
     * <p>
     * Sub-byte indexing of scanlines is unsupported, because the
     * data and rowBytes fields of the buffer are specified in
     * whole bytes.
     * <p>
     * Widths, however, are measured in pixels, so a scanline may
     * end in the middle of a byte.  If this occurs, the contents
     * of any unused bits of the final byte are ignored.
     * <p>
     * dest        Pointer to the destination vImage_Buffer object.
     * <p>
     * flags       The following flags are allowed:
     * <p>
     * kvImageDoNotTile - disables internal threading.  You may
     * want to specify this if you have your own threading
     * scheme and need to avoid interference.
     * <p>
     * kvImageGetTempBufferSize - does no work and returns zero,
     * as these functions do not use temp buffers.
     * <p>
     * Operation:
     * ----------
     * For each pixel in the destination image, the resulting value is the
     * corresponding pixel value from the source image multiplied by 255, 85,
     * or 17 (for Planar1, Planar2, or Planar4, respectively).
     * <p>
     * <p>
     * Return values:
     * --------------
     * kvImageNoError                     Success
     * kvImageUnknownFlagsBit             No work was done because an unknown bit was
     * set in the flags parameter.
     * kvImageRoiLargerThanInputBuffer    No work was done because the source
     * image isn't large enough to cover the
     * destination image.
     * <p>
     * These functions do not work in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar1toPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar2toPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar4toPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8toPlanar1(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int dither, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8toPlanar2(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int dither, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar8toPlanar4(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int dither, int flags);

    /**
     * vImageConvert_8to16Q12
     * vImageConvert_RGB888toPlanar16Q12
     * vImageConvert_ARGB8888toPlanar16Q12
     * <p>
     * All three functions convert 8-bit pixel format to 16-bit format with 12
     * fractional bits.  The conversion is performed as follows:
     * <p>
     * uint16_t dest = ((src << 12) + 127)/255;
     * <p>
     * Source pixel values of 0 are mapped to 0, and source pixel values of 255
     * are mapped to 0x1000 (4096).  No larger values are produced by this
     * conversion, which provides some headroom to help subsequent operations
     * avoid overflow or clipping.
     * <p>
     * vImageConvert_8to16Q12 takes a single source buffer and a single
     * destination buffer and simply does the conversion.
     * <p>
     * vImageConvert_RGB888toPlanar16Q12 has three destination buffers, and
     * de-interleaves while it converts.
     * <p>
     * vImageConvert_ARGB8888toPlanar16Q12 takes four destination buffers, and
     * also de-interleaves.  Any channel order may be handled by the latter two
     * functions by permuting the order in which the destination buffers are
     * passed as arguments.
     * <p>
     * <p>
     * <p>
     * The only supported flags are:
     * <p>
     * kvImageDoNotTile            Turns off internal multithreading. You may
     * wish to do this if you have your own
     * multithreading scheme to avoid having the
     * two interfere with one another.
     * <p>
     * kvImageGetTempBufferSize    Returns zero, as the routine does not use
     * a temp buffer.
     * <p>
     * Passing any other flag will result in no work being done and an error
     * code being returned.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                  is returned when there was no error.
     * kvImageBufferSizeMismatch       the destination buffers do not have the
     * same size as each other
     * kvImageRoiLargerThanInputBuffer The destination buffers are larger than the
     * source buffer.
     * kvImageUnknownFlagsBit          is returned when there is a unknown flag.
     * <p>
     * This function will not operate in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_8to16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_RGB888toPlanar16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGB8888toPlanar16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue, int flags);

    /**
     * vImageConvert_16Q12to8
     * vImageConvert_Planar16Q12toRGB888
     * vImageConvert_Planar16Q12toARGB8888
     * <p>
     * All three functions convert 16-bit format with 12 fractional bits to 8-bit.
     * The conversion is performed as follows:
     * <p>
     * uint8_t dest = clamp(src, 0, 4096)*255 + 2048 >> 12
     * <p>
     * Source pixel values of 0 are mapped to 0, and source pixel values of 4088
     * or greater are mapped to 255.
     * <p>
     * vImageConvert_Planar16Q12toRGB888 and vImageConvert_Planar16Q12toARGB8888
     * interleave data from three or four buffers respectively while performing
     * the conversion.
     * <p>
     * The only supported flags are:
     * <p>
     * kvImageDoNotTile            Turns off internal multithreading. You may
     * wish to do this if you have your own
     * multithreading scheme to avoid having the
     * two interfere with one another.
     * <p>
     * kvImageGetTempBufferSize    Returns zero, as the routine does not use
     * a temp buffer.
     * <p>
     * Passing any other flag will result in no work being done and an error
     * code being returned.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                  is returned when there was no error.
     * kvImageBufferSizeMismatch       the destination buffers do not have the
     * same size as each other
     * kvImageRoiLargerThanInputBuffer The destination buffers are larger than the
     * source buffer.
     * kvImageUnknownFlagsBit          is returned when there is a unknown flag.
     * <p>
     * This function will not operate in place.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16Q12to8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar16Q12toRGB888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar16Q12toARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_16Q12to16F
     * <p>
     * Convert 16Q12 (16-bit format with 12 fractional bits) to half-precision floating-point.
     * <p>
     * Source pixel values of 0 are mapped to 0, and source pixel values of (Pixel_16Q12) 4096
     * are mapped to (Pixel_16F) 1.0f.
     * [@note] Works in place provided that src->data == dest->data && src->rowBytes == dest->rowBytes.
     *
     * @param src   The input image.
     * @param dest  A pointer to a preallocated vImage_Buffer to receive the resulting image.
     * @param flags \p kvImageDoNotTile            Disables internal multithreading, if any.
     *              \p kvImageGetTempBufferSize    Returns zero, as the routine does not use a temp buffer.
     * @return kvImageNoError                      There was no error.
     * @return kvImageBufferSizeMismatch           The destination buffers do not have the
     * same size as each other
     * @return kvImageRoiLargerThanInputBuffer     The destination buffers are larger than the
     * source buffer.
     * @return kvImageUnknownFlagsBit              Unknown flag(s) provided.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16Q12to16F(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_16Q12toRGB16F
     * <p>
     * Convert 16Q12 and interleave (16-bit format with 12 fractional bits) to half-precision floating-point.
     * <p>
     * Interleaves data from three source buffers while performing the format conversion.
     * Source pixel values of 0 are mapped to 0, and source pixel values of (Pixel_16Q12) 4096
     * are mapped to (Pixel_16F) 1.0f.
     * [@note] Does not work in place.
     *
     * @param red   The red channel of the input image.
     * @param green The green channel of the input image.
     * @param blue  The blue channel of the input image.
     * @param dest  A pointer to a preallocated vImage_Buffer to receive the resulting chunky image.
     * @param flags \p kvImageDoNotTile             Disables internal multithreading, if any.
     *              \p kvImageGetTempBufferSize     Returns zero, as the routine does not use a temp buffer.
     * @return kvImageNoError                      There was no error.
     * @return kvImageBufferSizeMismatch           The destination buffers do not have the
     * same size as each other
     * @return kvImageRoiLargerThanInputBuffer     The destination buffers are larger than the
     * source buffer.
     * @return kvImageUnknownFlagsBit              Unknown flag(s) provided.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar16Q12toRGB16F(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_Planar16Q12toARGB16F
     * <p>
     * Convert and interleave 16Q12 (16-bit format with 12 fractional bits) to half-precision floating-point.
     * <p>
     * Interleaves data from four source buffers while performing the format conversion.
     * Source pixel values of 0 are mapped to 0, and source pixel values of (Pixel_16Q12) 4096
     * are mapped to (Pixel_16F) 1.0f.
     * [@note] Does not work in place.
     *
     * @param alpha The alpha channel of the input image.
     * @param red   The red channel of the input image.
     * @param green The green channel of the input image.
     * @param blue  The blue channel of the input image.
     * @param dest  A pointer to a preallocated vImage_Buffer to receive the resulting chunky image.
     * @param flags \p kvImageDoNotTile            Disables internal multithreading, if any.
     *              \p kvImageGetTempBufferSize    Returns zero, as the routine does not use a temp buffer.
     * @return kvImageNoError                      There was no error.
     * @return kvImageBufferSizeMismatch           The destination buffers do not have the
     * same size as each other
     * @return kvImageRoiLargerThanInputBuffer     The destination buffers are larger than the
     * source buffer.
     * @return kvImageUnknownFlagsBit              Unknown flag(s) provided.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Planar16Q12toARGB16F(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer red,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer green,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer blue,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_16Fto16Q12
     * <p>
     * Convert half-precision floating-point to 16Q12 (16-bit format with 12 fractional bits).
     * <p>
     * Source pixel values of 0 are mapped to 0, and source pixel values of (Pixel_16F) 1.0f
     * are mapped to (Pixel_16Q12) 4096.
     * [@note] Works in place provided that src->data == dest->data && src->rowBytes == dest->rowBytes.
     *
     * @param src   The input image.
     * @param dest  A pointer to a preallocated vImage_Buffer to receive the resulting image.
     * @param flags \p kvImageDoNotTile            Disables internal multithreading, if any.
     *              \p kvImageGetTempBufferSize    Returns zero, as the routine does not use a temp buffer.
     * @return kvImageNoError                      There was no error.
     * @return kvImageBufferSizeMismatch           The destination buffers do not have the
     * same size as each other
     * @return kvImageRoiLargerThanInputBuffer     The destination buffers are larger than the
     * source buffer.
     * @return kvImageUnknownFlagsBit              Unknown flag(s) provided.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16Fto16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * vImageConvert_16Q12toF
     * vImageConvert_Fto16Q12
     * <p>
     * Convert 16-bit format with 12 fractional bits to floating-point.
     * The conversion is performed as follows:
     * <p>
     * float vImageConvert_16Q12toF_result = sample_16Q12 / 4096.0f
     * Pixel_16Q12 vImageConvert_Fto16Q12_result = CLAMP( -32768, lrintf(sample_float * 4096.0f), 32767)
     * <p>
     * Source pixel values of 0 are mapped to 0, and source pixel values of (Pixel_16Q12) 4096
     * is mapped to (Pixel_F) 1.0f.
     * <p>
     * The only supported flags are:
     * <p>
     * kvImageDoNotTile            Turns off internal multithreading. You may
     * wish to do this if you have your own
     * multithreading scheme to avoid having the
     * two interfere with one another.
     * <p>
     * kvImageGetTempBufferSize    Returns zero, as the routine does not use
     * a temp buffer. Does no work
     * <p>
     * Passing any other flag will result in no work being done and an error
     * code being returned.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                  is returned when there was no error.
     * kvImageRoiLargerThanInputBuffer one or more source buffers is smaller than the destination buffer.
     * kvImageUnknownFlagsBit          is returned when there is a unknown flag.
     * <p>
     * These functions will operate in place provided that src->data == dest->data && src->rowBytes == dest->rowBytes.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16Q12toF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_Fto16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * vImageConvert_16Q12to16U
     * vImageConvert_16Uto16Q12
     * <p>
     * Convert 16-bit format with 12 fractional bits to floating-point.
     * The conversion is performed as follows:
     * <p>
     * Pixel_16U vImageConvert_16Q12to16U_result = CLAMP( 0, (sample_16Q12 * 65535 + 2048) >> 12, 65535 )
     * Pixel_16Q12 vImageConvert_16Uto16Q12_result = (sample_16U * 4096 + 32767) / 65535;
     * <p>
     * Source pixel values of 0 are mapped to 0, and source pixel values of (Pixel_16Q12) 4096
     * is mapped to (Pixel_16U) 65535.
     * <p>
     * The only supported flags are:
     * <p>
     * kvImageDoNotTile            Turns off internal multithreading. You may
     * wish to do this if you have your own
     * multithreading scheme to avoid having the
     * two interfere with one another.
     * <p>
     * kvImageGetTempBufferSize    Returns zero, as the routine does not use
     * a temp buffer. Does no work
     * <p>
     * Passing any other flag will result in no work being done and an error
     * code being returned.
     * <p>
     * Return Value:
     * -------------
     * kvImageNoError                  is returned when there was no error.
     * kvImageRoiLargerThanInputBuffer one or more source buffers is smaller than the destination buffer.
     * kvImageUnknownFlagsBit          is returned when there is a unknown flag.
     * <p>
     * These functions will operate in place provided that src->data == dest->data && src->rowBytes == dest->rowBytes.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16Q12to16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_16Uto16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageConvert_YpCbCrToARGB_GenerateConversion
     * <p>
     * Generates the conversion from a YpCbCr to a ARGB pixel format.
     * <p>
     * This function is used to create the vImage_YpCbCrToARGB conversion information necessary for all
     * of YUV -> RGB conversion functions.
     * <p>
     * For example, if we want to prepare for the conversion from 'yuvs' with ITU 601 video range to ARGB8888, then we
     * need to do the following:
     *
     * <pre> @textblock
     * VIMAGE_PF vImage_Error err = kvImageNoError;
     * vImage_Flags flags = kvImageNoFlags;
     * vImage_YpCbCrPixelRange pixelRange;
     * vImage_YpCbCrToARGB outInfo;
     *
     * pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     * pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     * pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     * pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     * pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' > 1.
     * pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' < 0.
     * pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr > 0.5
     * pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr < -0.5
     * //                ( pixelRange.CbCr_bias - (pixelRange.CbCrRangeMax - pixelRange.CbCr_bias) = 2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax )
     *
     * err = vImageConvert_YpCbCrToARGB_GenerateConversion(kvImageITU601_YpCbCrToARGBMatrix, &pixelRange, &outInfo, kvImage422YpCbYpCr8, kvImageARGB8888, flags);
     * @/textblock </pre>
     * <p>
     * If we want to define our own conversion coefficents, then we can do
     *
     * <pre> @textblock
     * vImage_YpCbCrToARGBMatrix matrix;
     * vImage_YpCbCrPixelRange pixelRange;
     *
     * matrix.Yp                  =  1.0f;
     * matrix.Cb_G                = -0.3441f;
     * matrix.Cb_B                =  1.772f;
     * matrix.Cr_R                =  1.402f;
     * matrix.Cr_G                = -0.7141f;
     *
     * pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     * pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     * pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     * pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     * pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' > 1.
     * pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' < 0.
     * pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr > 0.5
     * pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr < -0.5
     * //                ( pixelRange.CbCr_bias - (pixelRange.CbCrRangeMax - pixelRange.CbCr_bias) = 2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax )
     *
     * err = vImageConvert_YpCbCrToARGB_GenerateConversion(&matrix, &pixelRange, &outInfo, kvImage422YpCbYpCr8, kvImageARGB8888, flags).
     * @/textblock </pre>
     * <p>
     * <p>
     * vImage_YpCbCrToARGB created may be reused multiple times from multiple threads concurrently.
     * <p>
     * Here are the conversions available currently.
     *
     * <pre>
     * @textblock
     * RGB8   RGB16Q12    RGB16
     * YUV8     Y        N          N
     * YUV10    Y        Y          N
     * YUV12    Y        Y          N
     * YUV14    Y        N          Y
     * YUV16    Y        N          Y
     * @/textblock
     * </pre>
     *
     * @param matrix       A pointer to vImage_YpCbCrToARGBMatrix that contains the matrix coefficients for the conversion
     *                     from a YpCbCr to a ARGB pixel format.
     * @param pixelRange   A pointer to vImage_YpCbCrPixelRange that contains the pixel range information for the conversion
     *                     from a YpCbCr to a ARGB pixel format.
     * @param outInfo      A pointer to vImage_YpCbCrToRGB will be initialized with the information for the conversion function
     *                     will use later.
     * @param inYpCbCrType A YpCbCrType to specify the input YpCbCr format.
     * @param outARGBType  A ARGBType to specify the output ARGB format.
     * @param flags        kvImagePrintDiagnosticsToConsole   Directs the function to print diagnostic information to the console in the event of failure.
     * @return The following return codes may occur:
     * <pre> @textblock
     * kvImageNoError                  Is returned when there was no error.
     * kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     * kvImageUnsupportedConversion    Is returned when there is no conversion in vImage for inYpCbCrType & outARGBType.
     * @/textblock  </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_YpCbCrToARGB_GenerateConversion(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_YpCbCrToARGBMatrix matrix,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_YpCbCrPixelRange pixelRange,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_YpCbCrToARGB outInfo,
            int inYpCbCrType, int outARGBType, int flags);

    /**
     * [@function] vImageConvert_ARGBToYpCbCr_GenerateConversion
     * <p>
     * Generates the conversion from a ARGB to a YpCbCr pixel format.
     * <p>
     * This function is used to create the vImage_ARGBToYpCbCr conversion information necessary for all
     * of RGB -> YUV conversion functions.
     * <p>
     * For example, if we want to prepare for the conversion from ARGB8888 'yuvs' with ITU 601 video range, then we
     * need to do the following:
     *
     * <pre> @textblock
     * VIMAGE_PF vImage_Error err = kvImageNoError;
     * vImage_Flags flags = kvImageNoFlags;
     * vImage_YpCbCrPixelRange pixelRange;
     * vImage_ARGBToYpCbCr outInfo;
     *
     * pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     * pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     * pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     * pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     * pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' > 1.
     * pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' < 0.
     * pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr > 0.5
     * pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr < -0.5
     *
     * err = vImageConvert_ARGBToYpCbCr_GenerateConversion(kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4, &pixelRange, &outInfo, kvImageARGB8888, kvImage422YpCbYpCr8, flags);
     *
     *
     * If we want to define our own conversion coefficents, then we can do
     *
     * vImage_ARGBToYpCbCrMatrix matrix;;
     * vImage_YpCbCrPixelRange pixelRange;
     *
     * matrix.R_Yp          =  0.2989f;
     * matrix.G_Yp          =  0.5866f;
     * matrix.B_Yp          =  0.1144f;
     * matrix.R_Cb          = -0.1688f;
     * matrix.G_Cb          = -0.3312f;
     * matrix.B_Cb_R_Cr     =  0.5f;
     * matrix.G_Cr          = -0.4183f;
     * matrix.B_Cr          = -0.0816f;
     * pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     * pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     * pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     * pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     * pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' > 1.
     * pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' < 0.
     * pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr > 0.5
     * pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr < -0.5
     *
     * err = vImageConvert_ARGBToYpCbCr_GenerateConversion(&matrix, &pixelRange, &outInfo, kvImageARGB8888, kvImage422YpCbYpCr8, flags);
     *
     *
     * vImage_ARGBToYpCbCr created may be reused multiple times from multiple threads concurrently.
     *
     * Here are the conversions available currently.
     *
     * RGB8   RGB16Q12    RGB16
     * YUV8     Y        N          N
     * YUV10    Y        Y          N
     * YUV12    Y        Y          N
     * YUV14    Y        N          Y
     * YUV16    Y        N          Y
     * @/textblock </pre>
     *
     * @param matrix        A pointer to vImage_ARGBToYpCbCrMatrix that contains the matrix coefficients for the conversion
     *                      from a ARGB to a YpCbCr pixel format.
     * @param pixelRange    A pointer to vImage_YpCbCrPixelRange that contains the pixel range information for the conversion
     *                      from a ARGB to a YpCbCr pixel format.
     * @param outInfo       A pointer to vImage_ARGBToYpCbCr will be initialized with the information for the conversion function
     *                      will use later.
     * @param inARGBType    A ARGBType to specify the output ARGB format.
     * @param outYpCbCrType A YpCbCrType to specify the input YpCbCr format.
     * @param flags         kvImagePrintDiagnosticsToConsole   Directs the function to print diagnostic information to the console in the event of failure.
     * @return <pre> @textblock
     * kvImageNoError                  Is returned when there was no error.
     * kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     * kvImageUnsupportedConversion    Is returned when there is no conversion in vImage for inARGBType & outYpCbCrType.
     * @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_ARGBToYpCbCr_GenerateConversion(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_ARGBToYpCbCrMatrix matrix,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_YpCbCrPixelRange pixelRange,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_ARGBToYpCbCr outInfo,
            int inARGBType, int outYpCbCrType, int flags);

    /**
     * [@function] vImageCopyBuffer
     * <p>
     * Copy vImage buffer from src to dest.
     *
     * @param src       A pointer to source vImage_Buffer.
     * @param dest      A pointer to destination vImage_Buffer.
     * @param pixelSize Number of bytes for one pixel.
     * @param flags     \p kvImageDoNotTile            Disables internal multithreading, if any.
     *                  \p kvImageGetTempBufferSize    Returns 0. Does no work.
     * @return \p kvImageNoError                      Is returned when there was no error.
     * @return \p kvImageRoiLargerThanInputBuffer     Is returned when src.width < dest.width || src.height < dest.height
     * @see vImage_Buffer
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageCopyBuffer(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long pixelSize, int flags);

    /**
     * vImageRotate_<fmt>
     * =================
     * vImageRotate_<fmt> is a convenience function to provide facile rotation of images about their center point. The operation can also be done with vImageWarp_<fmt>, or
     * by using appropriate low level vImageHorizontal/VerticalShear_<fmt> interfaces. vImageWarp_<fmt> may be appropriate if you wish to rotate around a non-center point in
     * the image. vImageHorizontal/VerticalShear_<fmt> will provide the greatest detail in control, since it allows for alternative sampling methods, and also the opportunity to
     * control how tiling is done. This might allow for better cache utilization in cases where a format conversion (or other fast filter) is required either before or after
     * the scaling operation and you wish to incorporate it into your tiling design.
     * <p>
     * To avoid artifacts in high frequency regions of the image, the data should be non-premultiplied, or at minimum have the same alpha over the entire image. For integer
     * formats with constant alpha < PIXEL_MAX, it is possible for result color values to be greater than alpha.  vImageClipToAlpha_<fmt> can be used to correct that problem.
     * Some other functions like vImageUnpremultiplyData_<fmt> will correct the problem as part of their operation, if they appear later in your image pipeline.
     * Otherwise, integer formats are clamped in the range [0,255] and can not experience modulo overflow problems. For floating-point formats, it is always possible to
     * produce out-of-gamut or greater than alpha results, most often in high-frequency regions of the image. Out-of-gamut results are often resolved when the floating-point
     * format is converted to an integer format in a later vImage call -- all conversions to integer format are clamped to the representable range. However, color values
     * greater than alpha will persist if the alpha is less than fully opaque, and can be fixed by vImageClipToAlpha_<fmt> as with the integer formats.
     * vImageUnpremultiplyData_<fmt> and vImagePremultiplyData_<fmt> are much, much faster than vImageRotate_<fmt> and typically only add a few percent to the overall cost
     * of the filter.
     * <p>
     * vImageRotate_<fmt>() does not work in place
     * The ARGB8888, ARGB16U, ARGB16S and ARGBFFFF functions work equally well on other channel orderings of 4-channel images, such as RGBA or BGRA.
     * <p>
     * Acceptable flags are kvImageEdgeExtend, kvImageBackgroundColorFill, kvImageDoNotTile, kvImageHighQualityResampling, kvImageNoFlags. If no edging mode is passed,
     * the edging mode is undefined. You may not pass both kvImageEdgeExtend and kvImageBackgroundColorFill. kvImageEdgeExtend will leave odd stripes in areas for which
     * no corresponding source image pixel exists, corresponding to the value of the nearest edge pixel, for some value of "nearest". kvImageBackgroundColorFill is most
     * commonly used.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageRotate_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            float angleInRadians, byte backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageRotate_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            float angleInRadians, float backColor, int flags);

    /**
     * vImageScale_<fmt>
     * =================
     * vImageScale_<fmt> is a convenience function to provide facile resizing of images.
     * The operation can also be done with vImageWarp_<fmt>, or by using appropriate
     * low level vImageHorizontal/VerticalShear_<fmt> interfaces. vImageWarp_<fmt>
     * may be appropriate if you wish to use an edging mode other than kvImageEdgeExtend.
     * vImageHorizontal/VerticalShear_<fmt> will provide the greatest detail in control,
     * since it allows for alternative sampling methods, and also the opportunity to
     * control how tiling is done. This might allow for better cache utilization in
     * cases where a format conversion (or other fast filter) is required either before
     * or after the scaling operation and you wish to incorporate it into your tiling design.
     * <p>
     * To avoid artifacts in high frequency regions of the image, the data should be
     * non-premultiplied, or at minimum have the same alpha over the entire image.
     * For integer formats with constant alpha < PIXEL_MAX, it is possible for result
     * color values to be greater than alpha.
     * vImageClipToAlpha_<fmt> can be used to correct that problem.
     * Some other functions like vImageUnpremultiplyData_<fmt> will correct the problem
     * as part of their operation, if they appear later in your image pipeline.
     * Otherwise, integer formats are clamped in the range [PIXEL_MIN,PIXEL_MAX] and can not
     * experience modulo overflow problems. For floating-point formats, it is always
     * possible to produce out-of-gamut or greater than alpha results, most often in
     * high-frequency regions of the image. Out-of-gamut results are often resolved
     * when the floating-point format is converted to an integer format in a later vImage
     * call -- all conversions to integer format are clamped to the representable range.
     * However, color values greater than alpha will persist if the alpha is less than
     * fully opaque, and can be fixed by vImageClipToAlpha_<fmt> as with the integer formats.
     * vImageUnpremultiplyData_<fmt> and vImagePremultiplyData_<fmt> are much, much faster
     * than vImageScale_<fmt> and typically only add a few percent to the overall cost
     * of the filter.
     * <p>
     * vImageScale_<fmt>() does not work in place
     * The ARGB8888, ARGB16U, ARGB16S and ARGBFFFF functions work equally well on
     * other channel orderings of 4-channel images, such as RGBA or BGRA.
     * <p>
     * Acceptable flags are kvImageEdgeExtend, kvImageDoNotTile,
     * kvImageHighQualityResampling, kvImageNoFlags.
     * If no edging mode is passed, kvImageEdgeExtend is used.
     * Developers using vImageScale_<fmt> on MacOS X.3 should pass kvImageEdgeExtend
     * in the flags field to avoid ringing artifacts at the edges of images
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_Planar16S(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_Planar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_ARGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_ARGB16S(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_CbCr8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_CbCr16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageScale_XRGB2101010W(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int flags);

    /**
     * vImageAffineWarp_<fmt>
     * ======================
     * vImageAffineWarp_<fmt> is a convenience function to provide facile affine transformation of images. The operation can also be done by using appropriate low level
     * vImageHorizontal/VerticalShear_<fmt> interfaces. vImageHorizontal/VerticalShear_<fmt> will provide the greatest detail in control, since it allows for alternative
     * sampling methods, and also the opportunity to control how tiling is done, possibly allowing for better cache utilization in cases where a format conversion (or
     * other fast filter) is required either before or after the scaling operation and you wish to incorporate it into your tiling design.
     * <p>
     * To avoid artifacts in high frequency regions of the image, the data should be non-premultiplied, or at minimum have the same alpha over the entire image. For integer
     * formats with constant alpha < 255, it is possible for result color values to be greater than alpha.  vImageClipToAlpha_<fmt> can be used to correct that problem.
     * Some other functions like vImageUnpremultiplyData_<fmt> will correct the problem as part of their operation, if they appear later in your image pipeline.
     * Otherwise, integer formats are clamped in the range [PIXEL_MIN, PIXEL_MAX] and can not experience modulo overflow problems. For floating-point formats, it is always possible to
     * produce out-of-gamut or greater than alpha results, most often in high-frequency regions of the image. Out-of-gamut results are often resolved when the floating-point
     * format is converted to an integer format in a later vImage call -- all conversions to integer format are clamped to the representable range. However, color values
     * greater than alpha will persist if the alpha is less than fully opaque, and can be fixed by vImageClipToAlpha_<fmt> as with the integer formats.
     * vImageUnpremultiplyData_<fmt> and vImagePremultiplyData_<fmt> are much, much faster than vImageAffineWarp_<fmt> and typically only add a few percent to the overall cost
     * of the filter.
     * <p>
     * For the Affine Transform function, the coordinate space places the origin at the bottom left corner of the image. Positive movement in the X and Y direction moves you
     * right and up. Both source and destination images are assumed to place their bottom left hand corner at the origin.
     * <p>
     * vImageAffineWarp_<fmt>() does not work in place
     * The ARGB8888, ARGB16U, ARGB16S and ARGBFFFF functions work equally well on other channel orderings of 4-channel images, such as RGBA or BGRA.
     * <p>
     * Acceptable flags are kvImageEdgeExtend, kvImageBackgroundColorFill, kvImageDoNotTile, kvImageHighQualityResampling, kvImageNoFlags. If no edging mode is passed, the edging
     * mode is undefined. You may not pass both kvImageEdgeExtend and kvImageBackgroundColorFill. kvImageEdgeExtend will leave odd stripes in areas for which no corresponding source
     * image pixel exists, corresponding to the value of the nearest edge pixel, for some value of "nearest". kvImageBackgroundColorFill is most commonly used, except when the result
     * will be cropped to cover only regions present in the original image and no background color leakage into the edges of the result image are desired.
     * <p>
     * Versions of the API that use alternative formulations of the affine transform matrix follow immediately afterward.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAffineWarp_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_AffineTransform transform,
            byte backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageAffineWarp_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_AffineTransform transform,
            float backColor, int flags);

    /**
     * A single precision transformation matrix is often not enough. This one uses double precision.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAffineWarpD_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_AffineTransform_Double transform,
            byte backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageAffineWarpD_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_AffineTransform_Double transform,
            float backColor, int flags);

    /**
     * Convenience Interfaces for working directly with CGAffineTransform, which changes size depending on whether we are LP64 or not.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageAffineWarpCG_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_AffineTransform_Double transform,
            byte backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageAffineWarpCG_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_AffineTransform_Double transform,
            float backColor, int flags);

    /**
     * Low Level Geometry Functions
     * ----------------------------
     * <p>
     * vImage also provides a series of low level geometry functions that do simple, often 1-D transforms on images.
     * They are:
     * <p>
     * Reflect -- reflect an image across a  mirror plane at the center of the image in the x or y direction
     * Shear --  shear and rescale an image in the x or y direction
     * Rotate90 -- rotate an image by 0, 90, 180 or 270 degrees
     * <p>
     * The Reflect functions simply reflect images horizontally or vertically. Horizontal reflection inverts the image
     * left to right as if seen from behind. Vertical reflection causes the image to appear upside down.
     * <p>
     * Acceptable flags are kvImageDoNotTile, kvImageNoFlags.
     * <p>
     * These functions do not work in place.
     * <p>
     * All four channel geometry functions (i.e. those that support ARGB8888, ARGB16U, ARGB16S or ARGBFFFF images) work equally well on four channel images
     * with other channel orderings such as RGBA or BGRA.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalReflect_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalReflect_Planar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalReflect_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalReflect_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalReflect_ARGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalReflect_ARGB16S(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalReflect_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalReflect_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalReflect_Planar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalReflect_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalReflect_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalReflect_ARGB16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalReflect_ARGB16S(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalReflect_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * The Rotate90 function does simple 0, 90, 180 or 270 degree rotation according to the value of a rotation constant
     * passed to it. The images are rotated about their center. If the source and destination sizes do not match, parts
     * of the image may be cut off. Other parts may have no image, in which case the background color will be drawn there.
     * <p>
     * CAUTION: 90 and 270 degree rotation does not rotate about the true center of the image if the height of the source image
     * is an odd number of pixels and the width of the destination image an even number of pixels, or vice versa. This is also
     * true of the source width and destination height. In this case, you should use the High level rotate function for 90 or
     * 270 rotates so that the resampling can be done to shift the image a half pixel for proper centering. It may be somewhat
     * faster to widen the destination image by 1 and use the low level shearing functions to resample the image at a a half pixel offset.
     * For 0 and 180 degree rotates, if the source and destination buffers are a different size, the two heights must have matching
     * even/oddness and the two widths must have matching even/oddness. Otherwise the image will be rotated and shifted a half pixel
     * away from the center.
     * <p>
     * rotationConstant:    0 -- rotate 0 degrees (simply copy the data from src to dest)
     * 1 -- rotate 90 degrees counterclockwise
     * 2 -- rotate 180 degress
     * 3 -- rotate 270 degrees counterclockwise
     * <p>
     * backColor:    The color of the background. This color will be copied to any place where pixels are revealed because
     * the input image does not completely cover the output image.
     * <p>
     * Acceptable flags are kvImageDoNotTile, kvImageNoFlags.
     * <p>
     * These functions do not work in place.
     * <p>
     * All four channel geometry functions (i.e. those that support ARGB8888, ARGB16U, ARGB16S or ARGBFFFF images) work equally well on
     * four channel images with other channel orderings such as RGBA or BGRA.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageRotate90_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            byte rotationConstant, byte backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageRotate90_Planar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            byte rotationConstant, char backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageRotate90_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            byte rotationConstant, float backColor, int flags);

    /**
     * The Shearing functions use resampling to rescale a image and offset it to
     * fractional pixel offsets. The functions actually shear, resize in one
     * dimension and translate. All of it is done with fractional pixel precision.
     * The shear slope is set using the shearSlope parameter. They are intended to
     * be identical to the off diagonal components of the AffineWarp matrix for the
     * same shear (i.e. at 1,0 or 0,1). The xTranslate or yTranslate variable may
     * be used to adjust the position of the destination image in the x and y
     * directions. Scaling (making the image larger or smaller in one dimension)
     * is done by adjusting the resampling kernel.
     * <p>
     * All four channel geometry functions (i.e. those that support ARGB8888,
     * ARGB16U, ARGB16S or ARGBFFFF images) work equally well on four channel
     * images with other channel orderings such as RGBA or BGRA.
     * <p>
     * These functions do not work in place.
     * <p>
     * Acceptable flags are kvImageEdgeExtend, kvImageBackgroundColor,
     * kvImageDoNotTile, kvImageNoFlags.
     * Only one of kvImageEdgeExtend or kvImageBackgroundColor may be used.
     * If none is used then the edging mode is undefined and the results may be
     * unpredictable.
     * <p>
     * The ResamplingFilter is created using vImageNewResamplingFilter or
     * vImageNewResamplingFilterForFunctionUsingBuffer. The latter gives more
     * precise control over where the memory is allocated and which filter function
     * is used, at the expense of having to define / setup the same.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalShear_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float xTranslate, float shearSlope,
            VoidPtr filter, byte backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalShear_Planar16S(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float xTranslate, float shearSlope,
            VoidPtr filter, short backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalShear_Planar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float xTranslate, float shearSlope,
            VoidPtr filter, char backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalShear_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float xTranslate, float shearSlope,
            VoidPtr filter, float backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalShear_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float yTranslate, float shearSlope,
            VoidPtr filter, byte backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalShear_Planar16S(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float yTranslate, float shearSlope,
            VoidPtr filter, short backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalShear_Planar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float yTranslate, float shearSlope,
            VoidPtr filter, char backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalShear_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float yTranslate, float shearSlope,
            VoidPtr filter, float backColor, int flags);

    /**
     * Versions of shear functions that take coordinates in double precision
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalShearD_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, double xTranslate, double shearSlope,
            VoidPtr filter, byte backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalShearD_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, double xTranslate, double shearSlope,
            VoidPtr filter, float backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalShearD_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, double yTranslate, double shearSlope,
            VoidPtr filter, byte backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalShearD_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, double yTranslate, double shearSlope,
            VoidPtr filter, float backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageHorizontalShear_XRGB2101010W(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float xTranslate, float shearSlope,
            VoidPtr filter, int backColor, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageVerticalShear_XRGB2101010W(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, float yTranslate, float shearSlope,
            VoidPtr filter, int backColor, int flags);

    /**
     * The shearing functions use a resampling filter for their work. Before you call these functions you must
     * create a new filter. The filter must be remade for different scaling factors, but may be reused in different
     * function calls if the scaling factor is the same.
     * <p>
     * For general purpose work, use NewResamplingFilter() to create a resampling filter. It currently uses
     * either Lanczos3 or Lanczos5 filter, depending on whether the kvImageHighQualityResampling bit is set in the flags field.
     * What filter is used is subject to change.
     * <p>
     * ResamplingFilter kernel = NewResamplingFilter( theScale, kvImageHighQualityResampling );
     * <p>
     * Use DestroyResamplingFilter() when you are done with the filter to return the memory it uses to the heap.
     * <p>
     * The scale parameter sets the level of rescaling to be done. A value of 1.0f leaves the image at its
     * original size. 2.0f will magnify in one direction to make the image twice as wide / tall. 0.5f will
     * make it half as wide / tall. Any float is allowed, including negative values, which will have the effect
     * of flipping the image along that axis. Scaling will happen relative to the left or bottom edge of the image.
     * <p>
     * Set the kvImageEdgeExtend bit in the flags field if you would like the image buffer edges extended infinitely
     * rather than use the backColor value. This is useful when you do not wish a background color to bleed into
     * the edges of your image. This is generally only useful when the shear angle is 0.
     */
    @Generated
    @CFunction
    public static native VoidPtr vImageNewResamplingFilter(float scale, int flags);

    @Generated
    @CFunction
    public static native void vImageDestroyResamplingFilter(VoidPtr filter);

    /**
     * vImageNewResamplingFilter and vImageDestroyResamplingFilter are merely convenience functions to make
     * the common case of the default resampling filter into a heap allocated buffer easier for you.
     * <p>
     * If you would like to use your own special purpose resampling filter or need to restrict your use of malloc,
     * you may instead call NewResamplingFilterForFunctionUsingBuffer(), which creates a filter for a specific
     * resampling filter function that you provide in the form of a simple y = f(x) function, and writes it into a buffer
     * that you provide. This function writes the kernel values into a preallocated kernel buffer that you provide. The
     * kernel buffer should be at least the size of the kernel data, which is given by vImageGetResamplingKernelSize.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageNewResamplingFilterForFunctionUsingBuffer(VoidPtr filter, float scale,
            @FunctionPtr(name = "call_vImageNewResamplingFilterForFunctionUsingBuffer") Function_vImageNewResamplingFilterForFunctionUsingBuffer kernelFunc,
            float kernelWidth, VoidPtr userData, int flags);

    @Generated
    @CFunction
    @NUInt
    public static native long vImageGetResamplingFilterSize(float scale,
            @FunctionPtr(name = "call_vImageGetResamplingFilterSize") Function_vImageGetResamplingFilterSize kernelFunc,
            float kernelWidth, int flags);

    /**
     * vImageGetSamplingFilterExtent
     * <p>
     * returns the maximum sampling radius for the resampling filter.  This is the maximum distance from any pixel
     * that the filter will look either horizontally or vertically, depending on whether vImageHorizontalShear or
     * vImageVerticalShear is used.  It is analogous to kernelWidth in vImageNewResamplingFilterForFunctionUsingBuffer,
     * but might be slightly larger to allow for extra slop when dealing with sub-pixel coordinates during resampling.
     * <p>
     * filter      a valid ResamplingFilter
     * flags       the flags you intend to pass to vImage{Horizontal/Vertical}Shear_<fmt>.
     */
    @Generated
    @CFunction
    @NUInt
    public static native long vImageGetResamplingFilterExtent(VoidPtr filter, int flags);

    /**
     * [@function] vImageHistogramCalculation_Planar8
     * <p>
     * Calculates a histogram for a Planar8 image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      For each pixel, do the following:
     *          histogram[src[x]]++;
     * @/textblock</pre>
     * <p>
     * This routine will not work in place
     *
     * @param src       A pointer to a vImage_Buffer that references the source pixels
     * @param histogram A pointer to a histogram. On return, this array will
     *                  contain the histogram for the source image.
     *                  The histogram will be an array with 256 elements.
     * @param flags     The following flags are allowed:
     *                  <pre>@textblock
     *                           kvImageDoNotTile         Turns off internal multithreading. You may
     *                                                    wish to do this if you have your own
     *                                                    multithreading scheme to avoid having the
     *                                                    two interfere with one another.
     *                  @/textblock</pre>
     * @return The following error codes may be returned
     * <pre>@textblock
     *   kvImageNoError                  Success!
     *   kvImageNullPointerArgument      src or histogram pointer is NULL.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageHistogramCalculation_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src, NUIntPtr histogram,
            int flags);

    /**
     * [@function] vImageHistogramCalculation_PlanarF
     * <p>
     * Calculates a histogram for a PlanarF image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      For each pixel, do the following:
     *          val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
     *          i = clip val between 0 and histogram_entries-1
     *          histogram[i]++;
     * @/textblock</pre>
     * <p>
     * This routine will not work in place
     *
     * @param src               A pointer to a vImage_Buffer that references the source pixels
     * @param histogram         A pointer to a histogram. On return, this array will
     *                          contain the histogram for the source image.
     *                          The histogram will have histogram_entries elements.
     * @param histogram_entries The number of histogram entries, or bins.
     *                          The histogram will be an array with histogram_entries elements.
     * @param minVal            A minimum pixel value. Any pixel value less than this will be
     *                          clipped to this value (for the purposes of histogram calculation),
     *                          and assigned to the first histogram entry. src is not modified.
     * @param maxVal            A maximum pixel value. Any pixel value greater than this will
     *                          be clipped to this value (for the purposes of histogram calculation),
     *                          and assigned to the last histogram entry.  src is not modified.
     * @param flags             The following flags are allowed:
     *                          <pre>@textblock
     *                                   kvImageDoNotTile         Turns off internal multithreading. You may
     *                                                            wish to do this if you have your own
     *                                                            multithreading scheme to avoid having the
     *                                                            two interfere with one another.
     *                          @/textblock</pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *   kvImageNoError                  Success!
     *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0
     *   kvImageNullPointerArgument      src or histogram pointer is NULL.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageHistogramCalculation_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src, NUIntPtr histogram,
            int histogram_entries, float minVal, float maxVal, int flags);

    /**
     * [@function] vImageEqualization_Planar8
     * <p>
     * Equalizes the histogram of a Planar8 source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      Compute the histogram of the input image;
     *      Calculate normalized sum of histogram;
     *      For each pixel, do the following:
     *          dest[x] = equalized_histogram[src[x]];
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     *
     * @param src   A pointer to a vImage_Buffer that references the source pixels
     * @param dest  A pointer to a vImage buffer that references the destination pixels
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                       kvImageDoNotTile         Turns off internal multithreading. You may
     *                                                wish to do this if you have your own
     *                                                multithreading scheme to avoid having the
     *                                                two interfere with one another.
     *              @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *   kvImageNoError                  Success!
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
     *   kvImageNullPointerArgument      src or dest pointer is NULL.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageEqualization_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageEqualization_PlanarF
     * <p>
     * Equalizes the histogram of a PlanarF source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      Compute the histogram of the input image:
     *          For each pixel, do the following:
     *              val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
     *              i = clip val between 0 and histogram_entries-1
     *              histogram[i]++;
     *      Calculate normalized sum of histogram;
     *      For each pixel, do the following:
     *          val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
     *          i = clip val between 0 and histogram_entries-1
     *          dest[x] = equalized_histogram[i];
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     *
     * @param src               A pointer to a vImage_Buffer that references the source pixels
     * @param dest              A pointer to a vImage buffer that references the destination pixels
     * @param tempBuffer        A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
     *                          then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
     *                          in which case you are responsible for deallocating it when you is no longer need it.
     *                          If you want to allocate the buffer yourself, see the documentation for information
     *                          on how to determine the minimum size that you must allocate.
     * @param histogram_entries The number of histogram entries, or bins.
     *                          The histogram will be an array with histogram_entries elements.
     * @param minVal            A minimum pixel value. Any pixel value less than this will be
     *                          clipped to this value (for the purposes of histogram calculation),
     *                          and assigned to the first histogram entry.
     * @param maxVal            A maximum pixel value. Any pixel value greater than this will
     *                          be clipped to this value (for the purposes of histogram calculation),
     *                          and assigned to the last histogram entry.
     * @param flags             The following flags are allowed:
     *                          <pre>@textblock
     *                                   kvImageDoNotTile            Turns off internal multithreading. You may
     *                                                               wish to do this if you have your own
     *                                                               multithreading scheme to avoid having the
     *                                                               two interfere with one another.
     *
     *                                   kvImageGetTempBufferSize    If this is passed, then the size of a temp
     *                                                               buffer is returned from the left hand side
     *                                                               of the function and no other work is done.
     *                                                               An error may still be returned in this case.
     *                                                               All vImage errors are < 0.  0 may also be
     *                                                               returned, indicating that the temp buffer
     *                                                               size is 0 for this set of parameters on
     *                                                               this device with this operating system at
     *                                                               this time of day.
     *                          @/textblock</pre>
     * @return The following values may be returned:
     * <pre>@textblock
     *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
     *   kvImageNoError                  Success!
     *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0
     *   kvImageNullPointerArgument      src or histogram pointer is NULL.
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
     *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageEqualization_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int histogram_entries, float minVal, float maxVal, int flags);

    /**
     * [@function] vImageEqualization_ARGB8888
     * <p>
     * Equalizes the histogram of an ARGB8888 source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      Calculates histograms for each channel of the ARGB8888 source image;
     *      Calculate normalized sum of each histogram;
     *      For each pixel do the following:
     *          val = src[x];
     *          For each channel:
     *              val[ch] = equalized_histogram[ch][val[ch]];
     *              dest[x] = val;
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     * <p>
     * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
     * work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
     *
     * @param src   A pointer to a vImage_Buffer that references the source pixels
     * @param dest  A pointer to a vImage buffer that references the destination pixels
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                       kvImageDoNotTile            Turns off internal multithreading. You may
     *                                                   wish to do this if you have your own
     *                                                   multithreading scheme to avoid having the
     *                                                   two interfere with one another.
     *
     *                       kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
     *              @/textblock</pre>
     * @return The following error codes may be returned
     * <pre>@textblock
     *   kvImageNoError                  Success!
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
     *   kvImageNullPointerArgument      src or dest pointer is NULL.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageEqualization_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageEqualization_ARGBFFFF
     * <p>
     * Equalizes the histogram of an ARGBFFFF source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      Compute the histogram of the input image:
     *          For each pixel, do the following:
     *              val = src[x];
     *              For each channel do:
     *                  i = histogram_entries * (val[ch] - minVal) / (maxVal - minVal);
     *                  i = clip i between 0 and histogram_entries-1
     *                  histogram[ch][i]++;
     *
     *      Calculate normalized sum of each histogram;
     *
     *      For each pixel, do the following:
     *          val = src[x];
     *          For each channel do:
     *              i = histogram_entries * (val[ch] - minVal) / (maxVal - minVal);
     *              i = clip i between 0 and histogram_entries-1
     *              val[ch] = equalized_histogram[ch][i];
     *          dest[x] = val;
     * @/textblock</pre>
     *
     * @param src               A pointer to a vImage_Buffer that references the source pixels
     * @param dest              A pointer to a vImage buffer that references the destination pixels
     * @param tempBuffer        A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
     *                          then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
     *                          in which case you are responsible for deallocating it when you is no longer need it.
     *                          If you want to allocate the buffer yourself, see the documentation for information
     *                          on how to determine the minimum size that you must allocate.
     * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
     * @param minVal            A minimum pixel value. Any pixel value less than this will be clipped to this value
     *                          (for the purposes of histogram calculation), and assigned to the first histogram entry.
     *                          This minimum value is applied to each of the four channels separately.
     * @param maxVal            A maximum pixel value. Any pixel value greater than this will be clipped to this value
     *                          (for the purposes of histogram calculation), and assigned to the last histogram entry.
     *                          This maximum value is applied to each of the four channels separately.
     * @param flags             The following flags are allowed:
     *                          <pre>@textblock
     *                                   kvImageDoNotTile            Turns off internal multithreading. You may
     *                                                               wish to do this if you have your own
     *                                                               multithreading scheme to avoid having the
     *                                                               two interfere with one another.
     *
     *                                   kvImageGetTempBufferSize    If this is passed, then the size of a temp
     *                                                               buffer is returned from the left hand side
     *                                                               of the function and no other work is done.
     *                                                               An error may still be returned in this case.
     *                                                               All vImage errors are < 0.  0 may also be
     *                                                               returned, indicating that the temp buffer
     *                                                               size is 0 for this set of parameters on
     *                                                               this device with this operating system at
     *                                                               this time of day.
     *
     *                                   kvImageLeaveAlphaUnchanged    Copy the alpha channel to the destination image unchanged
     *                          @/textblock</pre>
     * @return The following error codes may be returned
     * <pre>@textblock
     *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
     *   kvImageNoError                  Success!
     *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0
     *   kvImageNullPointerArgument      src or dest pointer is NULL.
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
     *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     * <p>
     * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
     * work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageEqualization_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int histogram_entries, float minVal, float maxVal, int flags);

    /**
     * [@function] vImageHistogramSpecification_Planar8
     * <p>
     * Performs a histogram specification operation on a Planar8 source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      Compute the histogram of the input image;
     *      Calculate normalized sum of the input histogram and the desired_histogram
     *      Generate the inverse transform
     *      Transform final image using inv_hist as a LUT. For each pixel, do the following:
     *          dest[x] = inv_histogram[src[x]];
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     *
     * @param src               A pointer to a vImage_Buffer that references the source pixels
     * @param dest              A pointer to a vImage buffer that references the destination pixels
     * @param desired_histogram A pointer to the desired histogram for the transformed image.
     *                          The histogram should be an array with 256 elements.
     * @param flags             The following flags are allowed:
     *                          <pre>@textblock
     *                                   kvImageDoNotTile         Turns off internal multithreading. You may
     *                                                            wish to do this if you have your own
     *                                                            multithreading scheme to avoid having the
     *                                                            two interfere with one another.
     *                          @/textblock</pre>
     * @return The following error codes may occur:
     * <pre>@textblock
     *   kvImageNoError                  Success!
     *   kvImageBufferSizeMismatch       sizes of the src and dest images do not match
     *   kvImageNullPointerArgument      src, dest or desired_histogram pointer is NULL.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageHistogramSpecification_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            ConstNUIntPtr desired_histogram, int flags);

    /**
     * [@function] vImageHistogramSpecification_PlanarF
     * <p>
     * Performs a histogram specification operation on a PlanarF source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      Compute the histogram of the input image:
     *          For each pixel, do the following:
     *              val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
     *              i = clip val between 0 and histogram_entries-1
     *              histogram[i]++;
     *      Calculate normalized sum of the input histogram and the desired_histogram
     *      Generate the inverse transform
     *      Transform final image using inverse transform as a LUT. For each pixel, do the following:
     *          val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
     *          i = clip val between 0 and histogram_entries-1
     *          dest[x] = inv_histogram[i];
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     *
     * @param src               A pointer to a vImage_Buffer that references the source pixels
     * @param dest              A pointer to a vImage buffer that references the destination pixels
     * @param tempBuffer        A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
     *                          then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
     *                          in which case you are responsible for deallocating it when you is no longer need it.
     *                          If you want to allocate the buffer yourself, see the documentation for information
     *                          on how to determine the minimum size that you must allocate.
     * @param desired_histogram A pointer the desired histogram for the transformed image.
     *                          The histogram should be an array with histogram_entries elements.
     * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
     * @param minVal            A minimum pixel value. Any pixel value less than this will be
     *                          clipped to this value (for the purposes of histogram calculation),
     *                          and assigned to the first histogram entry.
     * @param maxVal            A maximum pixel value. Any pixel value greater than this will
     *                          be clipped to this value (for the purposes of histogram calculation),
     *                          and assigned to the last histogram entry.
     * @param flags             The following flags are allowed:
     *                          <pre>@textblock
     *                                   kvImageDoNotTile            Turns off internal multithreading. You may
     *                                                               wish to do this if you have your own
     *                                                               multithreading scheme to avoid having the
     *                                                               two interfere with one another.
     *
     *                                   kvImageGetTempBufferSize    If this is passed, then the size of a temp
     *                                                               buffer is returned from the left hand side
     *                                                               of the function and no other work is done.
     *                                                               An error may still be returned in this case.
     *                                                               All vImage errors are < 0.  0 may also be
     *                                                               returned, indicating that the temp buffer
     *                                                               size is 0 for this set of parameters on
     *                                                               this device with this operating system at
     *                                                               this time of day.
     *                          @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
     *   kvImageNoError                  Success!
     *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0
     *   kvImageNullPointerArgument      src, dest or desired_histogram pointer is NULL.
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
     *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageHistogramSpecification_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            ConstNUIntPtr desired_histogram, int histogram_entries, float minVal, float maxVal, int flags);

    /**
     * [@function] vImageContrastStretch_Planar8
     * <p>
     * Stretches the contrast of a Planar8 source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      Compute the histogram of the input image;
     *      Generate LookUp table based on the histogram
     *      Transform final image using the LUT. For each pixel, do the following:
     *          dest[x] = LUT[src[x]];
     *   @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     * <p>
     * vImageEndsInContrastStretch_Planar8 or vImageTableLookUp_Planar8 may be used instead when more control
     * over the stretch is desired.
     *
     * @param src   A pointer to a vImage_Buffer that references the source pixels
     * @param dest  A pointer to a vImage buffer that references the destination pixels
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                       kvImageDoNotTile         Turns off internal multithreading. You may
     *                                                wish to do this if you have your own
     *                                                multithreading scheme to avoid having the
     *                                                two interfere with one another.
     *                @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *   kvImageNoError                  Success!
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
     *   kvImageNullPointerArgument      src or dest pointer is NULL.
     *   @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageContrastStretch_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageContrastStretch_PlanarF
     * <p>
     * Stretches the contrast of a PlanarF source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      Find minimum and maximum value of the input image: loVal, hiVal;
     *      scale_factor = ( maxVal - minVal ) / (float) ( hiVal - loVal );
     *      Transfer the image. For each pixel do:
     *          dest[x] = (src[x] - loVal) * scale_factor + minVal;
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     * <p>
     * vImageEndsInContrastStretch_PlanarF or vImageInterpolatedLookupTable_PlanarF may be used instead when more control
     * over the stretch is desired.
     *
     * @param src               A pointer to a vImage_Buffer that references the source pixels
     * @param dest              A pointer to a vImage buffer that references the destination pixels
     * @param tempBuffer        A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
     *                          then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
     *                          in which case you are responsible for deallocating it when you is no longer need it.
     *                          If you want to allocate the buffer yourself, see the documentation for information
     *                          on how to determine the minimum size that you must allocate.
     * @param histogram_entries The number of histogram entries, or bins to be used in histograms for this operation
     * @param minVal            A minimum pixel value. Any pixel value less than this will be
     *                          clipped to this value (for the purposes of histogram calculation),
     *                          and assigned to the first histogram entry.
     * @param maxVal            A maximum pixel value. Any pixel value greater than this will
     *                          be clipped to this value (for the purposes of histogram calculation),
     *                          and assigned to the last histogram entry.
     * @param flags             The following flags are allowed:
     *                          <pre>@textblock
     *                                   kvImageDoNotTile            Turns off internal multithreading. You may
     *                                                               wish to do this if you have your own
     *                                                               multithreading scheme to avoid having the
     *                                                               two interfere with one another.
     *
     *                                   kvImageGetTempBufferSize    If this is passed, then the size of a temp
     *                                                               buffer is returned from the left hand side
     *                                                               of the function and no other work is done.
     *                                                               An error may still be returned in this case.
     *                                                               All vImage errors are < 0.  0 may also be
     *                                                               returned, indicating that the temp buffer
     *                                                               size is 0 for this set of parameters on
     *                                                               this device with this operating system at
     *                                                               this time of day.
     *                          @/textblock</pre>
     * @return The following error codes may be returned
     * <pre>@textblock
     *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
     *   kvImageNoError                  Success!
     *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0
     *   kvImageNullPointerArgument      src or dest pointer is NULL.
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
     *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageContrastStretch_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int histogram_entries, float minVal, float maxVal, int flags);

    /**
     * [@function] vImageContrastStretch_ARGB8888
     * <p>
     * Stretches the contrast of an ARGB8888 source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      For each channel:
     *          Compute the histogram of the input image;
     *          Generate LookUp table based on the histogram
     *          Transform final image using the LUT. For each pixel, do the following:
     *              dest[x] = LUT[src[x]];
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     * <p>
     * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
     * work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
     * <p>
     * vImageEndsInContrastStretch_ARGB8888 or vImageTableLookUp_ARGB8888 may be used instead when more control
     * over the stretch is desired.
     *
     * @param src   A pointer to a vImage_Buffer that references the source pixels
     * @param dest  A pointer to a vImage buffer that references the destination pixels
     * @param flags The following flags are allowed:
     *              <pre>@textblock
     *                       kvImageDoNotTile            Turns off internal multithreading. You may
     *                                                   wish to do this if you have your own
     *                                                   multithreading scheme to avoid having the
     *                                                   two interfere with one another.
     *
     *                       kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
     *              @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *   kvImageNoError                  Success!
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
     *   kvImageNullPointerArgument      src or dest pointer is NULL.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageContrastStretch_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int flags);

    /**
     * [@function] vImageContrastStretch_ARGBFFFF
     * <p>
     * Stretches the contrast of  an ARGBFFFF source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *        For each channel:
     *            Find minimum and maximum value of the input image: loVal, hiVal;
     *            scale_factor = ( maxVal - minVal ) / (float) ( hiVal - loVal );
     *            Transfer the image. For each pixel do:
     *                dest[x] = (src[x] - loVal) * scale_factor + minVal;
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     * <p>
     * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
     * work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
     *
     * @param src               A pointer to a vImage_Buffer that references the source pixels
     * @param dest              A pointer to a vImage buffer that references the destination pixels
     * @param tempBuffer        A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
     *                          then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
     *                          in which case you are responsible for deallocating it when you is no longer need it.
     *                          If you want to allocate the buffer yourself, see the documentation for information
     *                          on how to determine the minimum size that you must allocate.
     * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
     * @param minVal            A minimum pixel value. Any pixel value less than this will be clipped to this value
     *                          (for the purposes of histogram calculation), and assigned to the first histogram entry.
     *                          This minimum value is applied to each of the four channels separately.
     * @param maxVal            A maximum pixel value. Any pixel value greater than this will be clipped to this value
     *                          (for the purposes of histogram calculation), and assigned to the last histogram entry.
     *                          This maximum value is applied to each of the four channels separately.
     * @param flags             The following flags are allowed:
     *                          <pre>@textblock
     *                                   kvImageDoNotTile            Turns off internal multithreading. You may
     *                                                               wish to do this if you have your own
     *                                                               multithreading scheme to avoid having the
     *                                                               two interfere with one another.
     *
     *                                   kvImageGetTempBufferSize    If this is passed, then the size of a temp
     *                                                               buffer is returned from the left hand side
     *                                                               of the function and no other work is done.
     *                                                               An error may still be returned in this case.
     *                                                               All vImage errors are < 0.  0 may also be
     *                                                               returned, indicating that the temp buffer
     *                                                               size is 0 for this set of parameters on
     *                                                               this device with this operating system at
     *                                                               this time of day.
     *
     *                                   kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
     *                          @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
     *   kvImageNoError                  Success!
     *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0
     *   kvImageNullPointerArgument      src or dest pointer is NULL.
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
     * @/textblock<pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageContrastStretch_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int histogram_entries, float minVal, float maxVal, int flags);

    /**
     * [@function] vImageEndsInContrastStretch_Planar8
     * <p>
     * Performs an ends-in contrast stretch operation on a Planar8 source image.
     * <p>
     * This function performs the following operation:
     * <pre>@textblock
     *      Compute the histogram of the input image;
     *      Generate LookUp table based on the histogram and percentage parameters
     *      Transform final image using the LookUp table. For each pixel, do the following:
     *          dest[x] = LUT[src[x]];
     * @/textblock</pre>
     * <p>
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     * if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     * kvImageDoNotTile
     *
     * @param src          A pointer to a vImage_Buffer that references the source pixels
     * @param dest         A pointer to a vImage buffer that references the destination pixels
     * @param percent_low  A percentage value.
     *                     The number of pixels that map to the lowest end of the histogram of the
     *                     transformed image should represent this percentage of the total pixels.
     * @param percent_high A percentage value.
     *                     The number of pixels that map to the highest end of the histogram of the
     *                     transformed image should represent this percentage of the total pixels.
     * @param flags        The following flags are allowed:
     *                     <pre>@textblock
     *                              kvImageDoNotTile         Turns off internal multithreading. You may
     *                                                       wish to do this if you have your own
     *                                                       multithreading scheme to avoid having the
     *                                                       two interfere with one another.
     *                     @/textblock</pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *   kvImageNoError                  Success!
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
     *   kvImageNullPointerArgument      src or dest pointer is NULL.
     *   kvImageInvalidParameter         percent_low + percent_high is greater than 100.
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageEndsInContrastStretch_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, int percent_low,
            int percent_high, int flags);

    /**
     * [@function] vImageEndsInContrastStretch_PlanarF
     * <p>
     * Performs an ends-in contrast stretch operation on a PlanarF source image.
     *
     * <pre>@textblock
     *      Compute the histogram of the input image;
     *      Generate LookUp table based on the histogram and percentage parameters
     *      Transform final image using the LookUp table. For each pixel, do the following:
     *          val = histogram_entries * (src[x] - minVal) / ( maxVal - minVal );
     *          i = clip val between 0 and histogram_entries-1
     *          dest[x] = LUT[i];
     *
     * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
     *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
     *    kvImageDoNotTile
     *
     * @param src           A pointer to a vImage_Buffer that references the source pixels
     *
     * @param dest          A pointer to a vImage buffer that references the destination pixels
     *
     * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
     *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
     *                      in which case you are responsible for deallocating it when you is no longer need it.
     *                      If you want to allocate the buffer yourself, see the documentation for information
     *                      on how to determine the minimum size that you must allocate.
     *
     * @param percent_low   A percentage value.
     *                      The number of pixels that map to the lowest end of the histogram of the
     *                      transformed image should represent this percentage of the total pixels.
     *
     * @param percent_high  A percentage value.
     *                      The number of pixels that map to the highest end of the histogram of the
     *                      transformed image should represent this percentage of the total pixels.
     *
     * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
     *
     * @param minVal        A minimum pixel value, the low end of the histogram.
     *                      Any pixel value less than this will be clipped to this value
     *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
     *
     * @param maxVal        A maximum pixel value, the high end of the histogram.
     *                      Any pixel value greater than this will be clipped to this value
     *                      (for the purposes of histogram calculation), and assigned to the last histogram entry.
     *
     * @param    flags      The following flags are allowed:
     * <pre>@textblock
     *          kvImageDoNotTile            Turns off internal multithreading. You may
     *                                      wish to do this if you have your own
     *                                      multithreading scheme to avoid having the
     *                                      two interfere with one another.
     *
     *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
     *                                      buffer is returned from the left hand side
     *                                      of the function and no other work is done.
     *                                      An error may still be returned in this case.
     *                                      All vImage errors are < 0.  0 may also be
     *                                      returned, indicating that the temp buffer
     *                                      size is 0 for this set of parameters on
     *                                      this device with this operating system at
     *                                      this time of day.
     * @/textblock</pre>
     *
     * @return The following error codes may be returned:
     * <pre>@textblock
     *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
     *   kvImageNoError                  Success!
     *   kvImageInvalidParameter         maxVal is less than minVal, histogram_entries is 0 or
     *                                   percent_low + percent_high is greater than 100.
     *   kvImageNullPointerArgument      src or dest pointer is NULL.
     *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
     *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
     * @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageEndsInContrastStretch_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            int percent_low, int percent_high, int histogram_entries, float minVal, float maxVal, int flags);

    /**
     * [@function] vImageDilate_Planar8
     * <p>
     * Apply a dilate filter to a Planar8 image
     * <p>
     * This is a general purpose dilate filter for Planar8 data. It is optimized to handle the special cases that occur
     * in image masks -- large contiguous regions of all 0xff or 0x0. If your filter is all 0's, you should use vImageMax_Planar8
     * instead.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     int r = 0;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
     *                         }
     *                     }
     *
     *                     // normalize for kernel center not 0
     *                     r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *
     *                     // saturate overflow to representable range
     *                     result[i][j] = CLIP( r );
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the dilate filter.
     *                         It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the dilate filter.
     *                         It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel           A pointer to a array of filter values of dimension kernel_height x kernel_width.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                 0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageDilate_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y,
            @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String kernel,
            @NUInt long kernel_height, @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageDilate_PlanarF
     * <p>
     * Apply a dilate filter to a PlanarF image
     * <p>
     * This is a general purpose dilate filter for Planar8 data. If your filter is all 0's, you should use vImageMax_PlanarF
     * instead.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     float r = -INFINITY;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
     *                         }
     *                     }
     *
     *                     // normalize for kernel center not 0
     *                     r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *
     *                     // saturate overflow to representable range
     *                     result[i][j] = r;
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place. Floating-point values have host endianness.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the dilate filter.
     *                         It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the dilate filter.
     *                         It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel           A pointer to a array of filter values of dimension kernel_height x kernel_width.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                 0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageDilate_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernel, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageDilate_ARGB8888
     * <p>
     * Apply a dilate filter to a ARGB8888 image
     * <p>
     * This is a general purpose dilate filter for ARGB8888 data. If your filter is all 0's, you should use vImageMax_ARGB8888
     * instead.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     int a = 0;
     *                     int r = 0;
     *                     int g = 0;
     *                     int b = 0;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
     *                             r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
     *                             g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
     *                             b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
     *                         }
     *                     }
     *
     *                     // normalize for kernel center not 0
     *                     a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *
     *                     // saturate overflow to representable range
     *                     result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : CLIP( a );
     *                     result[i][j][1] = CLIP( r );
     *                     result[i][j][2] = CLIP( g );
     *                     result[i][j][3] = CLIP( b );
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place. If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
     * If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the dilate filter.
     *                         It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the dilate filter.
     *                         It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel           A pointer to a array of filter values of dimension kernel_height x kernel_width.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *
     *                                    kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
     *                                                                 without modification, instead of having a dilate filter applied to it.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                 0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageDilate_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y,
            @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String kernel,
            @NUInt long kernel_height, @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageDilate_ARGBFFFF
     * <p>
     * Apply a dilate filter to a ARGBFFFF image
     * <p>
     * This is a general purpose dilate filter for ARGBFFFF data. If your filter is all 0's, you should use vImageMax_ARGBFFFF
     * instead.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     float a = -INFINITY;
     *                     float r = -INFINITY;
     *                     float g = -INFINITY;
     *                     float b = -INFINITY;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
     *                             r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
     *                             g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
     *                             b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
     *                         }
     *                     }
     *
     *                     // normalize for kernel center not 0
     *                     a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *
     *                     // saturate overflow to representable range
     *                     result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
     *                     result[i][j][1] = r;
     *                     result[i][j][2] = g;
     *                     result[i][j][3] = b;
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place.  If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
     * If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. Floating-point values have host
     * endianness.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the dilate filter.
     *                         It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the dilate filter.
     *                         It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel           A pointer to a array of filter values of dimension kernel_height x kernel_width.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *
     *                                    kvImageLeaveAlphaUnchanged   The alpha channel (first float in pixel in memory) is copied to the destination
     *                                                                 without modification, instead of having a dilate filter applied to it.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                 0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageDilate_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernel, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageErode_Planar8
     * <p>
     * Apply a erode filter to a Planar8 image
     * <p>
     * This is a general purpose erode filter for Planar8 data. If your filter is all 0's, you should use vImageMin_Planar8
     * instead.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     int r = MAX_CHANNEL_VALUE;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
     *                         }
     *                     }
     *
     *                     // normalize for kernel center not 0
     *                     r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *
     *                     // saturate overflow to representable range
     *                     result[i][j] = CLIP( r );
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the erode filter.
     *                         It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the erode filter.
     *                         It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel           A pointer to a array of filter values of dimension kernel_height x kernel_width.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                 0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageErode_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y,
            @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String kernel,
            @NUInt long kernel_height, @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageErode_PlanarF
     * <p>
     * Apply a erode filter to a PlanarF image
     * <p>
     * This is a general purpose erode filter for Planar8 data. If your filter is all 0's, you should use vImageMin_PlanarF
     * instead.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     float r = INFINITY;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
     *                         }
     *                     }
     *
     *                     // normalize for kernel center not 0
     *                     r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *
     *                     // saturate overflow to representable range
     *                     result[i][j] = r;
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place. Floating-point values have host endianness.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the erode filter.
     *                         It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the erode filter.
     *                         It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel           A pointer to a array of filter values of dimension kernel_height x kernel_width.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                 0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageErode_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernel, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageErode_ARGB8888
     * <p>
     * Apply a erode filter to a ARGB8888 image
     * <p>
     * This is a general purpose erode filter for ARGB8888 data. If your filter is all 0's, you should use vImageMin_ARGB8888
     * instead.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     int a = 255;
     *                     int r = 255;
     *                     int g = 255;
     *                     int b = 255;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
     *                             r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
     *                             g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
     *                             b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
     *                         }
     *                     }
     *
     *                     // normalize for kernel center not 0
     *                     a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *
     *                     // saturate overflow to representable range
     *                     result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : CLIP( a );
     *                     result[i][j][1] = CLIP( r );
     *                     result[i][j][2] = CLIP( g );
     *                     result[i][j][3] = CLIP( b );
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place. If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
     * If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the erode filter.
     *                         It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the erode filter.
     *                         It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel           A pointer to a array of filter values of dimension kernel_height x kernel_width.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *
     *                                    kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
     *                                                                 without modification, instead of having a erode filter applied to it.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                 0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageErode_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y,
            @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String kernel,
            @NUInt long kernel_height, @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageErode_ARGBFFFF
     * <p>
     * Apply a erode filter to a ARGBFFFF image
     * <p>
     * This is a general purpose erode filter for ARGBFFFF data. If your filter is all 0's, you should use vImageMin_ARGBFFFF
     * instead.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     float a = INFINITY;
     *                     float r = INFINITY;
     *                     float g = INFINITY;
     *                     float b = INFINITY;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
     *                             r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
     *                             g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
     *                             b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
     *                         }
     *                     }
     *
     *                     // normalize for kernel center not 0
     *                     a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *                     b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
     *
     *                     // saturate overflow to representable range
     *                     result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
     *                     result[i][j][1] = r;
     *                     result[i][j][2] = g;
     *                     result[i][j][3] = b;
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place.  If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
     * If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. Floating-point values have host
     * endianness.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the erode filter.
     *                         It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the erode filter.
     *                         It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel           A pointer to a array of filter values of dimension kernel_height x kernel_width.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *
     *                                    kvImageLeaveAlphaUnchanged   The alpha channel (first float in pixel in memory) is copied to the destination
     *                                                                 without modification, instead of having a erode filter applied to it.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                 0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageErode_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernel, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function]   vImageMax_Planar8
     * <p>
     * Apply a max filter to a Planar8 image.
     * <p>
     * A max filter is a special case dilate filter, in which the filter elements are all 0. It is much faster than the normal dilate.
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     int r = 0;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
     *                         }
     *                     }
     *
     *                     // saturate overflow to representable range
     *                     result[i][j] = r;
     *                 }
     *              @/textblock </pre>
     * If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place, unless the kvImageDoNotTile flag is used.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param tempBuffer       May be NULL. An optional temp buffer in which to store temporary computation. To find the size
     *                         of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
     *                         flag. The size of the temp buffer will be returned from the left hand side of the function in
     *                         place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
     *                         improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
     *                         the newly allocated temp buffer.
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the max filter.
     *                         It allows the max filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the max filter.
     *                         It allows the max filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread. It also
     *                                                                 allows the function to work in place, though more slowly.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
     *                                             Instead, the size of the temp buffer needed is returned.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMax_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function]   vImageMax_PlanarF
     * <p>
     * Apply a max filter to a PlanarF image.
     * <p>
     * A max filter is a special case dilate filter, in which the filter elements are all 0. It is much faster than the normal dilate.
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     float r = -INFINITY;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
     *                         }
     *                     }
     *
     *                     // saturate overflow to representable range
     *                     result[i][j] = r;
     *                 }
     *              @/textblock </pre>
     * If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place, unless the kvImageDoNotTile flag is used.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param tempBuffer       May be NULL. An optional temp buffer in which to store temporary computation. To find the size
     *                         of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
     *                         flag. The size of the temp buffer will be returned from the left hand side of the function in
     *                         place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
     *                         improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
     *                         the newly allocated temp buffer.
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the max filter.
     *                         It allows the max filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the max filter.
     *                         It allows the max filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread. It also
     *                                                                 allows the function to work in place, though more slowly.
     *
     *                                    kvImageGetTempBufferSize     Return the size of the temp buffer needed.  Do no work.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
     *                                             Instead, the size of the temp buffer needed is returned.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMax_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageMax_ARGB8888
     * <p>
     * Apply a max filter to a ARGB8888 image
     * <p>
     * This is a special purpose dilate filter for ARGB8888 data, for rectangular kernels with value 0. It is much faster than the normal dilate.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     int a = 0;
     *                     int r = 0;
     *                     int g = 0;
     *                     int b = 0;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
     *                             r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
     *                             g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
     *                             b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
     *                         }
     *                     }
     *
     *                     // saturate overflow to representable range
     *                     result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
     *                     result[i][j][1] = r;
     *                     result[i][j][2] = g;
     *                     result[i][j][3] = b;
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
     * If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
     * Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
     * run more slowly.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param tempBuffer       May be NULL. An optional temp buffer in which to store temporary computation. To find the size
     *                         of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
     *                         flag. The size of the temp buffer will be returned from the left hand side of the function in
     *                         place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
     *                         improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
     *                         the newly allocated temp buffer.
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the max filter.
     *                         It allows the max filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the max filter.
     *                         It allows the max filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *                                                                 kvImageDoNotTile will also allow the filter to run in place, though more slowly.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *
     *                                    kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
     *                                                                 without modification, instead of having a max filter applied to it.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
     *                                             Instead, the size of the temp buffer needed is returned.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMax_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageMax_ARGBFFFF
     * <p>
     * Apply a max filter to a ARGBFFFF image
     * <p>
     * This is a special purpose dilate filter for ARGBFFFF data, for rectangular kernels with value 0. It is much faster than the normal dilate.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     float a = -INFINITY;
     *                     float r = -INFINITY;
     *                     float g = -INFINITY;
     *                     float b = -INFINITY;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
     *                             r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
     *                             g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
     *                             b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
     *                         }
     *                     }
     *
     *                     // saturate overflow to representable range
     *                     result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
     *                     result[i][j][1] = r;
     *                     result[i][j][2] = g;
     *                     result[i][j][3] = b;
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
     * If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
     * Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
     * run more slowly.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param tempBuffer       May be NULL. An optional temp buffer in which to store temporary computation. To find the size
     *                         of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
     *                         flag. The size of the temp buffer will be returned from the left hand side of the function in
     *                         place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
     *                         improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
     *                         the newly allocated temp buffer.
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the max filter.
     *                         It allows the max filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the max filter.
     *                         It allows the max filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *                                                                 kvImageDoNotTile will also allow the filter to run in place, though more slowly.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *
     *                                    kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
     *                                                                 without modification, instead of having a max filter applied to it.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
     *                                             Instead, the size of the temp buffer needed is returned.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMax_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function]   vImageMin_Planar8
     * <p>
     * Apply a min filter to a Planar8 image.
     * <p>
     * A min filter is a special case erode filter, in which the filter elements are all 0.  It is much faster than the normal erode.
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     int r = MAX_CHANNEL_VALUE;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
     *                         }
     *                     }
     *
     *                     // saturate overflow to representable range
     *                     result[i][j] = r;
     *                 }
     *              @/textblock </pre>
     * If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place, unless the kvImageDoNotTile flag is used.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param tempBuffer       May be NULL. An optional temp buffer in which to store temporary computation. To find the size
     *                         of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
     *                         flag. The size of the temp buffer will be returned from the left hand side of the function in
     *                         place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
     *                         improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
     *                         the newly allocated temp buffer.
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the min filter.
     *                         It allows the min filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the min filter.
     *                         It allows the min filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread. It also
     *                                                                 allows the function to work in place, though more slowly.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
     *                                             Instead, the size of the temp buffer needed is returned.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMin_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function]   vImageMin_PlanarF
     * <p>
     * Apply a min filter to a PlanarF image.
     * <p>
     * A min filter is a special case erode filter, in which the filter elements are all 0. It is much faster than the normal erode.
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     float r = INFINITY;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
     *                         }
     *                     }
     *
     *                     // saturate overflow to representable range
     *                     result[i][j] = r;
     *                 }
     *              @/textblock </pre>
     * If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * Does not work in place, unless the kvImageDoNotTile flag is used.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param tempBuffer       May be NULL. An optional temp buffer in which to store temporary computation. To find the size
     *                         of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
     *                         flag. The size of the temp buffer will be returned from the left hand side of the function in
     *                         place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
     *                         improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
     *                         the newly allocated temp buffer.
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the min filter.
     *                         It allows the min filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the min filter.
     *                         It allows the min filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread. It also
     *                                                                 allows the function to work in place, though more slowly.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
     *                                             Instead, the size of the temp buffer needed is returned.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMin_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageMin_ARGB8888
     * <p>
     * Apply a min filter to a ARGB8888 image
     * <p>
     * This is a special purpose erode filter for ARGB8888 data, for rectangular kernels with value 0. It is much faster than the normal erode.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     int a = MAX_CHANNEL_VALUE;
     *                     int r = MAX_CHANNEL_VALUE;
     *                     int g = MAX_CHANNEL_VALUE;
     *                     int b = MAX_CHANNEL_VALUE;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
     *                             r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
     *                             g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
     *                             b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
     *                         }
     *                     }
     *
     *                     // saturate overflow to representable range
     *                     result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
     *                     result[i][j][1] = r;
     *                     result[i][j][2] = g;
     *                     result[i][j][3] = b;
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
     * If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
     * Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
     * run more slowly.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param tempBuffer       May be NULL. An optional temp buffer in which to store temporary computation. To find the size
     *                         of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
     *                         flag. The size of the temp buffer will be returned from the left hand side of the function in
     *                         place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
     *                         improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
     *                         the newly allocated temp buffer.
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the min filter.
     *                         It allows the min filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the min filter.
     *                         It allows the min filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *                                                                 kvImageDoNotTile will also allow the filter to run in place, though more slowly.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *
     *                                    kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
     *                                                                 without modification, instead of having a min filter applied to it.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
     *                                             Instead, the size of the temp buffer needed is returned.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMin_ARGB8888(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    /**
     * [@function] vImageMin_ARGBFFFF
     * <p>
     * Apply a min filter to a ARGBFFFF image
     * <p>
     * This is a special purpose erode filter for ARGBFFFF data, for rectangular kernels with value 0. It is much faster than the normal erode.
     *
     * <pre> @textblock
     *                 for each pixel result[i][j] in the image{
     *                     float a = INFINITY;
     *                     float r = INFINITY;
     *                     float g = INFINITY;
     *                     float b = INFINITY;
     *                     for( y = 0; y < kernel_height; y++ ){
     *                         for( x = 0; x < kernel_width; x++ ){
     *                             a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
     *                             r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
     *                             g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
     *                             b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
     *                         }
     *                     }
     *
     *                     // saturate overflow to representable range
     *                     result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
     *                     result[i][j][1] = r;
     *                     result[i][j][2] = g;
     *                     result[i][j][3] = b;
     *                 }
     *              @/textblock </pre>
     * <p>
     * If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
     * of the result tile relative to the src image.
     * <p>
     * If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
     * If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
     * Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
     * run more slowly.
     *
     * @param src              The input image
     * @param dest             A preallocated buffer to contain the result image
     * @param tempBuffer       May be NULL. An optional temp buffer in which to store temporary computation. To find the size
     *                         of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
     *                         flag. The size of the temp buffer will be returned from the left hand side of the function in
     *                         place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
     *                         improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
     *                         the newly allocated temp buffer.
     * @param srcOffsetToROI_X An offset added to the horizontal position in the src image when calculating the min filter.
     *                         It allows the min filter to operate in a tiled fashion for tiles that do not start on the
     *                         left edge of the source image.
     * @param srcOffsetToROI_Y An offset added to the vertical position in the src image when calculating the min filter.
     *                         It allows the min filter to operate in a tiled fashion for tiles that do not start on the
     *                         top edge of the source image.
     * @param kernel_height    The height of the rectangular kernel. Must be an odd number.
     * @param kernel_width     The width of the rectangular kernel. Must be an odd number.
     * @param flags            The following flags values are allowed:
     *                         <pre> @textblock
     *                                    kvImageNoFlags               Default operation
     *
     *                                    kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
     *                                                                 multithreading and just want the filter to run local to the current thread.
     *                                                                 kvImageDoNotTile will also allow the filter to run in place, though more slowly.
     *
     *                                    kvImageGetTempBufferSize     Return 0.  Do no work.
     *
     *                                    kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
     *                                                                 without modification, instead of having a min filter applied to it.
     *                             @/textblock </pre>
     * @return The following error codes may result:
     * <pre> @textblock
     *            kvImageNoError                   Success.
     *                >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
     *                                             Instead, the size of the temp buffer needed is returned.
     *
     *            kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
     *                                             dimensions in the src image
     *
     *            kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMin_ARGBFFFF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, @NUInt long kernel_height,
            @NUInt long kernel_width, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImagePNGDecompressionFilter(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer buffer,
            @NUInt long startScanline, @NUInt long scanlineCount, int bitsPerPixel, int filterMethodNumber,
            int filterType, int flags);

    /**
     * vImageMatrixMultiply_Planar16S
     * <p>
     * Transform M source planes to N destination planes by multiplying the
     * M x N transformation matrix by the source planes.  A pre-bias may
     * optionally be added to the source planes before the transformation.  A
     * post-bias may optionally be added to the resulting destination planes. As
     * a final step the destination planes are divided by a given divisor.
     * <p>
     * if (pre_bias)
     * { bA, bR, bG, ... } = { A + pre_bias[0], R + pre_bias[1],
     * G + pre_bias[2], ... }
     * else
     * { bA, bR, bG, ... } = { A, R, G, ... }
     * <p>
     * <p>
     * { a00  a01  a02  ... }
     * { A', R', G', ...} = { bA, bR, bG, ... } * { a10  a11  a12  ... }
     * { a20  a21  a22  ... }
     * { ...  ...  ...  ... }
     * <p>
     * if (post_bias)
     * { A', R', G', ... } += { post_bias[0], post_bias[1], post_bias[2], ... }
     * else // correct value for normal rounding: divisor/2
     * { A', R', G', ... } += { divisor/2, divisor/2, divisor/2, ... }
     * <p>
     * { A', R', G', ... } /= divisor
     * <p>
     * where the values are:
     * { A', R', ... }    Resulting destination planes (dests).  For a concrete
     * example of the multiply step for one plane:
     * A' = bA * a00 + bR * a10 + bG * a20 + ... * ...
     * <p>
     * { A, R, ... }    Source planes (srcs).
     * <p>
     * { bA, bR, ... }    Pre-biased source planes. (for demonstration only, never
     * actually exists)
     * <p>
     * a00, a01, ...    Elements in the transformation matrix (matrix).
     * <p>
     * pre_bias         Pre-bias values corresponding to the source channels.
     * Value is zero when NULL.
     * <p>
     * post_bias         Post-bias values corresponding to the destination channels.
     * When NULL, the correct value for normal rounding if used,
     * which is divisor/2.
     * <p>
     * divisor            Divisor to normalize the destination planes.
     * <p>
     * Operands:
     * ---------
     * srcs                A pointer to an array of vImage_Buffer pointers that
     * reference the source planes. This array must contain
     * src_planes number of vImage_Buffer pointers.
     * <p>
     * dests            A pointer to an array of vImage_Buffer pointers that
     * reference where to write the destination planes. Only
     * the image data pointed to by each vImage_Buffer is modified
     * (i.e. dests[0]->data), everything else remains unchanged.
     * This array must contain dest_planes number of vImage_Buffer
     * pointers.
     * <p>
     * src_planes        The number of source planes.  Must be less than 256.
     * <p>
     * dest_planes        The number of destination planes.  Must be less than 256.
     * <p>
     * matrix            The row major transformation matrix with dest_planes number
     * of columns and src_planes number of rows.  Be aware that if
     * any column of this matrix sums to a value larger than
     * +-65538 this function may silently overflow.
     * <p>
     * divisor            Division by this value occurs as the last step, in effect
     * normalizing the output planes.
     * <p>
     * pre_bias            An optional array of length src_planes consisting of int16_t
     * values. Each value will be added to the corresponding
     * source plane in srcs.  Pass NULL for no pre_bias.
     * <p>
     * post_bias        An optional array of length dest_planes consisting of
     * int16_t values.  Each value will be added to the
     * corresponding destination planes in dests.  The post_bias
     * is added before any clipping, rounding or division.  Pass
     * NULL the correct value for for normal rounding (divisor/2).
     * <p>
     * flags            The following flags are allowed:
     * <p>
     * kvImageDoNotTile            Turns off internal multithreading. You may
     * wish to do this if you have your own
     * multithreading scheme to avoid having the
     * two interfere with one another.
     * <p>
     * Return Value:
     * -------------
     * kvImageInvalidKernelSize            Either src_planes or dest_planes is 0.
     * kvImageBufferSizeMismatch        All buffers in dests must have the same
     * width and height.
     * kvImageROILargerThanSourceBuffer The destination buffer size (width, or
     * height) is larger than the source buffer.
     * kvImageUnknownFlagsBit            Unexpected flag was passed.
     * kvImageNoError                    Success!
     * <p>
     * <p>
     * Comments:
     * ---------
     * Be aware that 32-bit signed accumulators are used in this operation with no
     * overflow protection. To avoid the possibility of overflow, limit the sum
     * of any column in the transformation matrix to values less than +-65536.
     * <p>
     * The 32-bit accumulated results out of 16-bit range (+-32767) will be subject
     * clipping before writing to the destination buffer.
     * <p>
     * This routine will work in place provided all of the following are true:
     * src.data == dest.data
     * src.rowBytes == dest.rowBytes
     * kvImageDoNotTile is passed
     * <p>
     * Some matrix based color transforms, such as that obtained using kColorSyncConversionMatrix are defined differently.
     * <p>
     * ColorSync:      p' = M1 * p                  M1 = colorsync matrix,  p = input pixel as column vector, p' = output pixel as column vector
     * vImage:      p'T = pT * M2                M2 = vImage matrix,T indicates transpose -- vImage pixels are row vectors
     * <p>
     * Given that (A*B)T = BT*AT, it can be shown that M2 = M1T. So, to use the alternative definition here, you need to transpose the matrix.
     * <p>
     * Example:
     * --------
     * To convert RGB to YUV, one might use the following formula:
     * <p>
     * Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
     * U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
     * V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
     * <p>
     * This translates to a matrix that looks like this:
     * <p>
     * 66     -38     112
     * 129     -74     -94
     * 25     112     -18
     * <p>
     * Pass 256 as the divisor to handle the >> 8 operation.  The post_bias
     * argument can handle the addition of { 16, 128, 128 }, however because
     * this function performs the division last, this array must be scaled by
     * the divisor, yielding a post_bias of:
     * post_bias = { 16*divisor + divisor/2, 128*divisor + divisor/2,
     * 128*divisor + divisor/2}
     * post bias = { 4224, 32896, 32896 }
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMatrixMultiply_Planar16S(Ptr<ConstPtr<vImage_Buffer>> srcs,
            Ptr<ConstPtr<vImage_Buffer>> dests, int src_planes, int dest_planes, ConstShortPtr matrix, int divisor,
            ConstShortPtr pre_bias, ConstIntPtr post_bias, int flags);

    /**
     * vImageMatrixMultiply_*
     * <p>
     * Multiply the M channels in the src buffers (A,R,G...) by a NxM matrix (a##) to yield N channels in the dest buffer(s)
     * For ARGB interleaved functions, both M and N must be 4. The pre_bias (ca, cr, cg...) is added to the M input channels
     * before the matrix is applied. The post_bias (ka, kr, kg...)  is added afterward.
     * <p>
     * { a00  a10  a20  ... }
     * { A', R', G' ...} = { A + ca, R + cr, G + cg, ... } *  { a01  a11  a21  ... } + { ka, kr, kg, ....}
     * { a02  a12  a22  ... }
     * { ...  ...  ...  ... }
     * <p>
     * A', R', G', ... = result channels stored into dests
     * A, R, G, ... = input channels from srcs
     * ca, cr, cg, ... = pre_bias elements corresponding to the input src channels, or zero if pre_bias is NULL
     * a00, a11, a12, ... = elmenets from the matrix[]
     * ka, kr, kg, ... = post_bias elements corresponding to the destination dest channels, or zero if post_bias is NULL
     * <p>
     * For integer code, there is an additional division operation that happens at the end, in effect normalizing integer matrices.
     * The post-bias is added before any clipping, rounding or division. If you pass NULL for the post-bias, the correct value for
     * normal rounding will be used:
     * <p>
     * integer:            divisor/2
     * floating point:     0.0f
     * <p>
     * Be aware that 32 bit signed accumulators are used for integer code. If the sum over any matrix column is larger
     * than +- 2**23, then overflow may occur. Generally speaking this will not happen because the matrix elements are
     * 16 bit integers, so one would need more than 256 source buffers before it is possible to encounter trouble.
     * <p>
     * As an example, to convert RGB to YUV, one might use the following formula:
     * <p>
     * Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
     * U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
     * V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
     * <p>
     * This translates to a matrix that looks like this:
     * <p>
     * 66     -38     112
     * 129     -74     -94
     * 25     112     -18
     * <p>
     * There is also the >>8 operation and the extra terms to be dealt with. For integer data, you would use a divisor of
     * 256 to account for the >>8 operation. The divisor is applied last after all other multiplications and additions.
     * (For floating point, there is no divisor. Just divide the whole matrix by the divisor if one is needed.) Use the
     * post bias to handle the +128 and {+16, +128, +128} terms. Since the second set happen after the divisor in the
     * formula above, but our post_bias is applied before the divide, you'll need to multiply those biases by the divisor.
     * This will give a post_bias of:
     * <p>
     * {  16 * 256 + 128, 128 * 256 + 128, 128 * 256 + 128 } = { 4224, 32896, 32896 }
     * <p>
     * Finally, if there is an alpha component, such that you wish to convert ARGB to AYUV, leaving the alpha component
     * unchanged then add another row and column:
     * <p>
     * matrix =    divisor      0       0       0
     * 0        66     -38     112
     * 0       129     -74     -94
     * 0        25     112     -18
     * <p>
     * post_bias =     { divisor/2, 4224, 32896, 32896 }
     * divisor =       256
     * <p>
     * Integer results out of range of 0...255 will be subject to saturated clipping before writing to the destination buffer.
     * <p>
     * <p>
     * Programming Note:
     * The pre-bias is provided as a convenience. The pre-bias can be converted to a post bias by
     * multiplying it by the matrix, which is what we do behind the scenes. Pass NULL for the pre-bias if
     * you don't want a prebias added in.
     * <p>
     * These functions work in place as long as overlapping buffers overlap exactly. Buffers that partially overlap
     * will yield undefined results. Destination buffers will be stored to in the order they appear in the dests array.
     * The buffers all need to be the same size. They can have different rowBytes.
     * <p>
     * In cases where the number of src and dest buffers match, these functions will work in place.
     * The source and destination buffers may all be different sizes and have different sized rowbytes. The source buffers must
     * be at least as large as the dest buffers. In cases where the source buffer is larger than a dest buffer, the portion of the
     * source buffer that overlaps the destination buffer when their top left corners are aligned will be used.
     * <p>
     * Some matrix based color transforms, such as that obtained using kColorSyncConversionMatrix are defined differently.
     * <p>
     * ColorSync:      p' = M1 * p                  M1 = colorsync matrix,  p = input pixel as column vector, p' = output pixel as column vector
     * vImage:      p'T = pT * M2                M2 = vImage matrix, T indicates transpose -- vImage pixels are row vectors
     * <p>
     * Given that (A*B)T = BT*AT, we find that M2 = M1T. So, to use the alternatively defined matrix here, you need to transpose the matrix
     * before passing it to vImage.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMatrixMultiply_Planar8(Ptr<ConstPtr<vImage_Buffer>> srcs,
            Ptr<ConstPtr<vImage_Buffer>> dests, int src_planes, int dest_planes, ConstShortPtr matrix, int divisor,
            ConstShortPtr pre_bias, ConstIntPtr post_bias, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageMatrixMultiply_PlanarF(Ptr<ConstPtr<vImage_Buffer>> srcs,
            Ptr<ConstPtr<vImage_Buffer>> dests, int src_planes, int dest_planes, ConstFloatPtr matrix,
            ConstFloatPtr pre_bias, ConstFloatPtr post_bias, int flags);

    @Generated
    @CFunction
    public static native VoidPtr vImageCreateGammaFunction(float gamma, int gamma_type, int flags);

    @Generated
    @CFunction
    public static native void vImageDestroyGammaFunction(VoidPtr f);

    /**
     * There is a 8 bit lookup table in Conversion.h, if you are looking for a 8bit to 8bit gamma function.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageGamma_Planar8toPlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr gamma,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageGamma_PlanarFtoPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr gamma,
            int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImageGamma_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr gamma,
            int flags);

    /**
     * *  vImagePiecewisePolynomial*
     * *
     * *  Apply one or more polynomials to the input image to give the output image.
     * *
     * *  vImagePiecewisePolynomial_Planar8toPlanarF uses 8 bit data on input and produces floating point data.
     * *  vImagePiecewisePolynomial_PlanarFtoPlanar8 uses floating point data on input and produces 8-bit data with saturated clamping at 0 and 255 to prevent modulo overflow.
     * *  vImagePiecewisePolynomial_PlanarF uses floating point data on both input and output.
     * *  vImageTableLookUp_Planar8 uses 8 bit data and produces 8 bit data. In certain cases, the matrix multiply function may also be appropriate.
     * *
     * *  No other arithmetic is done. If you wish a /255 or *255 operation to be done as part of the calculation, you must incorporate that into your polynomial.
     * *
     * *  The arrangement of the polynomials is defined as follows:
     * *      Let there be N polynomials that each cover part of the single precision floating point range that are arranged in order of area of influence from -Infinity to Infinity.
     * *      The ith polynomial shall operate on the set of input pixel values that fall in the range:
     * *
     * *          boundary[i] <= pixel_value < boundary[i+1].
     * *
     * *     for which:
     * *
     * *          boundary[0] = smallest value fit by the polynomial. Input pixels smaller than this will be clamped to this value before the calculation is done. Use -Inf for no lower limit.
     * *          boundary[N] = largest value fit by the polynomial. Input pixels larger than this will be clamped to this value before the calculation is done. Use +Inf for no upper limit.
     * *          boundary[1....N-1] = the boundaries separating the input ranges covered by the various polynomials provided (see below)
     * *
     * *     NaNs will return NaNs. The last polynomial also operates on Inf.  N must be an integer power of 2.
     * *     Values found in the destination array are undefined until after the function returns.
     * *       The behavior is undefined if boundaries are NaN.
     * *
     * *  These functions will also work for multichannel data, such as RGBAFFFF buffers by adjusting the width of the buffer to
     * *  reflect the additional channels. Note that this will cause the alpha channel, if there is one, to become modified like the other channels.
     * *  These will work in place, provided that the following are true:
     * *      src->data == dest->data
     * *      src->rowBytes >= dest->rowBytes
     * *      if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter
     * <p>
     * *
     * *  The input parameters are as follows:
     * *
     * *      src = a pointer to a vImage_Buffer containing the input data for the function
     * *      dest = a pointer to a vImage_Buffer structure that describes where to write the results
     * *
     * *      coefficients = a packed array of pointers to packed arrays of (order+1) polynomial coefficients ( i.e. coefficients[ N ][ order + 1 ] ).
     * *                      The polynomials must appear in order from least to greatest sorted by area of influence.
     * *                      The polynomials must all be of the same order.
     * *                      The polynomial coefficients are sorted from 0th order term to highest order term
     * *
     * *      boundaries = a packed array of (N+1) floating point values that mark the dividing line between one polynomial and the next. These must be sorted from most negative to most positive.
     * *                        Input pixel values less than boundaries[0] will be clamped to be equal to boundaries[0] before the calculation is done
     * *                        Input pixel values greater than boundaries[N] will be clamped to be equal to boundaries[N] before the calculation is done
     * *
     * *      order = the number of coefficients minus one used for each polynomial -- all the polynomials must be of the same order
     * *                  A polynomial with _two_ coefficients (y = c0 + c1 * x) is a _first_ order polynomial. Pass 1 for a first order polynomial. Pass 2 for a second order polynomial, etc.
     * *
     * *      log2segments = log2(N)
     * *
     * *      flags = no flags are currently honored. You must pass zero here.
     * *
     * *      vImagePiecewisePolynomial_PlanarF will work in place.
     * *      vImagePiecewisePolynomial_Planar8toPlanarF will work in place.
     * *      vImagePiecewisePolynomial_PlanarFtoPlanar8 will NOT work in place.
     * *
     * *  Performance advisory:
     * *      It costs much more to resolve additional polynomials than to work with higher order polynomials.
     * *      For performance, you are typically better off with one 9th order polynomial that spans the range you are
     * *      interested in than many first order polynomials that cover the area in a piecewise fashion.
     * *      Vector code execution time is roughly proportional to:
     * *
     * *              time = (base cost to touch all the data) + polynomial order + 4 * log2segments
     * *
     * *      The vector code for an unsplit 13th order polynomial should be about as fast as vImageLookupTable_Planar8toPlanarF()
     * *          on a G4.
     * *
     * *      With data not in cache, the time may be significantly different. For sufficiently small polynomials, the
     * *      cost may be a fixed cost, dependent only on how much data is touched, and not on polynomial order.
     * *
     * *        This performance behavior is provided to help developers evaluate speed tradeoffs. It is not a guarantee.
     * *        It is subject to change in future operating system revisions, and may be different on different hardware
     * *        within the same or different operating system revisions.
     * *
     * *      Vector code is not invoked for log2segments > 3.
     * *
     * *  Accuracy advisory:
     * *      Single precision floating point arithmetic is used. While some polynomials may fit a desired curve
     * *      within prescribed error limits when using infinite precision math, limited floating point precision
     * *      may in practice cause significant error to accumulate for some sets of polynomial coefficients. It is
     * *      recommended that you test all reasonable floating point pixel values to make sure that they do indeed
     * *      give results that conform to prescribed error limits.
     * *
     * *
     * *  Usage Example:
     * *  --------------
     * *      Lets say you want to mimic the sRGB gamma curve using vImagePiecewisePolynomial_PlanarF. The sRGB gamma curve is defined as follows:
     * *
     * *              if( {R,G,B} < 0.00304 )
     * *                  result = 12.92 * {R,G,B}
     * *              else
     * *                  result = -0.055 + 1.055 * Pow( {R,G,B}, 2.4 )
     * *
     * *      Because the power function isn't a polynomial and we need a polynomial, we will approximate it with a second order polynomial:
     * *
     * *              if( {R,G,B} < 0.00304 )
     * *                  result = 12.92 * {R,G,B}
     * *              else
     * *                  result = c0 + c1 * {R,G,B} + c2 * {R,G,B}^2
     * *
     * *      (Finding the best values for c0, c1, c2 to approximate -0.055 + 1.055 * Pow( {R,G,B}, 2.4 ) over the range [0.00304, 1.0] is
     * *          left as an exercise for the reader.)
     * *
     * *      We have two polynomials -- one for the region below 0.00304 and one for the region above, so N = 2.
     * *      The highest order polynomial is a second order polynomial, so order = 2.
     * *
     * *              const int N = 2;        // two polynomials
     * *              const int order = 2;    // the polynomials are second order (have three terms, including zero terms)
     * *
     * *      The two polynomials are:
     * *
     * *              float linearPart[ order + 1 ] = { 0, 12.92, 0 };    // result = 0 + 12.92 * {R,G,B} + 0 * {R,G,B} * {R,G,B}
     * *              float nonLinearPart[ order + 1 ] = { c0, c1, c2 };  // result = c0 + c1 * {R,G,B} + c2 * {R,G,B} * {R,G,B}
     * *
     * *      Here we assemble the rest of the information:
     * *
     * *              float *coefficients[ N ] = { linearPart, nonLinearPart };   // sorted in order of area of influence from least to greatest. ( x < 0.00304, x >= 0.00304 )
     * *              float boundaries[ N+1 ] = { 0.0f, 0.00304, 1.0f };      // sorted in order from least to greatest. 0.0f and 1.0f define the range over which the polynomials are valid. 0.00304 is the single value separating the two polynomials
     * *              int log2segments = 1;   // log2(N)
     * *              int flags = 0;          // no flags
     * *
     * *              VIMAGE_PF vImage_Error error = vImagePiecewisePolynomial_PlanarF( &mySourceBuffer, &myDestinationBuffer, coefficients, boundaries, order, log2segments, flags );
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePiecewisePolynomial_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            Ptr<ConstFloatPtr> coefficients, ConstFloatPtr boundaries, int order, int log2segments, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImagePiecewisePolynomial_Planar8toPlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            Ptr<ConstFloatPtr> coefficients, ConstFloatPtr boundaries, int order, int log2segments, int flags);

    @Generated
    @CFunction
    @NInt
    public static native long vImagePiecewisePolynomial_PlanarFtoPlanar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            Ptr<ConstFloatPtr> coefficients, ConstFloatPtr boundaries, int order, int log2segments, int flags);

    /**
     * *  vImageSymmetricPiecewisePolynomial*
     * *
     * *  Apply one or more polynomials to the input image to give the output image.  The polynomial p(x) is provided as a
     * *  series of coefficients.  e.g.:
     * *
     * *      p(x,i) = coefficient[i][0] + (coefficient[i][1] + (coefficient[i][2] + coefficient[i][3]*x)*x)*x;    (assuming a 3rd order polynomial)
     * *
     * *  This is just like vImagePiecewisePolynomial_<fmt>.  However, when it is applied, a modified polynomial p'(x) is actually used:
     * *
     * *      p'(x) = p(fabsf(x)) * copysignf( 1.0f, x)
     * *
     * *  This makes the polynomial C2 symmetric about the origin.  That is, the negative domain looks like the positive domain, rotated 180 degrees about the origin.
     * *
     * *  vImageSymmetricPiecewisePolynomial_PlanarF floating point data on both input and output.
     * *
     * *  The arrangement of the polynomials is defined as follows:
     * *      Let there be N polynomials that each cover part of the single precision floating point range that are arranged in order of area of influence from -Infinity to Infinity.
     * *      The ith polynomial shall operate on the set of input pixel values that fall in the range:
     * *
     * *          boundary[i] <= pixel_value < boundary[i+1].
     * *
     * *     for which:
     * *
     * *          boundary[0] = smallest value fit by the polynomial. Input pixels smaller than this will be clamped to this value before the calculation is done. Use -Inf for no lower limit.
     * *          boundary[N] = largest value fit by the polynomial. Input pixels larger than this will be clamped to this value before the calculation is done. Use +Inf for no upper limit.
     * *          boundary[1....N-1] = the boundaries separating the input ranges covered by the various polynomials provided (see below)
     * *
     * *     NaNs will return NaNs. The last polynomial also operates on Inf.  N must be an integer power of 2.
     * *     Values found in the destination array are undefined until after the function returns.
     * *       The behavior is undefined if boundaries are NaN.
     * *
     * *  These functions will also work for multichannel data, such as RGBAFFFF buffers by adjusting the width of the buffer to
     * *  reflect the additional channels. Note that this will cause the alpha channel, if there is one, to become modified like the other channels.
     * *  These will work in place, provided that the following are true:
     * *      src->data == dest->data
     * *      src->rowBytes >= dest->rowBytes
     * *      if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter
     * <p>
     * *
     * *  The input parameters are as follows:
     * *
     * *      src = a pointer to a vImage_Buffer containing the input data for the function
     * *      dest = a pointer to a vImage_Buffer structure that describes where to write the results
     * *
     * *      coefficients = a packed array of pointers to packed arrays of (order+1) polynomial coefficients ( i.e. coefficients[ N ][ order + 1 ] ).
     * *                      The polynomials must appear in order from least to greatest sorted by area of influence.
     * *                      The polynomials must all be of the same order.
     * *                      The polynomial coefficients are sorted from 0th order term to highest order term
     * *
     * *      boundaries = a packed array of (N+1) floating point values that mark the dividing line between one polynomial and the next. These must be sorted from most negative to most positive.
     * *                        Input pixel values less than boundaries[0] will be clamped to be equal to boundaries[0] before the calculation is done
     * *                        Input pixel values greater than boundaries[N] will be clamped to be equal to boundaries[N] before the calculation is done
     * *
     * *      order = the number of coefficients minus one used for each polynomial -- all the polynomials must be of the same order
     * *                  A polynomial with _two_ coefficients (y = c0 + c1 * x) is a _first_ order polynomial. Pass 1 for a first order polynomial. Pass 2 for a second order polynomial, etc.
     * *
     * *      log2segments = log2(N)
     * *
     * *      flags = no flags are currently honored. You must pass zero here.
     * *
     * *      vImagePiecewisePolynomial_PlanarF will work in place.
     * *      vImagePiecewisePolynomial_Planar8toPlanarF will work in place.
     * *      vImagePiecewisePolynomial_PlanarFtoPlanar8 will NOT work in place.
     * *
     * *  Performance advisory:
     * *      It costs much more to resolve additional polynomials than to work with higher order polynomials.
     * *      For performance, you are typically better off with one 9th order polynomial that spans the range you are
     * *      interested in than many first order polynomials that cover the area in a piecewise fashion.
     * *      Vector code execution time is roughly proportional to:
     * *
     * *              time = (base cost to touch all the data) + polynomial order + 4 * log2segments
     * *
     * *      The vector code for an unsplit 13th order polynomial should be about as fast as vImageLookupTable_Planar8toPlanarF()
     * *          on a G4.
     * *
     * *      With data not in cache, the time may be significantly different. For sufficiently small polynomials, the
     * *      cost may be a fixed cost, dependent only on how much data is touched, and not on polynomial order.
     * *
     * *        This performance behavior is provided to help developers evaluate speed tradeoffs. It is not a guarantee.
     * *        It is subject to change in future operating system revisions, and may be different on different hardware
     * *        within the same or different operating system revisions.
     * *
     * *      Vector code is not invoked for log2segments > 3.
     * *
     * *  Accuracy advisory:
     * *      Single precision floating point arithmetic is used. While some polynomials may fit a desired curve
     * *      within prescribed error limits when using infinite precision math, limited floating point precision
     * *      may in practice cause significant error to accumulate for some sets of polynomial coefficients. It is
     * *      recommended that you test all reasonable floating point pixel values to make sure that they do indeed
     * *      give results that conform to prescribed error limits.
     * *
     * *
     * *  Usage Example:
     * *  --------------
     * *      Lets say you want to mimic the sRGB gamma curve using vImagePiecewisePolynomial_PlanarF. The sRGB gamma curve is defined as follows:
     * *
     * *              if( {R,G,B} < 0.00304 )
     * *                  result = 12.92 * {R,G,B}
     * *              else
     * *                  result = -0.055 + 1.055 * Pow( {R,G,B}, 2.4 )
     * *
     * *      Because the power function isn't a polynomial and we need a polynomial, we will approximate it with a second order polynomial:
     * *
     * *              if( {R,G,B} < 0.00304 )
     * *                  result = 12.92 * {R,G,B}
     * *              else
     * *                  result = c0 + c1 * {R,G,B} + c2 * {R,G,B}^2
     * *
     * *      (Finding the best values for c0, c1, c2 to approximate -0.055 + 1.055 * Pow( {R,G,B}, 2.4 ) over the range [0.00304, 1.0] is
     * *          left as an exercise for the reader.)
     * *
     * *      We have two polynomials -- one for the region below 0.00304 and one for the region above, so N = 2.
     * *      The highest order polynomial is a second order polynomial, so order = 2.
     * *
     * *              const int N = 2;        // two polynomials
     * *              const int order = 2;    // the polynomials are second order (have three terms, including zero terms)
     * *
     * *      The two polynomials are:
     * *
     * *              float linearPart[ order + 1 ] = { 0, 12.92, 0 };    // result = 0 + 12.92 * {R,G,B} + 0 * {R,G,B} * {R,G,B}
     * *              float nonLinearPart[ order + 1 ] = { c0, c1, c2 };  // result = c0 + c1 * {R,G,B} + c2 * {R,G,B} * {R,G,B}
     * *
     * *      Here we assemble the rest of the information:
     * *
     * *              float *coefficients[ N ] = { linearPart, nonLinearPart };   // sorted in order of area of influence from least to greatest. ( x < 0.00304, x >= 0.00304 )
     * *              float boundaries[ N+1 ] = { 0.0f, 0.00304, 1.0f };      // sorted in order from least to greatest. 0.0f and 1.0f define the range over which the polynomials are valid. 0.00304 is the single value separating the two polynomials
     * *              int log2segments = 1;   // log2(N)
     * *              int flags = 0;          // no flags
     * *
     * *              VIMAGE_PF vImage_Error error = vImagePiecewisePolynomial_PlanarF( &mySourceBuffer, &myDestinationBuffer, coefficients, boundaries, order, log2segments, flags );
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageSymmetricPiecewisePolynomial_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            Ptr<ConstFloatPtr> coefficients, ConstFloatPtr boundaries, int order, int log2segments, int flags);

    /**
     * *      vImagePiecewiseRational_PlanarF is similar to vImagePiecewisePolynomial_PlanarF
     * *      Except that it evaluates a piecewise rational expression in the form of:
     * *
     * *                      c0 + c1*x + c2*x^2 + c3*x^3...
     * *          result = -----------------------------------
     * *                      d0 + d1*x + d2*x^2 + d3*x^3...
     * *
     * *      The function is behaves nearly exactly like vImagePiecewisePolynomial_PlanarF, except that
     * *      there are now two polynomials, for top and bottom of the divide shown above. Each
     * *      polynomial has its own set of coefficients and its own polynomial order. The two
     * *      polynomials share the same set of segment boundaries. If the polynomials are split then
     * *      all the top polynomials must be of the same order, and all the bottom polynomials must
     * *      be of the same order. However, regardless of whether the polynomial is split or not,
     * *      the top polynomials do not need to be the same order as the bottom polynomials.
     * *
     * *      This function does not deliver IEEE-754 correct division. The divide does not round per
     * *      the IEEE-754 current rounding mode. It incurs up to 2 ulps of error. Edge cases involving
     * *      denormals, infinities, NaNs and division by zero return undefined results. (They will not
     * *      crash, but NaN is a likely result in such cases.) Denormals can be rescued on AltiVec enabled
     * *      machines by turning off the Non-Java bit in the VSCR, at the expense of taking a many-thousand
     * *      cycle kernel exception every time a denormal number is encountered. Since you can predict ahead
     * *      of time whether a given set of bounded polynomials is going to encounter these conditions,
     * *      this problem should be avoidable by wise choice of polynomials. Developers who require IEEE-754
     * *      correct results should call the polynomial evaluator above twice and do the division themselves.
     * *
     * *      These functions will also work for multichannel data, such as RGBAFFFF buffers by adjusting the
     * *      width of the buffer to reflect the additional channels. Note that this will cause the alpha channel,
     * *      if there is one, to become modified like the other channels.
     * *
     * *      These will work in place, provided that the following are true:
     * *          src->data == dest->data
     * *          src->rowBytes >= dest->rowBytes
     * *          if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter
     * <p>
     * *      Performance Advisory:
     * *        Approximate cost of evaluating a rational (in the same units as polynomial above) is:
     * *
     * *              time = (base cost to touch all the data)
     * *                          + top polynomial order
     * *                          + bottom polynomial order
     * *                          + 4
     * *                          + 4 * log2segments
     * *
     * *        With data not in cache, the time may be significantly different. For sufficiently small polynomials, the
     * *        cost may be a fixed cost, dependent only on how much data is touched, and not on polynomial order.
     * *
     * *        This performance behavior is provided to help developers evaluate speed tradeoffs. It is not a guaranteed.
     * *        It is subject to change in future operating system revisions, and may be different on different hardware
     * *        within the same or different operating system revisions.
     * *
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImagePiecewiseRational_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest,
            Ptr<ConstFloatPtr> topCoefficients, Ptr<ConstFloatPtr> bottomCoefficients, ConstFloatPtr boundaries,
            int topOrder, int bottomOrder, int log2segments, int flags);

    /**
     * vImageInterpolatedLookupTable_PlanarF
     * <p>
     * Results are calculated as follows:
     * <p>
     * float clippedPixel = MAX( MIN( src_pixel, maxFloat ), minFloat );    //clip src_pixel to be in range
     * float fIndex = (float) (tableEntries - 1) * (clippedPixel - minFloat ) / (maxFloat - minFloat);
     * float fract = fIndex - floor( fIndex );
     * unsigned long index =  fIndex;
     * float result = table[ index ] * ( 1.0f - fract ) + table[ index + 1] * fract;
     * <p>
     * In English, this translates to a lookup table that contains tableEntries values, that span
     * the input range of minFloat...maxFloat, inclusive, in an evenly spaced fashion.
     * <p>
     * tableEntries
     * <--------------------->
     * |
     * r |          ****
     * e |        *      *              *
     * s |                 *          *
     * u |                  *       *
     * l |                    *****
     * t +--------+---------------------+--------
     * minFloat              maxFloat
     * <p>
     * IMPORTANT: For correct operation, the table must be allocated to contain tableEntries+1 entries.
     * If the table is too small or the value of table[ tableEntries ] is infinite or NaN,
     * behavior is undefined.
     * <p>
     * The function will work in place, provided that the following are true:
     * src->data == dest->data
     * src->rowBytes >= dest->rowBytes
     * if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter
     * <p>
     * This function may be used on multichannel images by scaling the width by the number of channels.
     * The same table will be used for all the channels, including alpha, if there is an alpha channel.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageInterpolatedLookupTable_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, ConstFloatPtr table,
            @NUInt long tableEntries, float maxFloat, float minFloat, int flags);

    @Generated
    @CFunction
    public static native vImage_MultidimensionalTable vImageMultidimensionalTable_Create(ConstCharPtr tableData,
            int numSrcChannels, int numDestChannels, ConstBytePtr table_entries_per_dimension, int hint, int flags,
            NIntPtr err);

    /**
     * vImageMultidimensionalTable_Retain
     * vImageMultidimensionalTable_Release
     * <p>
     * A vImage_MultidimensionalTable follows Retain/Release semantics. On creation, the table has  a retain count of 1.
     * If you call vImageMultidimensionalTable_Retain on it, the retain count is incremented. If you call
     * vImageMultidimensionalTable_Release on it, the retain count is decremented. When the retain count reaches 0,
     * the object is destroyed. If any vImage function is called on an object whose reference count has already reached
     * 0, behavior is undefined.
     * <p>
     * Parameters:
     * table       A pointer to vImage_MultidimensionalTableData. If NULL, then nothing happens.
     * <p>
     * Errors:
     * kvImageNoError                  Success
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMultidimensionalTable_Retain(vImage_MultidimensionalTable table);

    @Generated
    @CFunction
    @NInt
    public static native long vImageMultidimensionalTable_Release(vImage_MultidimensionalTable table);

    @Generated
    @CFunction
    @NInt
    public static native long vImageMultiDimensionalInterpolatedLookupTable_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcs,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dests, VoidPtr tempBuffer,
            vImage_MultidimensionalTable table, int method, int flags);

    /**
     * vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12
     * <p>
     * vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12 is like vImageMultiDimensionalInterpolatedLookupTable_PlanarF
     * except that it operates on signed fixed-point data. The 16Q12 format is a signed 16-bit fixed-point value with 12 fractional
     * bits, 3 non-fractional bits and one sign bit. It can represent values in the range (-8,8). However the table always describes
     * a region between [0,1] in each dimension. Values outside this range are clamped to the nearest in-range value by Manhattan
     * distance before indexing the table. See vImageConvert_Planar8to16Q12 and vImageConvert_16Q12toPlanar8 for more on the format.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcs,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dests, VoidPtr tempBuffer,
            vImage_MultidimensionalTable table, int method, int flags);

    /**
     * [@function] vImageBuffer_Init
     * <p>
     * Convenience function to allocate a vImage_Buffer of desired size
     * <p>
     * This function is a convenience method to help initialize a vImage_Buffer struct with a buffer sized
     * and aligned for best performance. It will initialize the height, width and rowBytes fields, and allocate
     * the pixel storage for you. You are responsible for releasing the memory pointed to by buf->data back to
     * the system when you are done with it using free(). If no such allocation is desired, pass
     * kvImageNoAllocate in the flags to cause buf->data to be set to NULL and the preferred alignment
     * to be returned from the left hand side of the function.
     * <p>
     * Here is an example of typical usage:
     *
     * <pre>@textblock
     *     vImage_Buffer buf;
     *     vImage_Error err = vImageBuffer_Init( &buf, height, width, 8 * sizeof(pixel), kvImageNoFlags);
     *     ...
     * @/textblock</pre>
     * <p>
     * And typical usage using your own allocator (posix_memalign in this case):
     *
     * <pre>@textblock
     *     vImage_Buffer buf;
     *     ssize_t alignment = vImageBuffer_Init( &buf, height, width, 8 * sizeof(pixel), kvImageNoAllocate);
     *     if( alignment >= 0 )  // <0 is an error
     *         error = posix_memalign( &buf.data, alignment, buf.height * buf.rowBytes );  // An allocator
     * @/textblock</pre>
     * <p>
     * On return, buf is initialized to contain the provided height and width and best rowBytes for the image.
     * buf->data will also be allocated by default. If kvImageNoAllocate is passed then allocation is skipped,
     * buf->data is set to NULL, and the preferred alignment is returned out the left hand side of the
     * function.
     *
     * @param buf       A valid empty vImage_Buffer struct. On return, all fields will be initialized.
     *                  Please see behavior of kvImageNoAllocate in the flags parameter below.
     * @param height    The desired height of the image
     * @param width     The desired width of the image
     * @param pixelBits The number of bits in a pixel of image data. If the image is in a planar format
     *                  then this is the number of bits per color component. If pixelBits is not divisible
     *                  by 8, then vImage will pad the scanline out to a multiple of a byte so that
     *                  two scanlines can not share the same byte and all scanlines start at the start of
     *                  a byte.
     * @param flags     Must be from the following list:
     *
     *                  <pre>@textblock
     *                                          kvImageNoAllocate -- on return buf->data is initialized to NULL. A preferred
     *                                              alignment suitable for use with posix_memalign is returned out the left hand
     *                                              side of the function and buf->rowBytes will be set to the preferred rowBytes.
     *                                              If the left hand side return is negative, it is an error code, not a size.
     *
     *                                              If the kvImageNoAllocate flag is not passed, then on return buf->data will point
     *                                              to a newly allocated buffer with preferred alignment and rowBytes. An appropriate
     *                                              error code will be returned from the left hand side.
     *
     *                                          kvImagePrintDiagnosticsToConsole -- directs the function to print diagnostic information
     *                                              to the console in the event of failure.
     *                  @/textblock</pre>
     * @return One of the following error codes will be returned out the left hand side.
     *
     * <pre>@textblock
     *     >0                              kvImageNoAllocate was passed. The value returned indicates the
     *                                     preferred alignment (in bytes) for buf->data. buf->data is NULL.
     *
     *     kvImageNoError                  Success
     *
     *     kvImageMemoryAllocationError    you requested that buf->data be allocated but the allocation failed
     *
     *     kvImageUnknownFlagsBit          flags was not from the list above
     * @/textblock</pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageBuffer_Init(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer buf, @NUInt long height,
            @NUInt long width, int pixelBits, int flags);

    /**
     * [@function] vImageBuffer_GetSize
     * <p>
     * Returns size of a vImage_Buffer as a CGSize.
     * <p>
     * The CGSize / NSSize is rounded down to the nearest representable
     * CGFloat that is less than or equal to the actual size of the image. In practice
     * the conversion will always be exact, except for really, really big images. In
     * that case, some part of the bottom or right edge might be truncated.
     *
     * <pre>@textblock
     * Rationale: If you attempt your own home-made conversion to CGSize / NSSize by
     *           ordinary C rules and the value rounds, it will round up half the time.
     *           This could lead to a crash later because the height or width
     *           will be reported to be larger than it really is and an ensuing image
     *           operation will attempt to touch scanlines that don't exist.
     * @/textblock</pre>
     *
     * @param buf A pointer to a valid vImage_Buffer
     * @return The largest CGSize that will fit in the buffer. In typical usage, this
     * is equal to the size of the buffer.
     */
    @Generated
    @CFunction
    @ByValue
    public static native CGSize vImageBuffer_GetSize(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer buf);

    /**
     * [@function] vImageCGImageFormat_GetComponentCount
     * <p>
     * Calculate the number of channels (color + alpha) for a given image format
     * <p>
     * The number of channels may not be safely calculated as bitsPerPixel / bitsPerComponent.
     * Use this routine instead.
     *
     * @param format A pointer to a valid vImage_CGImageFormat.  If format->colorspace is NULL,
     *               the format is assumed to belong to the sRGB colorspace.
     * @return Returns the number of color + alpha channels in the image.
     */
    @Generated
    @CFunction
    public static native int vImageCGImageFormat_GetComponentCount(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat format);

    /**
     * [@function] vImageCGImageFormat_IsEqual
     * <p>
     * Test to see if two vImage_CGImageFormats are equivalent
     * <p>
     * Returns nonzero if two vImage_CGImageFormats are the same
     * If either operand is NULL, the result is false.
     * If vImage_CGImageFormat.colorSpace is NULL, sRGB is used.
     *
     * @param f1 A pointer to the first vImage_CGImageFormat
     * @param f2 A pointer to the second vImage_CGImageFormat
     * @return nonzero if two vImage_CGImageFormats are the same
     */
    @Generated
    @CFunction
    public static native byte vImageCGImageFormat_IsEqual(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat f1,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat f2);

    /**
     * [@function] vImageBuffer_InitWithCGImage
     * <p>
     * Initialize a vImage_Buffer struct with the contents of a CGImageRef
     * <p>
     * This function will initialize a vImage_Buffer struct with an image from a CGImageRef.
     * By default, a new region of memory to hold the image data will be allocated by this function.  You may
     * optionally allocate the memory region yourself by passing in the kvImageNoAllocate flag.
     * <p>
     * You may release the CGImageRef and format->colorspace upon successful return of this function.
     * <p>
     * You are responsible for returning the memory referenced by buf->data to the system using free() when you are done with it.
     * The CGImage may have other metadata associated with it, such as camera orientiation, which may require further
     * processing downstream.  vImage just does 1:1 pixel conversions from the raw image source.
     * <p>
     * <p>
     * To create a CGImageRef from a image file on disk:
     *
     * <pre>@textblock
     *     CFURLRef path = ...;  // path to image
     *     CGImageSourceRef imageSource = CGImageSourceCreateWithURL( path, optionsDictionary ); // optionsDictionary may be NULL
     *     CGImageRef imageRef = CGImageSourceCreateImageAtIndex( imageSource, imageIndex, optionsDictionary );
     *  @/textblock</pre>
     * <p>
     * Similarly, with a chunk of compressed image data in memory:
     *
     * <pre>@textblock
     *     CFDataRef data = ...;
     *     CGImageSourceRef imageSource = CGImageSourceCreateWithData( path, optionsDictionary );
     *     CGImageRef imageRef = CGImageSourceCreateImageAtIndex( imageSource, imageIndex, optionsDictionary );
     *  @/textblock</pre>
     * <p>
     * You can do similar things through AppKit / UIKit with [NSImage initWithContentsOfFile:],
     * [NSImage initWithContentsOfURL:], or [NSImage initWithData:],  and use [NSImage CGImageForProposedRect:context:hints:]
     * to get out a CGImageRef.
     *
     * @param buf             A pointer to a valid vImage_Buffer struct. The fields of the structure pointed to by buf will
     *                        be updated to point to a vImage_Buffer representation of the CGImage. By default, a newly
     *                        allocated piece of memory will be used to hold the image. You are responsible
     *                        for releasing the memory pointed to by buf->data back to the system using free().
     *                        <p>
     *                        If you want to allocate the buf->data and initialize rowBytes yourself, then you may pass
     *                        kvImageNoAllocate in the flags parameter. This will cause the buf->data and rowBytes values
     *                        passed into the function to be used directly without modification.  You may find vImageBuffer_Init,
     *                        vImageCGImageFormat_GetPixelBits, CGImageGetWidth and CGImageGetHeight helpful in sizing your buffer.
     * @param format          A pointer to a valid vImage_CGImageFormat specifying the desired image format associated with the
     *                        output buf. If format->colorspace is NULL, sRGB will be used.
     * @param backgroundColor If the CGImageRef encodes an alpha (or mask) and the output format does not have alpha then the
     *                        result will be flattened against a background color. See vImageConverter_CreateWithCGImageFormat
     *                        and functions like vImageFlatten_ARGB8888ToRGB888 for more on flattening. The background color here is
     *                        a series of values of range [0,1] interpreted according to the colorspace passed in format. Example: If
     *                        the format encodes for a AGBR 8-bit image (kCGImageAlphaLast, kCGBitmapByteOrder32Little), then this would be
     *                        {red, green, blue}, the canonical ordering for a RGB colorspace, as an array of three CGFloats.
     *                        If NULL is passed, an array full of zeros is used. The backgroundColor must have at least as many
     *                        CGFloats in it as the colorspace has color channels. See CGColorSpaceGetNumberOfComponents.
     * @param image           A valid CGImageRef to be used as source data.
     * @param flags           You may set the following flags:
     *
     *                        <pre>@textblock
     *                                         kvImageNoAllocate       the buf->data and buf->rowBytes values passed in are used without modification.
     *                                                                 This allows you to allocate your own buffer to hold the result. See buf description
     *                                                                 above.
     *
     *                                         kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug messages.
     *
     *                                         kvImageDoNoTile         It is possible that vImage will have to do an image format conversion from the
     *                                                                 image native format to the desired format. This will turn off multithreading for
     *                                                                 that step and any other vImage work that is multithreaded. Since any such conversions
     *                                                                 are likely happening outside your tiling engine, use of this flag here is
     *                                                                 probably counterproductive. In rare cases, it might be valuable as a method to
     *                                                                 leave unoccupied some cores for other tasks, if you have other multithreaded time
     *                                                                 sensitive tasks running. Likewise, if you are converting multiple images concurrently,
     *                                                                 it might be helpful to avoid oversubscribing the system.
     *                         @/textblock </pre>
     * @return If the call succeeds, kvImageNoError is returned and the memory region pointed to by buf will be initialized to
     * describe a valid repesentation of the CGImageRef.
     * <p>
     * If the call fails, then one of the following error codes will be returned and buf->data will be set to NULL.
     *
     * <pre>@textblock
     *          kvImageUnknownFlagsBit              flags must be kvImageNoFlags or kvImageNoAllocate
     *          kvImageMemoryAllocationError        Not enough memory to allocate buf->data
     *          kvImageInvalidParameter             format->bitmapInfo has unknown bits set
     *          kvImageInvalidParameter             format->version is not 0 or 1
     *          kvImageInvalidParameter             format->decode is not NULL
     *          kvImageInvalidParameter             format->bitsPerComponent is not in {0,1,2,4,5,8,16,32}
     *          kvImageInvalidImageFormat           format->renderingIntent is not a known value
     *          kvImageInvalidImageFormat           The format called for conversion to an input-only colorspace. Some color profiles
     *                                              (e.g. those arising from a scanner) are described as input only, because the device can
     *                                              not produce image output.
     *          kvImageNullPointerArgument          format may not be NULL
     *          kvImageNullPointerArgument          image may not be NULL
     *          kvImageInternalError                Something unexpected went wrong. Please file a bug.
     *  @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageBuffer_InitWithCGImage(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer buf,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat format,
            ConstNFloatPtr backgroundColor, CGImageRef image, int flags);

    /**
     * [@function] vImageCreateCGImageFromBuffer
     * <p>
     * Create a CGImageRef from a vImage_Buffer.
     * <p>
     * This function creates a CGImageRef using the image data in a vImage_Buffer. The CGImageRef has a retain count of 1.
     * By default, a copy of the image data is made. This allows the function to convert to a CG-friendly format as necessary
     * and allows you to continue to use the vImage_Buffer without causing problems for the CGImageRef.
     *
     * <pre>@textblock
     * No copy mode
     * ------------
     * When the kvImageNoAllocate flag is passed, then "no-copy" operation is said to occur. Ownership of the memory region
     * pointed to by buf->data is transferred to the CGImageRef and it becomes private to and owned by that object and will
     * be used without modification. The memory region pointed to by buf->data will be destroyed when the CGImageRef is
     * destroyed. Caution: CGImageRefs are defined to be immutable once created. Behavior is undefined if you create
     * a CGImageRef then modify the pixels in its backing store.
     *
     * No-copy mode can be a little fussy about formats. When a format is rejected, kvImageInvalidImageFormat will be returned.
     * Formats that are likely to succeed are 8-bit unsigned, 16-bit unsigned and 32-bit floating-point. The image should be
     * kCGImageAlphaNone, kCGImageAlphaLast, kCGImageAlphaPremultipliedLast or kCGImageAlphaNoneSkipLast, and decode = NULL.
     * The image should be in host endian mode. This is kCGBitmapByteOrderDefault for 8-bit per component images, and or larger
     * types, the endianness is given by the endianness of the host system and the size is given by the size of the pixel
     * (bitsPerComponent < 8) or channel (bitsPerComponent > 8). For example RGB565 data should be kCGBitmapByteOrder16Little
     * and 32-bit floating point data should be kCGBitmapByteOrder32Little on little endian processors.
     *
     * It is recommended that if no-copy mode fails, that you try again without the kvImageNoAllocate flag. The call probably
     * will succeed.
     *  @/textblock </pre>
     * <p>
     * CGImage Debugging Note:
     * The format parameter describes the image data you pass in, but there is no requirement that this is the
     * format that is actually used to represent the image data held by the CGImage. You should be able to get
     * back the data in any format you like with vImageBuffer_InitWithCGImage. However, understand that if you
     * request the data through another API like CGDataProviderCopyData(), it will be formatted as described by
     * that API -- for CGDataProviderCopyData(), that would be as described by: CGImageGetBitmapInfo, CGImageGetDecode,
     * CGImageGetRenderingIntent, CGImageGetColorSpace, CGImageGetBytesPerRow, CGImageGetBitsPerPixel,
     * CGImageGetBitsPerComponent, etc.  Furthermore, the format that those APIs report is also not necessarily
     * the format of the data held by the CGImageRef.  Common image data consumers like CoreAnimation and
     * CoreGraphics have their format preferences and vImage caters to them in order to deliver good performance.
     * <p>
     * CGImageRefs can also be made from vImage_Buffers using CGImageCreate() and CGDataProviderCreateWithData().
     *
     * @param buf      The vImage_Buffer from which to make the CGImageRef
     * @param format   The image format of the vImage_Buffer. format may not be NULL.  format->colorspace may be NULL,
     *                 in which case sRGB will be used.  The colorspace is retained as needed by the new CGImage.
     * @param callback In no-copy mode, this callback is called to destroy the buf->data when the CGImageRef no longer needs it.
     *                 If NULL is passed for the callback, then free() will be used to destroy buf->data.  userData will be
     *                 passed to the callback function as the userData parameter and buf->data passed as the buf_data parameter.
     *                 <p>
     *                 This parameter has no effect if kvImageNoAllocate is not in flags.
     *                 <p>
     *                 The callback may be called at any time from any thread. It is possible for it to be called before
     *                 vImageCreateCGImageFromBuffer returns.
     *                 <p>
     *                 The callback will not be called if the returned CGImageRef is NULL.
     * @param userData The value to pass to the callbacks userData parameter. If callback is NULL or kvImageNoAllocate
     *                 is passed in flags, this value is ignored.
     * @param flags    The following flags are allowed:
     *                 <pre>@textblock
     *                                  kvImageNoAllocate                   Causes vImageCreateCGImageFromBuffer to run in no-copy mode.
     *                                                                      Ownership of the memory pointed to by buf->data is transferred
     *                                                                      to the CGImageRef.  You'll need to set up a callback and userData
     *                                                                      to manage releasing the memory back to the system when the CGImage
     *                                                                      is done with it.
     *
     *                                  kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug messages.
     *
     *                                  kvImageHighQualityResampling        Sometimes the system will ask for the image to be resamled to
     *                                                                      a smaller size. If that happens vImageAffineWarp_<fmt>" will be
     *                                                                      called. In that case, the value of this bit will be used to
     *                                                                      determine whether Lanczos3 or Lanczos5 resampling is used.
     *
     *                                  kvImageDoNotTile                    Disables multithreading in any conversions that need to be done.
     *                                                                      Since it seems likely any such conversions will not be running in
     *                                                                      the context of your tiling engine (if you wrote one) in this case,
     *                                                                      this flag is probably counterproductive in this context. Conversions
     *                                                                      can happen later, after this call returns, when the image is drawn.
     *                  @/textblock </pre>
     * @param error    if not NULL, points to a more informative error code to describe what went wrong on exit. May be NULL.
     *                 Testing the result against NULL is sufficient to detect success or failure. kvImagePrintDiagnosticsToConsole
     *                 is another way to get error information.
     * @return On success, the returned CGImageRef will be non-NULL. If error is not NULL, kvImageNoError will be written there.
     * On failure, NULL will be returned, and if error is not NULL, a more informative error code will be written there.
     *
     * <pre>@textblock
     *  Error Values:
     *      kvImageUnknownFlagsBit              flags was not from the list described in the flags parameter above
     *      kvImageMemoryAllocationError        Not enough memory to allocate the new CGImageRef
     *      kvImageInvalidParameter             format->bitmapInfo has unknown bits set
     *      kvImageInvalidParameter             format->bitsPerComponent is not in {5,8,16,32}
     *      kvImageInvalidImageFormat           format->renderingIntent is not a known value
     *      kvImageNullPointerArgument          format may not be NULL
     *      kvImageNullPointerArgument          buf may not be NULL
     *  @/textblock </pre>
     */
    @Generated
    @CFunction
    public static native CGImageRef vImageCreateCGImageFromBuffer(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer buf,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat format,
            @FunctionPtr(name = "call_vImageCreateCGImageFromBuffer") Function_vImageCreateCGImageFromBuffer callback,
            VoidPtr userData, int flags, NIntPtr error);

    /**
     * [@function] vImageConverter_Retain
     * <p>
     * Retain a vImageConverterRef
     * <p>
     * You should retain a vImageConverterRef when you receive it from elsewhere (that is, you did not
     * create or copy it) and you want it to persist. If you retain a vImageConverterRef you are responsible
     * for releasing it (see Memory Management Programming Guide for Core Foundation).
     * <p>
     * Like all of vImage, this interface is thread safe and may be called reentrantly.
     *
     * @param converter The vImageConverter to retain. If NULL, then nothing happens.
     */
    @Generated
    @CFunction
    public static native void vImageConverter_Retain(vImageConverterRef converter);

    /**
     * [@function] vImageConverter_Release
     * <p>
     * Release a vImageConverterRef
     * <p>
     * If the retain count of a vImageConverterRef becomes zero, the memory allocated to the
     * object is deallocated and the object is destroyed. If you create or explicitly
     * retain (see the vImageConverter_Retain function) a vImageConverterRef, you are responsible for
     * releasing it when you no longer need it (see Memory Management Programming Guide for Core Foundation).
     * <p>
     * Like all of vImage, this interface is thread safe and may be called reentrantly.
     *
     * @param converter The vImageConverter to release. If NULL, then nothing happens.
     */
    @Generated
    @CFunction
    public static native void vImageConverter_Release(vImageConverterRef converter);

    /**
     * [@function] vImageConverter_CreateWithCGImageFormat
     * <p>
     * Create a vImageConverterRef to convert from one vImage_CGImageFormat to another
     * <p>
     * vImageConverter_CreateWithCGImageFormat creates a vImageConverter to convert between
     * image formats describable with a vImage_CGImageFormat.  The vImageConverter is intended
     * to be used (and reused, possibly reentrantly) with vImageConvert_AnyToAny() to convert
     * images from one format to another.
     *
     * <pre>@textblock
     * Image Format Notes:
     *     CG Integer images map the range [0,1.0] (black to full color intensity) to the range [0, TYPE_MAX]. A 8-bit unsigned image
     * has a range [0,255] and a 16-bit signed image has a range [0,32767]. Floating point images map [0,1.0] to [0,1.0]. Some formats,
     * like floating-point and signed integers are capable of representing values outside of that range. Conversions involving these
     * formats will occasionally produce results outside of [0,1]. If the conversion causes a value to go out of the representable range
     * for the underlying type, it will be clamped to the nearest representable value. This can happen in normal operation during color
     * correction. You can clamp floating-point results back into [0,1] using vImageClip_PlanarF, if you like.
     *
     *     Usually, colors must be direct mapped. Indexed color is supported format->bitsPerComponent and format->.bitsPerPixel are 1,2,4
     * or 8, and equal (i.e. grayscale) only. Indexed color is not supported for the destination image. Images with indexed color must use
     * (kCGImageAlphaNone | kCGBitmapByteOrderDefault) as the bitmapInfo. It is usually faster with indexed color spaces to use
     * vImageConvert_AnyToAny to convert the color table rather than the image itself when possible, because the table is usually much
     * smaller than the image. vImageConvert_AnyToAny can not do that automatically for you behind the scenes because it does not return
     * a modified colorspace.
     *
     * Device Colorspaces:
     * Because vImage has no concept of a rendering context or destination graphics device, vImage maps device RGB, device grayscale
     * and device CMYK to a virtual device which is not your display. The virtual device uses kColorSyncGenericGrayGamma22Profile,
     * kColorSyncSRGBProfile and kColorSyncGenericCMYKProfile respectively. If you want the image to be converted to the right colorspace
     * for your display device, you will need to pass in the CGColorSpaceRef for that device obtained from an API like CGDisplayCopyColorSpace().
     *
     * Black Point Compensation:
     * By default, BPC is off for this function. If you want black point compensation or other advanced ColorSync effects, construct your
     * own ColorSyncTransformRef and pass the associated "code fragment" to vImageConverter_CreateWithColorSyncCodeFragment.
     * See Apple Sample Code "Converting an Image with Black Point Compensation" https://developer.apple.com/library/mac/samplecode/convertImage/Introduction/Intro.html
     * @/textblock </pre>
     * <p>
     * See also vImageConverter_CreateForCGToCVImageFormat and vImageConverter_CreateForCVToCGImageFormat for converters
     * that can operate on CoreVideo formats.
     *
     * @param srcFormat       A pointer to a populated vImage_CGImageFormat struct describing the image format
     *                        of the source image. If the CGColorSpaceRef is NULL, sRGB will be used
     *                        as the default value. The CGColorSpaceRef will be retained by this function. It
     *                        will be released when the vImageConverter is destroyed.
     * @param destFormat      A pointer to a populated vImage_CGImageFormat struct describing the image format
     *                        of the destination image. If the CGColorSpaceRef is NULL, sRGB will be
     *                        used as the default value. The CGColorSpaceRef will be retained by this function.
     *                        It will be released when the vImageConverter is destroyed.
     * @param backgroundColor Points to an array of floats to be used as a background color if one is needed. The
     *                        backgroundColor range is assumed to be [0,1]. The channel ordering and number of color
     *                        channels must match the natural order of the destination colorSpace (e.g. RGB or CMYK).
     *                        The backgroundColor may be NULL if no background color is needed.
     *                        <p>
     *                        A background color is used when the image is converted from an alpha-containing format
     *                        to an alpha-none format, in which case the alpha is removed by compositing against the
     *                        opaque background color pointed to by this parameter. If the image is instead converted
     *                        from one alpha containing format to another, then the image will be premultiplied or
     *                        unpremultiplied as necessary and no background color is necessary. (For unpremultiplication,
     *                        the result color value for pixels with alpha 0 is 0.)  Likewise, when converting between
     *                        alpha-none formats, a background color is not used. In the case of kCGImageAlphaNone ->
     *                        kCGImageAlphaNoneSkipFirst/Last, the vacant alpha channel is filled in with 1.0. If NULL
     *                        is passed here, then 0 will be used for the color channels.
     *                        <p>
     *                        The vImageConverter will contain a copy of the data passed in this field.
     * @param flags           Any of the following flags are allowed:
     *
     *                        <pre>@textblock
     *                                 kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug
     *                                                                     messages.
     *
     *                                 kvImageDoNotTile                    A converter created with this flag will operate as if
     *                                                                     kvImageDoNotTile was passed to vImageConvert_AnyToAny
     *                                                                     whether it was or not.
     *                        @/textblock </pre>
     * @param error           May be NULL.  If not NULL, then a vImage_Error is returned at the address pointed to by error.
     *                        The vImage_Error will be less than 0 if an error condition occurred. Checking the vImageConverter
     *                        returned to make sure it is non-NULL is sufficient to verify success or failure of the function.
     *                        <p>
     *                        The following error values can occur:
     *                        <pre>@textblock
     *                            kvImageNoError                      Success.
     *
     *                            kvImageNullPointerArgument          srcFormat and/or destFormat is NULL.
     *
     *                            kvImageUnknownFlagsBit              Currently only kvImagePrintDiagnosticsToConsole and kvImageDoNotTile are
     *                                                                allowed. All other bits in the flags field must be 0.
     *
     *                            kvImageInvalidParameter             backgroundColor is NULL and the conversion needed a backgroundColor
     *
     *                            kvImageInvalidImageFormat           bitsPerComponent must be in {1,2,4,5,8,12,16,32}.
     *                            kvImageInvalidImageFormat           The base colorspace must be grayscale for destination images using indexed color.
     *                            kvImageInvalidImageFormat           The colorspace may be indexed color for images only if it is {1,2,4,8} bitsPerComponent
     *                                                                and kCGImageAlphaNone.
     *                            kvImageInvalidImageFormat           vImage_CGImageFormat.bitmapInfo & kCGBitmapAlphaInfoMask  does not encode a valid alpha
     *                            kvImageInvalidImageFormat           floating point formats must be 16 or 32 bits per component. 16-bit floats are
     *                                                                IEEE-754-2008 binary16 interchange format  (a.k.a. OpenEXR half float). 32-bit floats
     *                                                                are the standard IEEE-754-2008 binary32 interchange format. (a.k.a float in C/C++/ObjC)
     *                            kvImageInvalidImageFormat           format->renderingIntent is not a known value
     *                            kvImageInvalidImageFormat           The conversion called for conversion to an input-only colorspace. Some color profiles
     *                                                                (e.g. those arising from a scanner) are described as input only, because the device can
     *                                                                not produce image output.
     *
     *                            kvImageInternalError                The converter was unable to find a path from the source format to the destination format.
     *                                                                This should not happen and indicates incorrect operation of the function. Please file a bug.
     *                                                                The kvImagePrintDiagnosticsToConsole flag will provide additional diagnostic info.
     *                        @/textblock </pre>
     *                        <p>
     *                        In cases where the error code is not sufficient to quickly determine the problem, the kvImagePrintDiagnosticsToConsole flag
     *                        should provide additional diagnostic info.
     * @return A vImageConverter object with reference count of 1 is created. If the call fails due to an error, then NULL
     * will be returned. Use vImageConverter_Release to release your reference to it and allow the resources used
     * by the converter to be returned to the system.
     * <p>
     * If error is not NULL, an error code will be written to that address on return.
     */
    @Generated
    @CFunction
    public static native vImageConverterRef vImageConverter_CreateWithCGImageFormat(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat srcFormat,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat destFormat,
            ConstNFloatPtr backgroundColor, int flags, NIntPtr error);

    /**
     * [@function] vImageConverter_CreateWithColorSyncCodeFragment
     * <p>
     * Create a vImageConverterRef substituting in a custom ColorSync transform for the one vImage usually generates for the color conversion steps.
     * <p>
     * vImageConverter_CreateWithColorSyncCodeFragment is like vImageConverter_CreateWithCGImageFormat, except that
     * instead of creating its own colorspace transform for any colorspace conversions, it uses the one you pass in.
     * This gives you greater control over the fine details of colorspace conversion, for exacting color fidelity.
     * The colorspaces for source and destination images must refer to colorspaces that have the same number of channels
     * as the codeFragment is designed to accept / produce.
     * <p>
     * See Apple Sample Code "Converting an Image with Black Point Compensation" https://developer.apple.com/library/mac/samplecode/convertImage/Introduction/Intro.html
     * for an example of usage.
     *
     * @param codeFragment    A code fragment created with ColorSyncTransformCopyProperty( kColorSyncTransformFullConversionData,
     *                        kColorSyncTransformParametricConversionData or kColorSyncTransformSimplifiedConversionData)
     *                        May be NULL.  If NULL, no colorspace conversion / correction is done. In this case,
     *                        behavior is undefined if the colorspaces do not have the same channel order or have a
     *                        different number of channels or the colorspaces are not from the same family.
     *                        kColorSyncTransformFullConversionData is required for black point compensation.
     *                        CAUTION: vImageConverter_CreateWithColorSyncCodeFragment does not verify that the
     *                        codeFragment is actually appropriate for the srcFormat and destFormat provided. Nor
     *                        does it attempt to append additional color space transformation steps to make the
     *                        codeFragment appropriate to the images provided. If the colorspace of the srcFormat
     *                        and destFormat do not correspond to the ColorSyncProfileRefs used to create the
     *                        ColorSync transform in at least colorspace model, then the behavior is undefined.
     *                        See CGColorSpaceModel CoreGraphics/CGColorSpace.h
     * @param srcFormat       A pointer to a populated vImage_CGImageFormat struct describing the image format
     *                        of the source image. If the CGColorSpaceRef is NULL, sRGB will be used
     *                        as the default value. The CGColorSpaceRef will be retained by this function. It
     *                        will be released when the vImageConverter is destroyed.
     * @param destFormat      A pointer to a populated vImage_CGImageFormat struct describing the image format
     *                        of the destination image. If the CGColorSpaceRef is NULL, sRGB will be
     *                        used as the default value. The CGColorSpaceRef will be retained by this function.
     *                        It will be released when the vImageConverter is destroyed.
     * @param backgroundColor Points to an array of floats to be used as a background color if one is needed. The
     *                        backgroundColor range is assumed to be [0,1]. The channel ordering and number of color
     *                        channels must match the natural order of the destination colorSpace (e.g. RGB or CMYK).
     *                        The backgroundColor may be NULL if no background color is needed.
     *                        <p>
     *                        A background color is used when the image is converted from an alpha-containing format
     *                        to an alpha-none format, in which case the alpha is removed by compositing against the
     *                        opaque background color pointed to by this parameter. If the image is instead converted
     *                        from one alpha containing format to another, then the image will be premultiplied or
     *                        unpremultiplied as necessary and no background color is necessary. (For unpremultiplication,
     *                        the result color value for pixels with alpha 0 is 0.)  Likewise, when converting between
     *                        alpha-none formats, a background color is not use. In the case of kCGImageAlphaNone ->
     *                        kCGImageAlphaNoneSkipFirst/Last, the vacant alpha channel is filled in with 1.0. If NULL
     *                        is passed here, then 0 will be used for the color channels.
     *                        <p>
     *                        The vImageConverter will contain a copy of the data passed in this field.
     * @param flags           Any of the following flags are allowed:
     *
     *                        <pre>@textblock
     *                                  kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug
     *                                                                      messages.
     *
     *                                  kvImageDoNotTile                    A converter created with this flag will operate as if
     *                                                                      kvImageDoNotTile was passed to vImageConvert_AnyToAny
     *                                                                      whether it was or not.
     *                         @/textblock </pre>
     * @param error           May be NULL.  If not NULL, then a vImage_Error is returned at the address pointed to by error.
     *                        The vImage_Error will be less than 0 if an error condition occurred. Checking the vImageConverter
     *                        returned to make sure it is non-NULL is sufficient to verify success or failure of the function.
     *                        <p>
     *                        The following error values can occur:
     *                        <pre>@textblock
     *                             kvImageNoError                      Success.
     *
     *                             kvImageNullPointerArgument          srcFormat and/or destFormat is NULL.
     *
     *                             kvImageUnknownFlagsBit              Currently only kvImagePrintDiagnosticsToConsole and kvImageDoNotTile are
     *                                                                 allowed. All other bits in the flags field must be 0.
     *
     *                             kvImageInvalidParameter             backgroundColor is NULL and the conversion needed a backgroundColor
     *
     *                             kvImageInvalidImageFormat           bitsPerComponent must be in {1,2,4,5,8,12,16,32}.
     *                             kvImageInvalidImageFormat           The base colorspace must be grayscale for destination images using indexed color.
     *                             kvImageInvalidImageFormat           The colorspace may be indexed color for images only if it is {1,2,4,8} bitsPerComponent
     *                                                                 and kCGImageAlphaNone.
     *                             kvImageInvalidImageFormat           vImage_CGImageFormat.bitmapInfo & kCGBitmapAlphaInfoMask  does not encode a valid alpha
     *                             kvImageInvalidImageFormat           floating point formats must be 16 or 32 bits per component. 16-bit floats are
     *                                                                 IEEE-754-2008 binary16 interchange format  (a.k.a. OpenEXR half float). 32-bit floats
     *                                                                 are the standard IEEE-754-2008 binary32 interchange format. (a.k.a float in C/C++/ObjC)
     *                             kvImageInvalidImageFormat           format->renderingIntent is not a known value
     *                             kvImageInvalidImageFormat           The conversion called for conversion to an input-only colorspace. Some color profiles
     *                                                                 (e.g. those arising from a scanner) are described as input only, because the device can
     *                                                                 not produce image output.
     *
     *                             kvImageInvalidImageFormat           codeFragment was found to be otherwise invalid / unusable
     *
     *                             kvImageInternalError                The converter was unable to find a path from the source format to the destination format.
     *                                                                 This should not happen and indicates incorrect operation of the function. Please file a bug.
     *                                                                 The kvImagePrintDiagnosticsToConsole flag will provide additional diagnostic info.
     *                         @/textblock </pre>
     *                        <p>
     *                        In cases where the error code is not sufficient to quickly determine the problem, the kvImagePrintDiagnosticsToConsole flag
     *                        should provide additional diagnostic info.
     * @return A vImageConverter object with reference count of 1 is created. If the call fails due to an error, then NULL
     * will be returned. Use vImageConverter_Release to release your reference to it and allow the resources used
     * by the converter to be returned to the system.
     * <p>
     * If error is not NULL, an error code will be written to that address on return.
     */
    @Generated
    @CFunction
    public static native vImageConverterRef vImageConverter_CreateWithColorSyncCodeFragment(ConstVoidPtr codeFragment,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat srcFormat,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat destFormat,
            ConstNFloatPtr backgroundColor, int flags, NIntPtr error);

    /**
     * [@function]  vImageConverter_MustOperateOutOfPlace
     * <p>
     * Determine whether a converter is capable of operating in place.
     * <p>
     * Some conversions will work if the src and destination image buffer
     * scanlines start at the same address. Others will not. In such cases,
     * you need to allocate additional storage to hold the destination buffer.
     * This function returns kvImageOutOfPlaceOperationRequired if the conversion
     * requires out of place operation.
     *
     * <pre>@textblock
     *       In-place operation is considered to mean srcs[i].data = dests[i].data
     *       and srcs[i].rowBytes = dests[i].rowBytes. Other styles of partial buffer
     *       overlap produce undefined behavior.
     *  @/textblock </pre>
     * <p>
     * The list of source and destination buffers is optional. Results are as follows:
     *
     * <pre>@textblock
     *      srcs = dests = NULL         kvImageNoError if any conversion with this converter is guaranteed to work in place,
     *                                  provided that srcs[i].data = dests[i].data and srcs[i].rowBytes = dests[i].rowBytes.
     *                                  If there exists at least one combination of height and width for which in place operation
     *                                  is not possible with this converter, then kvImageOutOfPlaceOperationRequired will be returned.
     *
     *      srcs != NULL, dests = NULL  kvImageNullPointerArgument
     *      srcs = NULL, dests != NULL  kvImageNullPointerArgument
     *
     *      srcs != NULL, dests != NULL kvImageNoError if the conversion will successfully operate in place for this particular
     *                                  combination of heights, widths and rowBytes. In this case, vImage does not check to see if the
     *                                  buffers overlap. It presumes that srcs[i].data = dests[i].data.  This is intended to allow
     *                                  you to defer allocation until later.  If in place operation will not work, then
     *                                  kvImageOutOfPlaceOperationRequired is returned.
     *  @/textblock </pre>
     * <p>
     * In no case during this function call does vImage examine the contents of the memory pointed to by srcs[i].data or dests[i].data.
     *
     * @param converter The converter to check
     * @param srcs      The list of source buffers you plan to use with vImageConvert_AnyToAny. May be NULL.
     * @param dests     The list of destination buffers you plan to use with vImageConvert_AnyToAny. May be NULL.
     * @param flags     The flags you plan to pass to vImageConvert_AnyToAny.
     *
     *                  <pre>@textblock
     *                                               Note: in the case of kvImagePrintDiagnosticsToConsole, the flag means print
     *                                               error information to the console for errors caught by vImageConverter_MustOperateOutOfPlace,
     *                                               not vImageConvert_AnyToAny. At times, vImageConverter_MustOperateOutOfPlace may fail because
     *                                               it detects an error condition that would cause vImageConvert_AnyToAny to fail.
     *                   @/textblock </pre>
     * @return Error Codes:
     * <pre>@textblock
     *      kvImageNoError                      In-place operation will work
     *      kvImageNullPointerArgument          The converter may not be NULL
     *      kvImageNullPointerArgument          srcs and dests must either both be NULL or neither must be NULL.
     *      kvImageInvalidParameter             The converter is invalid
     *      kvImageUnknownFlagsBit              An unknown / unsupported flag was used
     *      kvImageOutOfPlaceOperationRequired  vImageConvert_AnyToAny requires separate buffers be used for this operation
     *  @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConverter_MustOperateOutOfPlace(vImageConverterRef converter,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcs,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dests, int flags);

    /**
     * [@function] vImageConverter_GetNumberOfSourceBuffers
     * <p>
     * Get the number of source buffers consumed by the converter.
     * <p>
     * All formats discribed by a vImage_CGImageFormat just consume one vImage_Buffer
     * and produce one vImage_Buffer. There are no multi-plane vImage_CGImageFormats.
     * However, some video formats (see vImage/vImage_CVUtilities) have planar
     * data formats with data in more than one plane. For such conversions, it may be
     * necessary to know how many input buffers are consumed by a converter.
     * <p>
     * For older operating systems, where these functions are not available,
     * the number of source and destination buffers is always 1.
     *
     * @param converter The conversion for which you wish to know the number of source buffers
     * @return On success, the number of source buffers is returned.  On failure, 0 is returned.
     */
    @Generated
    @CFunction
    @NUInt
    public static native long vImageConverter_GetNumberOfSourceBuffers(vImageConverterRef converter);

    /**
     * [@function] vImageConverter_GetNumberOfDestinationBuffers
     * <p>
     * Get the number of destination buffers written to by the converter.
     * <p>
     * All formats discribed by a vImage_CGImageFormat just consume one vImage_Buffer
     * and produce one vImage_Buffer. There are no multi-plane vImage_CGImageFormats.
     * However, some video formats (see vImage/vImage_CVUtilities) have planar
     * data formats with data in more than one plane. For such conversions, it may be
     * necessary to know how many out buffers are overwritten by a converter.
     * <p>
     * For older operating systems, where these functions are not available,
     * the number of source and destination buffers is always 1.
     *
     * @param converter The conversion for which you wish to know the number of result buffers
     * @return On success, the number of result buffers is returned.  On failure, 0 is returned.
     */
    @Generated
    @CFunction
    @NUInt
    public static native long vImageConverter_GetNumberOfDestinationBuffers(vImageConverterRef converter);

    /**
     * [@function] vImageConverter_GetSourceBufferOrder
     * <p>
     * Get a list of vImage_Buffer channel names specifying the order of planes
     * <p>
     * These functions describe the identity of each buffer passed in the srcs parameters of vImageConvert_AnyToAny,
     * to allow you to order the buffers correctly. It is provided for informational purposes, to help wire up image
     * processing pipelines to vImage that are not supported through more direct means, CGImages, CVPixelBuffers, the alternative
     * handling of which is described at the end of this comment.
     * <p>
     * Prior to OS X.10 and iOS 8.0, only CG Image formats are handled by vImageConvert_AnyToAny. Had these functions existed
     * then, the result would always be {kvImageBufferTypeCode_CGFormat, kvImageBufferTypeCode_EndOfList}
     *
     * <pre>@textblock
     * Simplified Common Cases
     * -----------------------
     *   CGImageRefs:
     *     CoreGraphics formats always come as a single buffer, with one or more channels. No buffer ordering is
     *     requred. The buffer order is always kvImageBufferTypeCode_CGFormat. Prior to OS X.10 and iOS 8.0, only
     *     converters to CG image formats are available, so where these functions are not available, the answer would
     *     have always been { kvImageBufferTypeCode_CGFormat, 0}. As a point of trivia, the ordering of the channels
     *     within a buffer is by convention as follows:
     *
     *             number of channels = number of channels in colorspace + (alpha != kCGImageAlphaNone)
     *             alpha is either first or last, given by the alpha component of the CGBitmapInfo
     *             The ordering of the non-alpha channels is given by the colorspace, e.g. {R,G,B} for a RGB image.
     *             For 8-bit images, the ordering of the channels may be reversed according to
     *                 kCGBitmapByteOrderLittleEndian32 or kCGBitmapByteOrderLittleEndian16, but
     *                 the pixel size must match the endian swap chunk size. This gives you access to formats
     *                 like BGRA8888. If the endian is default or big endian, then no swap occurs.
     *
     *   CVPixelBufferRefs:
     *     Though these APIs will work for this purpose, it is expected to be simpler to use vImageBuffer_InitForCopyToCVPixelBuffer
     *     or vImageBuffer_InitForCopyFromCVPixelBuffer to set up a vImage_Buffer array for srcs and dests. Pass kvImageDoNotAllocate
     *     to have it automatically alias a locked CVPixelBuffer. The conversion will then copy the data right into or out of the
     *     CVPixelBuffer without further copying or modification.  (It may still need to be copied out to the GPU, for example, however.)
     *
     * @/textblock</pre>
     *
     * @param converter The conversion for which you wish to know the ordering of source or result buffers.
     *                  converter must be a valid vImageConverterRef.
     * @return The function returns a kvImageBufferTypeCode_EndOfList terminated array of buffer type codes. The type codes
     * indicate the order that the vImage_Buffers are passed in to vImageConvert_AnyToAny. The array is valid for the
     * lifetime of the vImageConverterRef.  It belongs to the vImageConverterRef and should not be freed by you.
     */
    @Generated
    @CFunction
    public static native ConstIntPtr vImageConverter_GetSourceBufferOrder(vImageConverterRef converter);

    /**
     * [@function] vImageConverter_GetDestinationBufferOrder
     * <p>
     * Get a list of vImage_Buffer channel names specifying the order of planes
     * <p>
     * These functions describe the identity of each buffer passed in the dests parameters of vImageConvert_AnyToAny,
     * to allow you to order the buffers correctly. It is provided for informational purposes, to help wire up image
     * processing pipelines to vImage that are not supported through more direct means, CGImages, CVPixelBuffers, the alternative
     * handling of which is described at the end of this comment.
     * <p>
     * Prior to OS X.10 and iOS 8.0, only CG Image formats are handled by vImageConvert_AnyToAny. Had these functions existed
     * then, the result would always be {kvImageBufferTypeCode_CGFormat, kvImageBufferTypeCode_EndOfList}
     *
     * <pre>@textblock
     * Simplified Common Cases
     * -----------------------
     *   CGImageRefs:
     *     CoreGraphics formats always come as a single buffer, with one or more channels. No buffer ordering is
     *     requred. The buffer order is always kvImageBufferTypeCode_CGFormat. Prior to OS X.10 and iOS 8.0, only
     *     converters to CG image formats are available, so where these functions are not available, the answer would
     *     have always been { kvImageBufferTypeCode_CGFormat, 0}. As a point of trivia, the ordering of the channels
     *     within a buffer is by convention as follows:
     *
     *             number of channels = number of channels in colorspace + (alpha != kCGImageAlphaNone)
     *             alpha is either first or last, given by the alpha component of the CGBitmapInfo
     *             The ordering of the non-alpha channels is given by the colorspace, e.g. {R,G,B} for a RGB image.
     *             For 8-bit images, the ordering of the channels may be reversed according to
     *                 kCGBitmapByteOrderLittleEndian32 or kCGBitmapByteOrderLittleEndian16, but
     *                 the pixel size must match the endian swap chunk size. This gives you access to formats
     *                 like BGRA8888. If the endian is default or big endian, then no swap occurs.
     *
     *   CVPixelBufferRefs:
     *     Though these APIs will work for this purpose, it is expected to be simpler to use vImageBuffer_InitForCopyToCVPixelBuffer
     *     or vImageBuffer_InitForCopyFromCVPixelBuffer to set up a vImage_Buffer array for srcs and dests. Pass kvImageDoNotAllocate
     *     to have it automatically alias a locked CVPixelBuffer. The conversion will then copy the data right into or out of the
     *     CVPixelBuffer without further copying or modification.  (It may still need to be copied out to the GPU, for example, however.)
     *
     * @/textblock</pre>
     *
     * @param converter The conversion for which you wish to know the ordering of source or result buffers.
     *                  converter must be a valid vImageConverterRef.
     * @return The function returns a kvImageBufferTypeCode_EndOfList terminated array of buffer type codes. The type codes
     * indicate the order that the vImage_Buffers are passed in to vImageConvert_AnyToAny. The array is valid for the
     * lifetime of the vImageConverterRef. It belongs to the vImageConverterRef and should not be freed by you.
     */
    @Generated
    @CFunction
    public static native ConstIntPtr vImageConverter_GetDestinationBufferOrder(vImageConverterRef converter);

    /**
     * [@function] vImageConvert_AnyToAny
     * <p>
     * Use a vImageConverterRef to convert the pixels in a vImage_Buffer to another format
     * <p>
     * With an appropriately configured vImageConverter, convert the image channels found in srcs
     * to the image channels found in dests. Whenever possible, conversion passes are vectorized and multithreaded
     * to reduce the time and energy cost of the function.
     * <p>
     * Please use vImageConverter_MustOperateOutOfPlace() to determine whether a particular conversion can operate in place.
     * For an in-place conversion to work, it is required that srcs[i].data = dests[i].data and srcs[i].rowBytes = dests[i].rowBytes.
     * <p>
     * All scanlines must start at an at least byte aligned address. (Some formats have 1, 2, 4 or 12 bits per channel/pixel and
     * conceivably might not start at a byte aligned address.) A single byte may not span multiple rows of data.
     * <p>
     * Some formats, particarly YUV 422 and 420 and those that have pixel size not evenly divisble by 8 bits, operate in chunks
     * containing multiple pixels. For example, a Y'CbCr 422 chunk may have {Y0, Cb, Y1, Cr} in the chunk. The chunk contains two
     * pixels, each with an independent Y (luminance) component, but shared chrominance.  Even though the chunk width is two,
     * it is still possible for an image to have a width that is not divisible by two. This means that some part of the chunk on
     * the rightmost edge of the scanline must refer to a non-existant pixel. When reading incomplete chunks, vImage will only
     * touch the unused parts of the chunk when it knows it to be safe to do so. When writing incomplete chunks, vImage will
     * copy the rightmost valid pixel color into the unused part of the chunk. Thus, on reading the entire chunk doesn't have to
     * be there, but on writing, it does. Conventions on this are varied among chunk using imaging pipelines and this conservative
     * approach should interoperate with most. However, some care must be exercised when writing to chunk based formats (not to be
     * confused with chunky formats which merely have several channels interleaved) to make sure that the buffer is large enough
     * to tolerate the write policy.  If you are tiling chunk based data, care must be taken not to run tile boundaries
     * through the middle of a chunk.  Chunks are assumed to be indivisible.
     *
     * @param converter  A valid vImageConverterRef indicating what conversion to do. The same vImageConverterRef
     *                   may be used concurrently from multiple threads. vImageConverterRefs may be created with
     *                   vImageConverter_CreateWithCGImageFormat, vImageConverter_CreateWithColorSyncCodeFragment,
     *                   vImageConverter_CreateForCGToCVImageFormat or vImageConverter_CreateForCVToCGImageFormat.
     *                   May not be NULL.
     * @param srcs       a pointer to an array of vImage_Buffer structs that describe the color planes that make
     *                   up the input image. Please see the description of the function that created the
     *                   vImageConverter for the ordering and number of input buffers. The ordering can also be
     *                   determined manually using vImageConverter_GetSourceBufferOrder.
     * @param dests      a pointer to an array of vImage_Buffer structs that describe the color planes that make
     *                   up the result image. Please see the description of the function that created the
     *                   vImageConverter for the ordering and number of output buffers. The ordering can also be
     *                   determined manually using vImageConverter_GetSourceBufferOrder. The destination buffer may
     *                   only alias the srcs buffers only if vImageConverter_MustOperateOutOfPlace() returns 0, and
     *                   only if the respective scanlines of the aliasing buffers start at the same address.
     * @param tempBuffer May be NULL. If not NULL, the memory pointed to by tempBuffer will be used as scratch space
     *                   by the function. The size of the tempBuffer can be determined by passing kvImageGetTempBufferSize
     *                   to the in the flags parameter. See below. If NULL is passed here and a tempBuffer is needed '
     *                   (temp buffer size > 0) then the function will allocate one on the heap and free it before
     *                   returning. This may run more slowly, both because of the allocation cost and the cost of VM
     *                   faults to zero fill pages as they are used. NULL is the right option when the function is
     *                   used infrequently or convenience is valued.
     * @param flags      The following flags are allowed. Other flags will trigger an error.
     *
     *                   <pre>@textblock
     *                                   kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug messages.
     *
     *                                   kvImageGetTempBufferSize            No image conversion work is done. The value returned out the
     *                                                                       left hand side of the function is the an error code if it is
     *                                                                       less than zero. Otherwise, it is the size of the tempBuffer
     *                                                                       to be passed into the function. The size may be 0.
     *
     *                                   kvImageDoNotTile                    Disables internal multithreading.  You may wish to pass this
     *                                                                       flag if you are doing your own threading and think it will
     *                                                                       conflict with vImage's attempts to do the same.
     *
     *                                   kvImageNoFlags                      Default behavior.
     *                   @/textblock </pre>
     * @return The following error codes may be returned:
     * <pre>@textblock
     *     kvImageNoError                      Success!
     *
     *     0                                   kvImageGetTempBufferSize was passed in flags, and no temp buffer is needed.
     *
     *     >0                                  kvImageGetTempBufferSize was passed in flags. The value indicates the size
     *                                         of the temp buffer needed.
     *
     *     kvImageMemoryAllocationError        NULL was passed in tempBuffer and vImage failed to allocate its own
     *                                             temp buffer
     *     kvImageBufferSizeMismatch           The source buffer(s) must be at least as large as the destination buffer(s)
     *                                          (src.height >= dest.height && src.width >= dest.width)
     *     kvImageUnknownFlagsBit              A flag was passed to the vImageConverter creation function which is
     *                                         unrecognized or not appropriate to this function
     *     kvImageNullPointerArgument          converter is NULL
     *     kvImageInvalidParameter             One of the buffers pointed to by srcs or dests has a NULL vImage_Buffer.data pointer
     *     kvImageUnknownFlagsBit              An unknown or unsupported flags bit was set.
     *     kvImageInvalidImageFormat           if a byte ordering is specified (e.g. kCGBitmapByteOrder16Little), the buffer.rowBytes
     *                                         must be multiple of 2 (kCGBitmapByteOrder16Little, kCGBitmapByteOrder16Big) or
     *                                         4 (kCGBitmapByteOrder32Little, kCGBitmapByteOrder32Big)
     * @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageConvert_AnyToAny(vImageConverterRef converter,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer srcs,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dests, VoidPtr tempBuffer,
            int flags);

    /**
     * [@function] vImageBuffer_InitWithCVPixelBuffer
     * <p>
     * Initializes a vImage_Buffer to contain a representation of the CVPixelBufferRef provided.
     * <p>
     * It does the following:
     *
     * <pre>
     *  @textblock
     *      o   Set buffer->height and buffer->width to match the size of the provided image.
     *
     *      o   set buffer->rowBytes for good performance                               (see kvImageDoNotAllocate flag below)
     *
     *      o   allocate a region of memory and assign a pointer to it to buffer->data  (see kvImageDoNotAllocate flag below)
     *
     *      o   convert the pixels contained in the image to the desired format and write to buffer->data.
     *  @/textblock
     *  </pre>
     * <p>
     * <p>
     * The entire image is converted. If you want to convert less, you can do so using vImageConvert_AnyToAny and a converter prepared with
     * vImageConverter_CreateForCVToCGImageFormat.
     *
     * @param buffer          A pointer to a vImage_Buffer structure to be initialized. The height and width fields will be overwritten
     *                        with the size of the CVPixelBuffer. Please see the kvImageDoNotAllocate flag description below for
     *                        options about how the buffer->data and buffer->rowBytes field is handled.
     * @param desiredFormat   image format for the vImage_Buffer.
     * @param cvPixelBuffer   A CVPixelBufferRef for the image. It is not necessary to lock the CVPixelBuffer before calling this function.
     * @param cvImageFormat   An optional vImageCVImageFormatRef to specify the pixel format of the CVPixelBuffer.
     *                        <p>
     *                        If NULL, vImage attempts to discover this information automatically from the CVPixelBuffer. However, sometimes
     *                        necessary color information in the CVPixelBuffer is missing, preventing conversion.  An error will be returned.
     *                        See kvImageCVImageFormat return codes for this function for more information. To supply vImage with complete
     *                        color information, provide a complete vImageCVImageFormatRef here.
     *                        <p>
     *                        If not NULL, the cvImageFormat is used instead of looking to the CVPixelBufferRef for color information. If the
     *                        cvImageFormat is also incomplete, a kvImageCVImageFormat_ error code will be returned.
     * @param backgroundColor In cases where the vImage_Buffer format specifies opaque alpha and the cvPixelBuffer is has non-opaque alpha, the
     *                        image will be composited against a background color to remove the alpha before writing to the vImage_Buffer. The
     *                        background color is given in the colorspace of the desiredFormat.
     * @param flags           The following flags are understood by this function:
     *
     *                        <pre>
     *                                 @textblock
     *                                 kvImageDoNotAllocate        Under normal operation, new memory is allocated to hold the image pixels and its address is written
     *                                                             to buffer->data. You are responsible for freeing that data when you are done with it, using free().
     *                                                             When the kvImageDoNotAllocate flag is set, the buffer->data pointer and buffer->rowBytes is used unmodified.
     *                                                             This is intended to allow you to allocate the buffer yourself, or write directly into part of another image.
     *                                                             Use CVPixelBufferGetHeight() and CVPixelBufferGetWidth() to find the size of the result buffer.
     *
     *                                 kvImageDoNotTile            Disable internal multithreading. This may be desired if you are extracting many
     *                                                             such images in parallel, or are otherwise attempting to keep CPU utilization to
     *                                                             a single core.
     *
     *                                 kvImageHighQualityResampling    For some CVPixelBuffer formats, the chroma channels are subsampled. This flag directs
     *                                                                 vImage to spend extra time where it can to give better image quality.
     *
     *                                 kvImagePrintDiagnosticsToConsole    In case of an error, print human readable error messages to the Apple System Logger (Console).
     *                                                                     This is useful for debugging, but probably should not be on for a shipping application.
     *                                 @/textblock
     *                                 </pre>
     * @return <pre>
     *          @textblock
     *      kvImageMemoryAllocationError            buffer->data was not able to be allocated.
     *
     *      kvImageBufferSizeMismatch               buffer and cvPixelBuffer are not the same height and width
     *
     *      kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
     *
     *      kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
     *
     *      kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the CVPixelBuffer / vImageCVImageFormatRef.
     *
     *      kvImageInvalidParameter                 buffer is NULL
     *
     *      kvImageInvalidImageObject               cvPixelBuffer is NULL or can not be locked
     *
     *      kvImageInvalidImageFormat               desiredFormat is NULL or points to an illegal CG image format
     *
     *      Note: Some CVPixelBuffers have incompletely specified color information. This makes it impossible for vImage to do the conversion.
     *            When this happens, you will get one of the kvImageCVImageFormat_ errors above. To proceed, create a vImageCVImageFormatRef, add
     *            the missing information and pass as the cvImageFormat parameter. It is possible that more than one piece of information is missing.
     *            If the vImageCVImageFormatRef is missing information, then you will also get these errors.
     *          @/textblock
     *          </pre>
     * <p>
     * Returned image notes:
     * <p>
     * vImage here conforms to CoreVideo practice of substituting gamma 1/1.961 for kCVImageBufferTransferFunction_ITU_R_709_2 and
     * kCVImageBufferTransferFunction_SMPTE_240M_1995 instead of using the ITU-R BT.709-5 specified transfer function.  You may
     * manually set the transfer function using vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() and vImageCVImageFormat_SetColorSpace().
     * vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() does not make this substitution.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageBuffer_InitWithCVPixelBuffer(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer buffer,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat desiredFormat,
            CVBufferRef cvPixelBuffer, vImageCVImageFormatRef cvImageFormat, ConstNFloatPtr backgroundColor, int flags);

    /**
     * [@function] vImageBuffer_CopyToCVPixelBuffer
     * <p>
     * Copies the contents of the vImage_Buffer to a CVPixelBufferRef.
     * <p>
     * If the format of the vImage_Buffer doesn't match the CVPixelBuffer format, the image will be converted to the CVPixelBuffer
     * format as part of the copy.
     * <p>
     * The entire CVPixelBuffer is overwritten. If you want to copy less, you can do so using vImageConvert_AnyToAny and a converter prepared
     * with vImageConverter_CreateForCFToCVImageFormat.
     * <p>
     * vImage here conforms to CoreVideo practice of substituting gamma 1/1.961 for kCVImageBufferTransferFunction_ITU_R_709_2 and
     * kCVImageBufferTransferFunction_SMPTE_240M_1995 instead of using the ITU-R BT.709-5 specified transfer function.  You may
     * manually set the transfer function using vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() and vImageCVImageFormat_SetColorSpace().
     * ImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() does not make this substitution.
     *
     * @param buffer          A pointer to a vImage_Buffer containing the pixels to be copied (converted) to the CVPixelBuffer. May not be NULL.
     * @param bufferFormat    The format of buffer. May not be NULL.
     * @param cvPixelBuffer   The CVPixelBufferRef where the image will be written.  It should be a valid, preallocated CVPixelBufferRef
     *                        set to the desired image type (which need not match bufferFormat).  It is not necessary to lock the
     *                        CVPixelBuffer before calling this function. May not be NULL.
     * @param cvImageFormat   An optional vImageCVImageFormatRef to specify the pixel format of the CVPixelBuffer.
     *                        <p>
     *                        If NULL, vImage attempts to discover this information automatically. However, sometimes necessary color information
     *                        in the CVPixelBuffer is missing, preventing conversion.  An error will be returned. See kvImageCVImageFormat return
     *                        codes for this function for more information. To supply vImage with complete color information, provide a complete
     *                        vImageCVImageFormatRef here.
     *                        <p>
     *                        If not NULL, the cvImageFormat is used instead of looking to the CVPixelBufferRef for color information. If the
     *                        cvImageFormat is also incomplete, a kvImageCVImageFormat_ error code will be returned.
     *                        <p>
     *                        CAUTION: In this case, it is your responsibility to make sure that the CVPixelBuffer has the right
     *                        attachments for matrix, chroma siting and colorspace as necessary to be properly decoded.
     *                        vImage does not set these things for you.
     * @param backgroundColor If bufferFormat->bitmapInfo encodes kCGImageAlphaPremultipliedLast, kCGImageAlphaPremultipliedFirst,
     *                        kCGImageAlphaLast or kCGImageAlphaFirst -- that is, has a real alpha channel -- and the CVPixelBuffer
     *                        does not (most CV pixel formats don't) then the image will be flattened against a solid color to remove
     *                        the alpha information. You can select which color that is here. The background color is a CGFloat[3]
     *                        (red, green, blue) in the RGB colorspace of the CVPixelBuffer. (YpCbCr images reference a RGB colorspace
     *                        through a matrix like ITU-709. That is the RGB colorspace we are talking about here.)
     *                        <p>
     *                        This parameter may be NULL, indicating black.
     *                        <p>
     *                        If you want to skip flattening, you can substitute in kCGImageAlphaNoneSkipFirst/Last for the encoding of
     *                        the input buffer. This may lead to undesired results in the case of premultiplied alpha however, when alpha
     *                        is not all either 1.0 or 0. In that case, unpremultiply it first as a separate pass. Unpremultiplication may
     *                        be more costly than just flattening it, but does not introduce regions of background color into the image.
     * @param flags           The following flags are understood by this function:
     *
     *                        <pre>
     *                                 @textblock
     *                                 kvImageNoFlags                      Default operation.
     *
     *                                 kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
     *                                                                     many such operations going concurrently, and in cases where it is desirable to keep
     *                                                                     CPU utilization to a single core.
     *
     *                                 kvImageHighQualityResampling        For some CVPixelBuffer formats, the chroma channels are subsampled. This flag directs
     *                                                                     vImage to spend extra time where it can to give better image quality.
     *
     *                                 kvImagePrintDiagnosticsToConsole    In case of an error, print human readable error messages to the Apple System Logger (Console).
     *                                                                     This is useful for debugging, but probably should not be on for a shipping application.
     *                                 @/textblock
     *                                 </pre>
     * @return <pre>
     *          @textblock
     *          kvImageNoError                          Success
     *
     *          kvImageInvalidImageFormat               bufferFormat is NULL or encodes an invalid format
     *
     *          kvImageBufferSizeMismatch               buffer and cvPixelBuffer are not the same height and width
     *
     *          kvImageNullPointerArgument              buffer and cvPixelBuffer may not be NULL
     *
     *          kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
     *
     *          kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
     *
     *          kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the CVPixelBuffer / vImageCVImageFormatRef.
     *          @/textblock
     *          </pre>
     * <p>
     * Note: Some CVPixelBuffers have incompletely specified color information. This makes it impossible for vImage to do the conversion.
     * When this happens, you will get one of the kvImageCVImageFormat_ errors above. To proceed, create a vImageCVImageFormatRef, add
     * the missing information and pass as the cvImageFormat parameter. It is possible that more than one piece of information is missing.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageBuffer_CopyToCVPixelBuffer(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer buffer,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat bufferFormat,
            CVBufferRef cvPixelBuffer, vImageCVImageFormatRef cvImageFormat, ConstNFloatPtr backgroundColor, int flags);

    /**
     * [@function] vImageCVImageFormat_CreateWithCVPixelBuffer
     * <p>
     * Used to create a vImageCVImageFormatRef to describe the pixel format of an existing CVPixelBufferRef.
     * <p>
     * If the CVPixelBufferRef has incomplete pixel format information, the vImageCVImageFormatRef will also be incomplete. Not all
     * missing fields ultimately will prove to be necessary, however.  If a function that consumes a vImageCVImageFormatRef returns a
     * vImageCVImageFormatError code, please add the missing information and try again. See "vImageCVImageFormatRef Accessors" below.
     *
     * @param buffer The CBPixelBufferRef on which to base the vImageCVImageFormatRef
     * @return On success, a non-NULL vImageCVImageFormatRef is returned. The vImageCVImageFormatRef has a retain count of 1. You are responsible
     * for releasing it when you are done with it.
     */
    @Generated
    @CFunction
    public static native vImageCVImageFormatRef vImageCVImageFormat_CreateWithCVPixelBuffer(CVBufferRef buffer);

    /**
     * [@function] vImageCVImageFormat_Create
     * <p>
     * Create a vImageCVImageFormatRef (low level).
     * <p>
     * This function creates a vImageCVImageFormatRef from first principles. In most cases, vImageCVImageFormat_CreateWithCVPixelBuffer
     * is easier, but if your video pipeline doesn't use CoreVideo, or you need absolute control then this is your alternative.
     * <p>
     * Other fields not given by function parameters like number of channels, channel names, and channel description are automatically
     * configured using the imageFormatType. User data is set separately with vImageCVImageFormat_SetUserData.
     *
     * @param imageFormatType             A CVPixelFormatType such as '2vuy'. See CVPixelBuffer.h for the complete list.
     * @param matrix                      A vImage_ARGBToYpCbCrMatrix showing how to convert from RGB to the YpCbCr format. This may be NULL. However, it
     *                                    is required for conversions involving YpCbCr images, so for YpCbCr images you will be eventually forced to set the matrix
     *                                    using vImageCVImageFormat_CopyConversionMatrix before you can make a vImageConverterRef with this object.
     *                                    There are some predefined conversion matrices in Conversion.h for Rec 601 and 709 formats.
     * @param cvImageBufferChromaLocation See kCVImageBufferChromaLocationTopFieldKey in CVImageBuffer.h for a list of chroma locations.
     *                                    kCVImageBufferChromaLocation_Center is typical.  This may be NULL. However, for YpCbCr formats with downsampled
     *                                    chroma, you will be ultimately forced to set a chroma location using vImageCVImageFormat_SetChromaSiting, before
     *                                    a vImageConverterRef can be made with this object.
     * @param baseColorspace              For RGB and monochrome images, this is the colorspace of the image.
     *                                    <p>
     *                                    For YpCbCr images, this is the colorspace of the RGB image before it was converted to YpCbCr using the ARGB-to-YpCbCr
     *                                    conversion matrix (see matrix parameter above). The colorspace is defined based on the YpCbCr format RGB primaries
     *                                    and transfer function.
     *                                    <p>
     *                                    This may be NULL. However, you will eventually be forced to set set a colorspace for all image types, before
     *                                    a vImageConvertRef can be made with this object.
     * @param alphaIsOneHint              Typically this is 0. If your image format has an alpha channel, but you know the image is fully opaque,
     *                                    or want it to be treated as opaque, you can set this to 1. This may allow for faster conversions to
     *                                    opaque formats.
     * @return On success, a non-NULL vImageCVImageFormatRef will be returned, which encodes the information contained in the above parameters. The
     * vImageCVImageFormatRef has a retain count of 1.  You must release it when you are done with it.
     * <p>
     * On failure, NULL is returned.
     */
    @Generated
    @CFunction
    public static native vImageCVImageFormatRef vImageCVImageFormat_Create(int imageFormatType,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_ARGBToYpCbCrMatrix matrix,
            CFStringRef cvImageBufferChromaLocation, CGColorSpaceRef baseColorspace, int alphaIsOneHint);

    /**
     * [@function] vImageCVImageFormat_Copy
     * <p>
     * Makes a copy of a vImageCVImageFormatRef.
     * <p>
     * The new vImageCVFormatRef is different from the old one in that:
     * <p>
     * o       Its reference count is 1
     * <p>
     * o       The userData field and destructor callback are not copied, and are initialized to NULL.
     * <p>
     * Usually, it is preferable to simply retain a vImageCVImageFormatRef rather than copy it. You may wish to copy a vImageCVImageFormatRef if
     * you want to modify an existing vImageCVImageFormatRef but can't because it is being read by another thread, or to replace another software layer's
     * userData pointer with your own.  By convention, the new vImageCVImageFormatRef is considered to have been created by the software layer that called
     * vImageCVImageFormat_Copy.
     *
     * @param format The vImageCVImageFormatRef to copy.
     * @return On success, a non-NULL vImageCVImageFormatRef is returned. Its reference count is 1. You are responsible for releasing it when you are done with it.
     * On failure, this function returns NULL.
     */
    @Generated
    @CFunction
    public static native vImageCVImageFormatRef vImageCVImageFormat_Copy(vImageConstCVImageFormatRef format);

    /**
     * [@function] vImageCVImageFormat_Retain
     * <p>
     * Retains a vImageCVImageFormatRef
     * <p>
     * The vImageCVImageFormatRef follows standard retain/release semantics.
     * <p>
     * vImageCVImageFormat_Retain causes the object's reference count to be incremented.
     * <p>
     * vImageCVImageFormat_Release causes the object's reference count to be decremented. When the reference count reaches 0,
     * the userDataReleaseCallback (if any) is called, and the object is then destroyed. The userDataReleaseCallback can access
     * the vImageCVImageFormatRef, but can not prevent vImageCVImageFormatRef destruction. For this reason, the
     * userDataReleaseCallback should be careful who it hands off control to in case that software layer
     * attempts to retain the vImageCVImageFormatRef. This will result in undefined behavior.
     *
     * @param fmt The vImageCVImageFormatRef to retain
     *            <p>
     *            fmt may be NULL, in which case nothing occurs.
     */
    @Generated
    @CFunction
    public static native void vImageCVImageFormat_Retain(vImageCVImageFormatRef fmt);

    /**
     * [@function] vImageCVImageFormat_Release
     * <p>
     * Releases a vImageCVImageFormatRef
     * <p>
     * The vImageCVImageFormatRef follows standard retain/release semantics.
     * <p>
     * vImageCVImageFormat_Retain causes the object's reference count to be incremented.
     * <p>
     * vImageCVImageFormat_Release causes the object's reference count to be decremented. When the reference count reaches 0,
     * the userDataReleaseCallback (if any) is called, and the object is then destroyed. The userDataReleaseCallback can access
     * the vImageCVImageFormatRef, but can not prevent vImageCVImageFormatRef destruction. For this reason, the
     * userDataReleaseCallback should be careful who it hands off control to in case that software layer
     * attempts to retain the vImageCVImageFormatRef. This will result in undefined behavior.
     *
     * @param fmt The vImageCVImageFormatRef to release
     *            <p>
     *            fmt may be NULL, in which case nothing occurs.
     */
    @Generated
    @CFunction
    public static native void vImageCVImageFormat_Release(vImageCVImageFormatRef fmt);

    /**
     * [@function] vImageCVImageFormat_GetFormatCode
     * <p>
     * Return the kCVPixelFormatType_ (4 character code) that encodes the pixel format.
     * <p>
     * The kCVPixelFormatType_ of a CoreVideo pixel buffer is given by a four character code (4CC), such as '2vuy'. It describes the number of channels,
     * channel packing order, bits per component (except in one case), and usually range information like whether it is full range or
     * video range.
     *
     * @param format The vImageCVImageFormatRef for which the 4 character code is desired.
     * @return A 4CC in host-endian format.
     * @see //apple_ref/doc/constant_group/Pixel_Format_Types CoreVideo/CVPixelBuffer.h
     */
    @Generated
    @CFunction
    public static native int vImageCVImageFormat_GetFormatCode(vImageConstCVImageFormatRef format);

    /**
     * [@function] vImageCVImageFormat_GetChannelCount
     * <p>
     * Return the the number of color channels in the image, including alpha.
     * <p>
     * The channels may be interleaved or planar. For RGBA, the result is 4. For 'yuvs' this is 3. This does not return
     * the same results as vImageConverter_GetNumberOfSourceBuffers / vImageConverter_GetNumberOfSourceBuffers, which
     * instead describe the number of vImage_Buffers to pass to vImageConvert_AnyToAny. Some vImage_Buffers contain
     * multiple channels.
     *
     * @param format The vImageCVImageFormatRef for which the number of channels is desired.
     * @return A uint32_t containing the number of channels
     */
    @Generated
    @CFunction
    public static native int vImageCVImageFormat_GetChannelCount(vImageConstCVImageFormatRef format);

    /**
     * [@function] vImageCVImageFormat_GetChannelNames
     * <p>
     * Get a const kvImageBufferTypeCode_EndOfList-terminated array indicating the names of the channels in the buffer.
     * <p>
     * The array is owned by the vImageCvImageFormatRef and will cease to be valid when the object is destroyed.
     * This function is not useful to discover the correct vImage_Buffer order for a call to vImageConvert_AnyToAny().
     *
     * @param format The vImageCVImageFormatRef for which the channel names are desired.
     * @return A const pointer to an array of vImageBufferTypeCodes indicating the names of the channels in the image.
     * @see vImageConverter_GetSourceBufferOrder
     * @see vImageConverter_GetDestinationBufferOrder
     */
    @Generated
    @CFunction
    public static native ConstIntPtr vImageCVImageFormat_GetChannelNames(vImageConstCVImageFormatRef format);

    /**
     * [@function] vImageCVImageFormat_GetColorSpace
     * <p>
     * Get the colorspace associated with the image.
     * <p>
     * If the image format is a Y'CbCr image format, this is the RGB colorspace of the image after the inverse
     * RGB->YpCbCr conversion matrix is applied. Otherwise, it is the colorspace of the pixels in the image.
     *
     * @param format The vImageCVImageFormatRef for which the colorspace is desired.
     * @return The colorspace (if any) that is returned is referenced by the vImageCVImageFormatRef and will be released
     * when that object is destroyed. This function may return NULL, indicating an absence of colorspace information.
     */
    @Generated
    @CFunction
    public static native CGColorSpaceRef vImageCVImageFormat_GetColorSpace(vImageConstCVImageFormatRef format);

    /**
     * [@function] vImageCVImageFormat_SetColorSpace
     * <p>
     * Set the colorspace associated with the image.
     * <p>
     * If the image format is a Y'CbCr image format, this sets the RGB colorspace of the image before the
     * RGB->YpCbCr conversion matrix was applied. Otherwise, it is the colorspace of the pixels in the image.
     * A non-NULL colorspace must be present before a vImageCVImageFormatRef can be used to do a conversion.
     *
     * @param format     The vImageCVImageFormatRef for which the colorspace is to be set.
     * @param colorspace The new colorspace.  May be NULL, indicating missing colorspace information.
     * @return On Success, kvImageNoError. An error will be returned if the colorspace model doesn't match what is expected
     * for the image format type. For example, a 'RGBA' image must be kCGColorSpaceModelRGB.  Y'CbCr images expect a
     * RGB colorspace. The new colorspace will be retained and he old one will be released.
     * <p>
     * On failure, nothing occurs.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageCVImageFormat_SetColorSpace(vImageCVImageFormatRef format,
            CGColorSpaceRef colorspace);

    /**
     * [@function] vImageCVImageFormat_GetChromaSiting
     * <p>
     * Get the chroma-siting for the image.
     * <p>
     * When Y'CbCr images have subsampled chroma, the position of the chroma samples relative to the luminance samples needs to be
     * specified. Chroma siting information is only needed for Y'CbCr images that are not 444.
     *
     * @param format The vImageCVImageFormatRef for which the chroma siting information is desired.
     * @return Returns a CFStringRef that describes the positioning of the chroma samples. Eligible string return values are listed
     * in CoreVideo/CVImageBuffer.h.   The result is NULL if the chroma siting information is missing.
     * @see //apple_ref/c/data/kCVImageBufferChromaLocationTopFieldKey kCVImageBufferChromaLocationTopFieldKey
     */
    @Generated
    @CFunction
    public static native CFStringRef vImageCVImageFormat_GetChromaSiting(vImageConstCVImageFormatRef format);

    /**
     * [@function] vImageCVImageFormat_SetChromaSiting
     * <p>
     * Set the chroma-siting for the image.
     * <p>
     * When Y'CbCr images have subsampled chroma, the position of the chroma samples relative to the luminance samples needs to be
     * specified. Chroma siting information is only needed for Y'CbCr images that are not 444. The new siting name will be retained.
     * The old siting will be released. This function has no effect for image format types that do not require siting information.
     *
     * @param format The vImageCVImageFormatRef for which the chroma siting information is desired.
     * @param siting The new siting information for the format. May be NULL.
     * @return <pre>
     *     @textblock
     *         kvImageNoError                  Success
     *
     *         kvImageInvalidImageFormat       format is NULL
     *
     *         kvImageInvalidParameter         siting is not a recognized CFStringRef from the set of values appearing in CoreVideo/CVImageBuffer.h.
     *     @/textblock
     *     </pre>
     * @see //apple_ref/c/data/kCVImageBufferChromaLocationTopFieldKey kCVImageBufferChromaLocationTopFieldKey
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageCVImageFormat_SetChromaSiting(vImageCVImageFormatRef format, CFStringRef siting);

    /**
     * [@function] vImageCVImageFormat_GetConversionMatrix
     * <p>
     * Get the RGB -> Y'CbCr conversion matrix for the image.
     * <p>
     * Y'CbCr images are defined in terms of a RGB image and a conversion matrix from that RGB format to Y'CbCr.
     * The conversion frequently has the form:
     *
     * <pre>
     *         @textblock
     *             Y' =  R_Yp * R  + G_Yp * G + B_Yp * B       Y' = [0, 1.0]
     *             Cb = k0 * (B - Y')                          Cb = [-0.5, 0.5]
     *             Cr = k1 * (R - Y')                          Cr = [-0.5, 0.5]
     *         @/textblock
     *         </pre>
     * <p>
     * That can be reformulated as a 3x3 matrix operation. The element names here correspond to the fields in the vImage_ARGBToYpCbCrMatrix type:
     *
     * <pre>
     *         @textblock
     *             | Y' |   | R_Yp        G_Yp     B_Yp      |   | R |
     *             | Cb | = | R_Cb        G_Cb     B_Cb_R_Cr | * | G |
     *             | Cr |   | B_Cb_R_Cr   G_Cr     B_Cr      |   | B |
     *         @/textblock
     *         </pre>
     * <p>
     * Most Y'CbCr conversion matrices are of this form. However, some conversion matrices, such as that proposed to ITU-R BT.2020 for
     * constant luminance, are more complicated.
     * <p>
     * It is possible for the matrix to be absent. Y'CbCr image types may not be converted without a conversion matrix.
     *
     * @param format  The vImageCVImageFormatRef for which the matrix is desired
     * @param outType A pointer to a variable of type vImageMatrixType.
     * @return A pointer to a matrix will be returned from the left hand side of the function. The memory pointed to by outType will be
     * overwritten with the type of the matrix returned.  The returned matrix may be NULL, indicating an absent matrix.
     * <p>
     * The matrix is owned by the vImageCvImageFormatRef and will cease to be valid when the vImageCvImageFormatRef is destroyed.
     * @see vImage_ARGBToYpCbCrMatrix
     * @see vImageMatrixType
     */
    @Generated
    @CFunction
    public static native ConstVoidPtr vImageCVImageFormat_GetConversionMatrix(vImageConstCVImageFormatRef format,
            IntPtr outType);

    /**
     * [@function] vImageCVImageFormat_CopyConversionMatrix
     * <p>
     * Set the RGB -> Y'CbCr conversion matrix for the image.
     * <p>
     * matrix is copied to the vImageCVImageFormatRef's internal matrix storage.
     * <p>
     * Y'CbCr images are defined in terms of a RGB image and a conversion matrix from that RGB format to Y'CbCr.
     * The conversion frequently has the form:
     *
     * <pre>
     *         @textblock
     *             Y' =  R_Yp * R  + G_Yp * G + B_Yp * B       Y' = [0, 1.0]
     *             Cb = k0 * (B - Y')                          Cb = [-0.5, 0.5]
     *             Cr = k1 * (R - Y')                          Cr = [-0.5, 0.5]
     *         @/textblock
     *         </pre>
     * <p>
     * That can be reformulated as a 3x3 matrix operation. The element names here correspond to the fields in the vImage_ARGBToYpCbCrMatrix type:
     *
     * <pre>
     *         @textblock
     *             | Y' |   | R_Yp        G_Yp     B_Yp      |   | R |
     *             | Cb | = | R_Cb        G_Cb     B_Cb_R_Cr | * | G |
     *             | Cr |   | B_Cb_R_Cr   G_Cr     B_Cr      |   | B |
     *         @/textblock
     *         </pre>
     * <p>
     * Most Y'CbCr conversion matrices are of this form. However, some conversion matrices, such as that proposed to ITU-R BT.2020 for
     * constant luminance, are more complicated.
     * <p>
     * It is possible for the matrix to be absent. Y'CbCr image types may not be converted without a conversion matrix.
     *
     * @param format The vImageCVImageFormatRef for which the matrix is desired
     * @param matrix The matrix data to be copied to the vImageCVImageFormatRef. If the matrix is a constant predefined by vImage,
     *               the address shall be preserved, and returned unmodified by vImageCVImageFormat_GetConversionMatrix.
     *               The matrix must have a matrix inverse.
     * @param inType The type of the matrix. The only type defined for OS X.10 and iOS 8.0 is kvImageMatrixType_ARGBToYpCbCrMatrix, which is a vImage_ARGBToYpCbCrMatrix.
     * @return <pre>
     *         @textblock
     *          kvImageNoError             Success.
     *
     *          kvImageInvalidParameter    The matrix type did not match that required for the image format.
     *
     *          kvImageInvalidParameter    The matrix is not invertible. (See console for log in this case.)
     *         @/textblock
     *         </pre>
     * @see vImage_ARGBToYpCbCrMatrix
     * @see vImageMatrixType
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageCVImageFormat_CopyConversionMatrix(vImageCVImageFormatRef format,
            ConstVoidPtr matrix, int inType);

    /**
     * [@function] vImageCVImageFormat_GetAlphaHint
     * <p>
     * Get the alpha-is-one hint from a vImageCVImageFormatRef
     * <p>
     * Some image formats have an alpha channel. Sometimes, the alpha channel for the entire image is known to be 1.0 (fully opaque).
     * In some circumstances, that knowledge can be used to eliminate work from a conversion to make it faster, especially when converting
     * to a format without an alpha channel.  If the alpha-is-one hint is non-zero, it indicates that the alpha channel is fully opaque.
     * <p>
     * Images that do not have an alpha channel will also return non-zero.
     * <p>
     * There are a few image formats that have room for an alpha channel (kCVPixelFormatType_16BE555, kCVPixelFormatType_16LE555,
     * kCVPixelFormatType_30RGB) but which do not have an alpha channel. Setting the alpha-is-one hint to 0 does not add an alpha
     * channel to these image types.
     * <p>
     * The alpha-is-one hint is a hint.  It can not be absent in a way that will prevent conversion. If it is not set or is zero, and
     * the image format has alpha, then the alpha channel will be included in the calculation. If the result format has alpha, the alpha
     * will propagate there. If the result format does not have alpha, the image will be flattened against the indicated background color
     * for the conversion.
     *
     * @param format The vImageCVImageFormatRef for which the colorspace is to be set.
     * @return 0  Alpha is not known to be opaque, or the hint has not been set.
     * <p>
     * non-zero  Alpha is known to be fully opaque, even if the values encoded for alpha in the image are not 1.0.
     */
    @Generated
    @CFunction
    public static native int vImageCVImageFormat_GetAlphaHint(vImageConstCVImageFormatRef format);

    /**
     * [@function] vImageCVImageFormat_SetAlphaHint
     * <p>
     * Set the alpha-is-one hint for a vImageCVImageFormatRef
     * <p>
     * Some image formats have an alpha channel. Sometimes, the alpha channel for the entire image is known to be 1.0 (fully opaque).
     * In some circumstances, that knowledge can be used to eliminate work from a conversion to make it faster, especially when converting
     * to a format without an alpha channel.  If the alpha-is-one hint is non-zero, it indicates that the alpha channel is fully opaque.
     * <p>
     * The alpha-is-one hint is a hint.  It can not be absent in a way that will prevent conversion. If it is not set or is zero, and
     * the image format has alpha, then the alpha channel will be included in the calculation. If the result format has alpha, the alpha
     * will propagate there. If the result format does not have alpha, the image will be flattened against the indicated background color
     * for the conversion.
     * <p>
     * There are a few image formats that have room for a small alpha channel (kCVPixelFormatType_16BE555, kCVPixelFormatType_16LE555,
     * kCVPixelFormatType_30RGB) but which do not have an alpha channel. Setting the alpha-is-one hint to 0 does not add an alpha
     * channel to these image types.  If this behavior is desired, such image formats can generally be described using a vImage_CGImageFormat.
     * If so, you can set the vImage_CGImageFormat.bitmap info to an appropriate CGImageAlphaInfo for the desired treatment for the alpha
     * channel and convert using vImageConverter_CreateWithCGImageFormat() + vImageConvert_AnyToAny().
     * <p>
     * [@parma] alphaIsOne   The new value for the alpha-is-one hint.
     *
     * @param format The vImageCVImageFormatRef for which the colorspace is to be set.
     * @return kvImageNoError             Success.
     * <p>
     * kvImageInvalidParameter    format is NULL
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageCVImageFormat_SetAlphaHint(vImageCVImageFormatRef format, int alphaIsOne);

    /**
     * [@function] vImageCVImageFormat_GetChannelDescription
     * <p>
     * Get the channel description for a particular channel type
     * <p>
     * The channel description gives information about the range of values and clamping for a image color channel.
     * <p>
     * [@parma] type         The type of the channel that you wish information about. Example: kvImageBufferTypeCode_Luminance
     *
     * @param format The vImageCVImageFormatRef that the channel description is for.
     * @return A const pointer to a vImageChannelDescription struct. The data in the structure may not be modified and belongs to the vImageCVImageFormatRef.
     * It is destroyed when the vImageCVImageFormatRef is destroyed.
     * @see vImageChannelDescription
     */
    @Generated
    @CFunction
    @UncertainReturn("Options: reference, array Fallback: reference")
    public static native vImageChannelDescription vImageCVImageFormat_GetChannelDescription(
            vImageConstCVImageFormatRef format, int type);

    /**
     * [@function] vImageCVImageFormat_CopyChannelDescription
     * <p>
     * Set the channel description for a particular channel type
     * <p>
     * The channel description gives information about the range of values and clamping for a image color channel.
     *
     * @param format The vImageCVImageFormatRef that the channel description is for.
     * @param desc   A pointer to a new vImageChannelDescription to use for the channel type.  The data is copied into the vImageCVImageFormatRef.
     * @param type   The type of the channel that you wish to set information about. Example: kvImageBufferTypeCode_Luminance
     * @return kvImageNoError     Success
     * <p>
     * kvImageInvalidParameter    An invalid vImageBufferTypeCode, either out of range, or the channel type does not appear in the image format
     * @see vImageChannelDescription
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageCVImageFormat_CopyChannelDescription(vImageCVImageFormatRef format,
            @UncertainArgument("Options: reference, array Fallback: reference") vImageChannelDescription desc,
            int type);

    /**
     * [@function] vImageCVImageFormat_GetUserData
     * <p>
     * Get the user info pointer attached to the image format
     * <p>
     * There may be extra information that you wish to attach to a vImageCVImageFormatRef.  It might be a pthread_rwlock_t to help prevent
     * concurrent access to the vImageCVImageFormatRef while it is being modified, or perhaps additional metadata about the image format
     * that you may need later. It may even just a pointer to an object you wrote which wraps the vImageCVImageFormatRef.
     * <p>
     * The user data pointer is available for you to use to store a reference to this information. The token is opaque to vImage. vImage
     * only returns it when asked via vImageCVImageFormat_GetUserData.  It can be set with vImageCVImageFormat_SetUserData.
     *
     * @param format The vImageCVImageFormatRef to get the userData from.
     * @return The address of the userData. It will be NULL if no userData has been set.
     * @see vImageCVImageFormat_SetUserData
     */
    @Generated
    @CFunction
    public static native VoidPtr vImageCVImageFormat_GetUserData(vImageConstCVImageFormatRef format);

    /**
     * [@function] vImageCVImageFormat_SetUserData
     * <p>
     * Sets the userData pointer and a userDataReleaseCallback function
     * <p>
     * The userDataReleaseCallback is called when the vImageCVImageFormatRef is destroyed. You may access the vImageCVImageFormatRef
     * during the callback function. However vImageCVImageFormat_Retain() will not prevent the destruction of the object in that context.
     * The userDataReleaseCallback will also be called on the previous user data in the event that vImageCVImageFormat_SetUserData
     * is called to replace one set of user date with another.
     * <p>
     * CAUTION: vImage does not attempt to do anything smart when the old and new userData are actually the same or differ only by callback.
     * <p>
     * vImage does not attempt to free the user data when the vImageCVImageFormatRef is destroyed. If the userData needs to
     * be freed/released/etc. at this time, then you should do so in your userDataReleaseCallback.
     * <p>
     * vImageCVImageFormat_SetUserData function is not atomic. vImageCVImageFormat_SetUserData is not safe to call reentrantly.
     * <p>
     * Since there can be only one userData attached to a vImageCVImageFormatRef, the userData field is reserved by convention
     * for exclusive use by the app/framework/library that created the vImageCVImageFormatRef.  If you need to attach your own
     * userData to a vImageCVImageFormatRef that you did not create, make a copy of it with vImageCVImageFormat_Copy.  The new
     * copy will not have userData attached to it.
     *
     * @param format                  The vImageCVImageFormatRef to get the userData from.
     * @param userData                The new userData pointer.
     * @param userDataReleaseCallback The callback that is called when the vImageCVImageFormatRef is destroyed, or
     *                                when the userData is replaced with another one.
     * @param callback_fmt            The vImageCVImageFormatRef that the userData is attached to.
     * @param callback_userData       The userData field attached to callback_fmt.
     * @return kvImageNoError - Success
     * @return kvImageInvalidImageFormat  - Format is NULL
     * @see vImageCVImageFormat_SetUserData
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageCVImageFormat_SetUserData(vImageCVImageFormatRef format, VoidPtr userData,
            @FunctionPtr(name = "call_vImageCVImageFormat_SetUserData") Function_vImageCVImageFormat_SetUserData userDataReleaseCallback);

    /**
     * [@function] vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction
     * <p>
     * Create a RGB colorspace based on primitives typically found in Y'CbCr specifications
     * <p>
     * This function may be used to create a CGColorSpaceRef to correspond with a given set of color
     * primaries and transfer function. This defines a RGB colorspace. (A Y'CbCr colorspace is defined as a RGB
     * colorspace and a conversion matrix from RGB to Y'CbCr.) The color primaries give the extent of a colorspace
     * in x,y,z space and the transfer function gives the transformation from linear color to non-linear color that
     * the pixels actually reside in.
     *
     * <pre>
     *   @textblock
     *      Example:  ITU-R BT.709-5
     *
     *          const vImageTransferFunction f709 =
     *          {  // 1.2 transfer function
     *              .c0 = 1.099,
     *              .c1 = 1.0,
     *              .c2 = 0.0,
     *              .c3 = -0.099,
     *              .gamma = 0.45,
     *              .cutoff = 0.018,
     *              .c4 = 4.5,
     *              .c5 = 0
     *          };
     *
     *          const vImageRGBPrimaries p709 =
     *          {
     *              .red_x = .64,               // 1.3 red
     *              .green_x = .30,             // 1.3 green
     *              .blue_x = .15,              // 1.3 blue
     *              .white_x = 0.3127,          // 1.4 white
     *
     *              .red_y = .33,               // 1.3 red
     *              .green_y = .60,             // 1.3 green
     *              .blue_y = .06,              // 1.3 blue
     *              .white_y = 0.3290           // 1.4 white
     *          };
     *
     *          vImage_Error err = kvImageNoError;
     *          CGColorSpaceRef colorSpace = vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction( &p709, &f709, kvImageNoFlags, &err );
     *          @/textblock
     *          </pre>
     * <p>
     * Other methods to create a RGB colorspace:
     * <p>
     * You may find it easier to use CVImageBufferCreateColorSpaceFromAttachments or CVImageBufferGetColorSpace, in some cases.
     * If there is enough color information attached to a CVPixelBuffer, you can also get one using vImageCVImageFormat_CreateWithCVPixelBuffer().
     * There are also many ways to create a RGB CGColorSpace in CoreGraphics/CGColorSpace.h.
     *
     * <pre>
     *   @textblock
     *      Note: This low level function does not conform to CoreVideo practice of automatically substituting gamma 1/1.961
     *      for kCVImageBufferTransferFunction_ITU_R_709_2 and kCVImageBufferTransferFunction_SMPTE_240M_1995 instead of using
     *      the ITU-R BT.709-5 specified transfer function. (vImageBuffer_InitWithCVPixelBuffer and vImageBuffer_CopyToCVPixelBuffer
     *      do.) If you would like that behavior, you can use the following transfer function:
     *
     *      const vImageTransferFunction f709_Apple =
     *      {
     *          .c0 = 1.0,
     *          .c1 = 1.0,
     *          .c2 = 0.0,
     *          .c3 = 0,
     *          .gamma = 1.0/1.961,
     *          .cutoff = -INFINITY,
     *          .c4 = 1,
     *          .c5 = 0
     *      };
     *    @/textblock
     *    </pre>
     *
     * @param primaries A set of x, y tristimulus values to defined the color primaries for the RGB colorspace. Here:
     *
     *                  <pre>
     *                           @textblock
     *                                           x = X/(X+Y+Z),  y = Y/(X+Y+Z)
     *                           @/textblock
     *                           </pre>
     *                  <p>
     *                  where X, Y, and Z are from CIEXYZ. z is derived automatically from x and y.
     * @param tf        The transfer function to convert from linear RGB (using above primaries) to non-linear RGB.
     *                  The transfer function here is defined in the style of ITU-R BT.709 and is the inverse
     *                  operation of what appears in a ICC color profile.
     * @param flags     Currently the only flag recognized here is  kvImagePrintDiagnosticsToConsole, which may be used to
     *                  debug the colorspace creation when it fails.
     * @param error     May be NULL. If not NULL, a vImage_Error code is written to the memory pointed to by error to
     *                  indicate success or failure of the operation.
     * @return On success, a non-NULL RGB CGColorSpaceRef will be returned.  The color space has a reference count of 1.
     * You are responsible for releasing the colorspace when you are done with it to return the memory back
     * to the system. If error is not NULL, kvImageNoError is written to *error.
     * <p>
     * On failure, NULL will be returned and one of the following errors is written to *error if error is non-NULL:
     *
     * <pre>
     *          @textblock
     *          Errors:
     *
     *              kvImageInvalidParameter         tf->gamma = 0       (transfer function is not round-trippable)
     *              kvImageInvalidParameter         primaries define XYZ <-> RGB matrix which is not invertible
     *          @/textblock
     *          </pre>
     */
    @Generated
    @CFunction
    public static native CGColorSpaceRef vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction(
            @UncertainArgument("Options: reference, array Fallback: reference") vImageRGBPrimaries primaries,
            @UncertainArgument("Options: reference, array Fallback: reference") vImageTransferFunction tf, int intent,
            int flags, NIntPtr error);

    @Generated
    @CFunction
    public static native CGColorSpaceRef vImageCreateMonochromeColorSpaceWithWhitePointAndTransferFunction(
            @UncertainArgument("Options: reference, array Fallback: reference") vImageWhitePoint whitePoint,
            @UncertainArgument("Options: reference, array Fallback: reference") vImageTransferFunction tf, int intent,
            int flags, NIntPtr error);

    /**
     * [@function] vImageConverter_CreateForCGToCVImageFormat
     * <p>
     * Create a vImageConverterRef that converts a CoreGraphics formatted image to CoreVideo formatted image
     * <p>
     * This creates a vImageConverterRef which may be used with vImageConvert_AnyToAny to convert a
     * CoreGraphics formatted image, as described by a vImage_CGImageFormat to CV image data, the format of
     * which is given by a vImageCVImageFormatRef.
     *
     * @param srcFormat       The vImage_CGImageFormat that describes the pixel format associated with the source image buffers.
     * @param destFormat      The vImageCVImageFormatRef that describes the pixel format associated with the destination buffers.
     * @param backgroundColor In cases where the source format has an alpha channel and the destination does not (or is kCGImageAlphaNoneSkipFirst/Last)
     *                        the conversion will remove the alpha channel by flattening it against an opaque background color. The background color
     *                        is given as CGFloat[3] {red, green, blue} (sRGB).
     * @param flags           The following flags are honored:
     *
     *                        <pre>
     *                                @textblock
     *                                    kvImagePrintDiagnosticsToConsole    cause extra information to be sent to Apple System Logger (Console) in case of failure
     *
     *                                    kvImageHighQualityResampling        In some cases, chroma may have to be up or downsampled as part of the conversion
     *                                                                        When this flag bit is set, it instructs the converter to spend extra time to achieve better
     *                                                                        image quality.
     *
     *                                    kvImageDoNotTile                    Disable multithreading in the conversion step when this converter is used with vImageConvert_AnyToAny.
     *                                @/textblock
     *                                </pre>
     * @param error           An optional pointer to a vImage_Error in which the returned error code is written.
     *                        Error be NULL, in which case no error value will be written.
     * @return On success, a non-NULL vImageConverteRef will be returned, suitable for use with vImageConvert_AnyToAny(). If
     * error is non-NULL, kvImageNoError will be written to *error, indicating success. You must release the
     * vImageConverterRef when you are done with it, to return its resources to the system.  It has a reference count of 1.
     * <p>
     * On failure, a NULL vImageConverteRef will be returned. If error is non-NULL, an error code will be written to
     * *error.  Some possible error values:
     *
     * <pre>
     *         @textblock
     *         kvImageNoError                      Success. No error occurred. A non-NULL vImageConverterRef will be returned.
     *
     *         kvImageInternalError                Your usage was likely correct, but something appears to be very wrong inside
     *                                             vImage. Please file a bug, with a reproducible example of this failure. Please
     *                                             also try the kvImagePrintDiagnosticsToConsole flag for more information.
     *
     *         kvImageInvalidImageFormat           The vImage_CGImageFormat is invalid. kvImagePrintDiagnosticsToConsole may provide
     *                                             more information.
     *
     *         kvImageInvalidCVImageFormat         The vImageCVImageFormatRef is invalid. Probably, the vImageCVImageFormatRef is
     *                                             incomplete. This can happen when a vImageCVImageFormatRef is created from a
     *                                             CVPixelBufferRef and that itself has incomplete conversion information. Please
     *                                             see "vImageCVImageFormatRef Repair" above. kvImagePrintDiagnosticsToConsole
     *                                             may provide more information.
     *
     *         kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the vImageCVImageFormatRef. Please add one.
     *         kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the vImageCVImageFormatRef. Please add.
     *         kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the vImageCVImageFormatRef.
     *         @/textblock
     *         </pre>
     * @see vImageBuffer_InitForCopyToCVPixelBuffer When converting from CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains multiple data planes which are in turn represented by multiple vImage_Buffers.
     * @see vImageConverter_GetDestinationBufferOrder for manual ordering information
     */
    @Generated
    @CFunction
    public static native vImageConverterRef vImageConverter_CreateForCGToCVImageFormat(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat srcFormat,
            vImageCVImageFormatRef destFormat, ConstNFloatPtr backgroundColor, int flags, NIntPtr error);

    /**
     * [@function] vImageConverter_CreateForCVToCGImageFormat
     * <p>
     * Create a vImageConverterRef that converts a CoreVideo formatted image to a CoreGraphics formatted image
     * <p>
     * This creates a vImageConverterRef which may be used with vImageConvert_AnyToAny to do conversions of
     * CV image data, as described by a vImageCVImageFormatRef to CoreGraphics formatted image data, as
     * described by a vImage_CGImageFormat.
     *
     * @param srcFormat       The vImageCVImageFormatRef that describes the pixel format associated with the source image buffers.
     * @param destFormat      The vImage_CGImageFormat that describes the pixel format associated with the destination buffers.
     * @param backgroundColor In cases where the source format has an alpha channel and the destination does not (or is kCGImageAlphaNoneSkipFirst/Last)
     *                        the conversion will remove the alpha channel by flattening it against an opaque background color. The background color
     *                        is given as CGFloat[3] {red, green, blue} (sRGB).
     * @param flags           The following flags are honored:
     *
     *                        <pre>
     *                                @textblock
     *                                    kvImagePrintDiagnosticsToConsole    cause extra information to be sent to Apple System Logger (Console) in case of failure
     *
     *                                    kvImageHighQualityResampling        In some cases, chroma may have to be up or downsampled as part of the conversion
     *                                                                        When this flag bit is set, it instructs the converter to spend extra time to achieve better
     *                                                                        image quality.
     *
     *                                    kvImageDoNotTile                    Disable multithreading in the conversion step when this converter is used with vImageConvert_AnyToAny.
     *                                @/textblock
     *                                </pre>
     * @param error           An optional pointer to a vImage_Error in which the returned error code is written.
     *                        Error be NULL, in which case no error value will be written.
     * @return On success, a non-NULL vImageConverteRef will be returned, suitable for use with vImageConvert_AnyToAny(). If
     * error is non-NULL, kvImageNoError will be written to *error, indicating success. You must release the
     * vImageConverterRef when you are done with it, to return its resources to the system.  It has a reference count of 1.
     * <p>
     * On failure, a NULL vImageConverteRef will be returned. If error is non-NULL, an error code will be written to
     * *error.  Some possible error values:
     *
     * <pre>
     *         @textblock
     *         kvImageNoError                      Success. No error occurred. A non-NULL vImageConverterRef will be returned.
     *
     *         kvImageInternalError                Your usage was likely correct, but something appears to be very wrong inside
     *                                             vImage. Please file a bug, with a reproducible example of this failure. Please
     *                                             also try the kvImagePrintDiagnosticsToConsole flag for more information.
     *
     *         kvImageInvalidImageFormat           The vImage_CGImageFormat is invalid. kvImagePrintDiagnosticsToConsole may provide
     *                                             more information.
     *
     *         kvImageInvalidCVImageFormat         The vImageCVImageFormatRef is invalid. Probably, the vImageCVImageFormatRef is
     *                                             incomplete. This can happen when a vImageCVImageFormatRef is created from a
     *                                             CVPixelBufferRef and that itself has incomplete conversion information. Please
     *                                             see "vImageCVImageFormatRef Repair" above. kvImagePrintDiagnosticsToConsole
     *                                             may provide more information.
     *
     *         kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the vImageCVImageFormatRef. Please add one.
     *         kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the vImageCVImageFormatRef. Please add.
     *         kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the vImageCVImageFormatRef.
     *         @/textblock
     *         </pre>
     * @see vImageBuffer_InitForCopyFromCVPixelBuffer When converting from CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains multiple data planes which are in turn represented by multiple vImage_Buffers.
     * @see vImageConverter_GetSourceBufferOrder for manual ordering information
     */
    @Generated
    @CFunction
    public static native vImageConverterRef vImageConverter_CreateForCVToCGImageFormat(vImageCVImageFormatRef srcFormat,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat destFormat,
            ConstNFloatPtr backgroundColor, int flags, NIntPtr error);

    /**
     * [@function] vImageBuffer_InitForCopyToCVPixelBuffer
     * <p>
     * Initialize an array of vImage_Buffers in the right order to convert a image to a CV formatted image
     * <p>
     * When converting to CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains
     * multiple data planes which are in turn represented by multiple vImage_Buffers. (These are passed in as an array
     * of vImage_Buffers to vImageConvert_AnyToAny().)  To make it easier to order the buffers correctly, we provide
     * vImageBuffer_InitForCopyToCVPixelBuffer, which initializes an array vImage_Buffer structs  in the order expected by
     * vImageConvert_AnyToAny. With appropriate flags, the conversion can be made to occur directly into the CVPixelBufferRef
     * backing store.
     * <p>
     * You are responsible for updating any missing / incorrect color information in the pixelBuffer after writing to it.
     *
     * @param buffers     A pointer to an array of vImage_Buffer structs to be overwritten. The buffers will be initialized
     *                    in the correct order for use with vImageConvert_AnyToAny and the provided converter. On entry,
     *                    buffers must point to a valid region of memory of size no smaller than number_of_buffers *
     *                    sizeof(vImage_Buffer). The number_of_buffers is given by vImageConverter_GetNumberOfDestinationBuffers.
     *                    The buffers pointer may not be NULL.
     * @param converter   The converter that will be used to do the conversion.  May not be NULL.
     * @param pixelBuffer A locked (use CVPixelBufferLockBaseAddress) CVPixelBufferRef.
     * @param flags       kvImageNoAllocate must be used.  The following flags are allowed:
     *
     *                    <pre>
     *                             @textblock
     *                                 kvImageNoFlags                      Default operation.
     *
     *                                 kvImagePrintDiagnosticsToConsole    Print diagnostic messages to the console in the event an error occurs
     *
     *                                 kvImageNoAllocate                   Instructs the function to initialized the buffers to directly write to a
     *                                                                     locked CVPixelBufferRef. You  may unlock the CVPixelBufferRef after
     *                                                                     vImageConvert_AnyToAny has returned. Once the pixelBuffer is unlocked,
     *                                                                     the vImage_Buffers initialized by this function are no longer valid and
     *                                                                     must be reinitialized.
     *
     *                             @/textblock
     *                             </pre>
     * @return The following error codes may be returned:
     *
     * <pre>
     *          @textblock
     *      kvImageNoError                  Success
     *
     *      kvImageNullPointerArgument      buffers is NULL.
     *      kvImageNullPointerArgument      converter is NULL.
     *
     *      kvImageInvalidParameter         pixelBuffer is not NULL but kvImageNoAllocate was not passed in flags. See pixelBuffer description above.
     *
     *      kvImageUnknownFlagsBit          An unknown / unhandled flags bit was set in flags.
     *
     *      kvImageInternalError            Something is very wrong inside vImage. This shouldn't happen. Please file a bug, along with a
     *                                      reproducible failure case.
     *          @/textblock
     *          </pre>
     * @see vImageConverter_GetDestinationBufferOrder for another method to initialize the vImage_Buffers in the right order for vImageConvert_AnyToAny.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageBuffer_InitForCopyToCVPixelBuffer(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer buffers,
            vImageConverterRef converter, CVBufferRef pixelBuffer, int flags);

    /**
     * [@function] vImageBuffer_InitForCopyFromCVPixelBuffer
     * <p>
     * Initialize an array of vImage_Buffers in the right order to convert CV formatted image to another image format
     * <p>
     * When converting from CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains
     * multiple data planes which are in turn represented by multiple vImage_Buffers. (These are passed in as an array
     * of vImage_Buffers to vImageConvert_AnyToAny().)  To make it easier to order the buffers correctly, we provide
     * vImageBuffer_InitForCopyFromCVPixelBuffer, which initializes an array vImage_Buffer structs  in the order expected by
     * vImageConvert_AnyToAny. With appropriate flags, the conversion can be made to occur directly from the CVPixelBufferRef
     * backing store.
     *
     * @param buffers     A pointer to an array of vImage_Buffer structs to be read. The buffers will be initialized
     *                    in the correct order for use with vImageConvert_AnyToAny and the provided converter. On entry,
     *                    buffers must point to a valid region of memory of size no smaller than number_of_buffers *
     *                    sizeof(vImage_Buffer). The number_of_buffers is given by vImageConverter_GetNumberOfSourceBuffers.
     *                    The buffers pointer may not be NULL.
     * @param converter   The converter that will be used to do the conversion.  May not be NULL.
     * @param pixelBuffer A locked (use CVPixelBufferLockBaseAddress) CVPixelBufferRef.
     * @param flags       kvImageNoAllocate must be used. The following flags are allowed:
     *
     *                    <pre>
     *                             @textblock
     *                                 kvImageNoFlags                      Default operation.
     *
     *                                 kvImagePrintDiagnosticsToConsole    Print diagnostic messages to the console in the event an error occurs
     *
     *                                 kvImageNoAllocate                   Instructs the function to initialized the buffers to directly read from a
     *                                                                     locked CVPixelBufferRef. You  may unlock the CVPixelBufferRef after
     *                                                                     vImageConvert_AnyToAny has returned. Once the pixelBuffer is unlocked,
     *                                                                     the vImage_Buffers initialized by this function are no longer valid and
     *                                                                     must be reinitialized.
     *
     *                             @/textblock
     *                             </pre>
     * @return The following error codes may be returned:
     *
     * <pre>
     *          @textblock
     *      kvImageNoError                  Success
     *
     *      kvImageNullPointerArgument      buffers is NULL.
     *      kvImageNullPointerArgument      converter is NULL.
     *
     *      kvImageInvalidParameter         pixelBuffer is not NULL but kvImageNoAllocate was not passed in flags. See pixelBuffer description above.
     *
     *      kvImageUnknownFlagsBit          An unknown / unhandled flags bit was set in flags.
     *
     *      kvImageInternalError            Something is very wrong inside vImage. This shouldn't happen. Please file a bug, along with a
     *                                      reproducible failure case.
     *          @/textblock
     *          </pre>
     * @see vImageConverter_GetSourceBufferOrder vImageConverter_GetSourceBufferOrder for another method to initialize the vImage_Buffers in the right order for vImageConvert_AnyToAny.
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageBuffer_InitForCopyFromCVPixelBuffer(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer buffers,
            vImageConverterRef converter, CVBufferRef pixelBuffer, int flags);

    /**
     * [@const]      kvImage_YpCbCrToARGBMatrix_ITU_R_601_4
     * <p>
     * Y'CbCr->RGB conversion matrix for ITU-Recommendation BT.601-4
     */
    @Generated
    @CVariable()
    @UncertainReturn("Options: reference, array Fallback: reference")
    public static native vImage_YpCbCrToARGBMatrix kvImage_YpCbCrToARGBMatrix_ITU_R_601_4();

    /**
     * [@const]      kvImage_YpCbCrToARGBMatrix_ITU_R_709_2
     * <p>
     * Y'CbCr->RGB conversion matrix for ITU-Recommendation BT.709-2
     */
    @Generated
    @CVariable()
    @UncertainReturn("Options: reference, array Fallback: reference")
    public static native vImage_YpCbCrToARGBMatrix kvImage_YpCbCrToARGBMatrix_ITU_R_709_2();

    /**
     * [@const]      kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4
     * <p>
     * RGB->Y'CbCr conversion matrix for ITU-Recommendation BT.601-4
     */
    @Generated
    @CVariable()
    @UncertainReturn("Options: reference, array Fallback: reference")
    public static native vImage_ARGBToYpCbCrMatrix kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4();

    /**
     * [@const]      kvImage_ARGBToYpCbCrMatrix_ITU_R_709_2
     * <p>
     * RGB->Y'CbCr conversion matrix for ITU-Recommendation BT.709-2
     */
    @Generated
    @CVariable()
    @UncertainReturn("Options: reference, array Fallback: reference")
    public static native vImage_ARGBToYpCbCrMatrix kvImage_ARGBToYpCbCrMatrix_ITU_R_709_2();

    /**
     * [@const] kvImageDecodeArray_16Q12Format
     * <p>
     * Predefined decode array constant to use with 16Q12 formatted data
     * <p>
     * 16Q12 data is a signed 16-bit fixed point integer. The format is implicitly divided by 2**12
     * to give a range of [-8,8)  (SHRT_MIN/4096,SHRT_MAX/4096). The type is present to allow
     * 8-bit content to be converted into other colorspaces and operated on without undue
     * loss of precision or loss of color gamut due to clamping. This constant is "magic" in the
     * sense that it is identified by address. Copying the values here will cause a CG format to
     * be instead interpreted as a _unsigned_ 16 bit format.
     * <p>
     * 16Q12 pixels do not follow CG image format conventions in two respects. The format is signed.
     * The alpha channel is subject to the decode array transform too, meaning that 0 is transparent
     * and 4096 opaque. Consequently, ALL buffers that use this format must be tagged with the
     * kvImageDecodeArray_16Q12Format decode array.
     */
    @Generated
    @CVariable()
    public static native ConstNFloatPtr kvImageDecodeArray_16Q12Format();

    @Runtime(CRuntime.class)
    @Generated
    public interface Function_SetBLASParamErrorProc {
        @Generated
        void call_SetBLASParamErrorProc(
                @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String arg0,
                @UncertainArgument("Options: java.string, c.const-byte-ptr Fallback: java.string") String arg1,
                ConstIntPtr arg2, ConstIntPtr arg3);
    }

    @Runtime(CRuntime.class)
    @Generated
    public interface Function_la_matrix_from_float_buffer_nocopy {
        @Generated
        void call_la_matrix_from_float_buffer_nocopy(VoidPtr arg0);
    }

    @Runtime(CRuntime.class)
    @Generated
    public interface Function_la_matrix_from_double_buffer_nocopy {
        @Generated
        void call_la_matrix_from_double_buffer_nocopy(VoidPtr arg0);
    }

    @Runtime(CRuntime.class)
    @Generated
    public interface Function_vImageNewResamplingFilterForFunctionUsingBuffer {
        @Generated
        void call_vImageNewResamplingFilterForFunctionUsingBuffer(ConstFloatPtr arg0, FloatPtr arg1, @NUInt long arg2,
                VoidPtr arg3);
    }

    @Runtime(CRuntime.class)
    @Generated
    public interface Function_vImageGetResamplingFilterSize {
        @Generated
        void call_vImageGetResamplingFilterSize(ConstFloatPtr arg0, FloatPtr arg1, @NUInt long arg2, VoidPtr arg3);
    }

    @Runtime(CRuntime.class)
    @Generated
    public interface Function_vImageCreateCGImageFromBuffer {
        @Generated
        void call_vImageCreateCGImageFromBuffer(VoidPtr arg0, VoidPtr arg1);
    }

    @Runtime(CRuntime.class)
    @Generated
    public interface Function_vImageCVImageFormat_SetUserData {
        @Generated
        void call_vImageCVImageFormat_SetUserData(vImageCVImageFormatRef arg0, VoidPtr arg1);
    }

    /**
     * Create a vector conversion/activation layer filter (DEPRECATED,  Use BNNSFilterCreateLayerActivation)
     * <p>
     * Creates a filter applying the given activation function and conversions to vectors. Input and output vectors must have the same size.
     *
     * @param in_desc       Input vector descriptor
     * @param out_desc      Output vector descriptor
     * @param activation    Activation function to apply and its parameters
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateVectorActivationLayer(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSVectorDescriptor in_desc,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSVectorDescriptor out_desc,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSActivation activation,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    @Generated
    @CFunction
    public static native void _SparseRetainSymbolic(VoidPtr symbolicFactor);

    @Generated
    @CFunction
    public static native void _SparseDestroyOpaqueSymbolic(VoidPtr toFree);

    @Generated
    @CFunction
    @ByValue
    public static native SparseSymbolicFactorOptions _SparseGetOptionsFromSymbolicFactor(VoidPtr factor);

    @Generated
    @CFunction
    public static native void _SparseTrap();

    @Generated
    @CFunction
    public static native void _SparseRefactorSymmetric_Double(VoidPtr Matrix, VoidPtr Factorization,
            @UncertainArgument("Options: reference, array Fallback: reference") SparseNumericFactorOptions nfoptions,
            VoidPtr workspace);

    @Generated
    @CFunction
    public static native void _SparseRefactorQR_Double(VoidPtr Matrix, VoidPtr Factorization,
            @UncertainArgument("Options: reference, array Fallback: reference") SparseNumericFactorOptions nfoptions,
            VoidPtr workspace);

    @Generated
    @CFunction
    public static native void _SparseMultiplySubfactor_Double(VoidPtr Subfactor, VoidPtr x, VoidPtr y,
            BytePtr workspace);

    @Generated
    @CFunction
    public static native void _SparseSolveSubfactor_Double(VoidPtr Subfactor, VoidPtr b, VoidPtr x, BytePtr workspace);

    @Generated
    @CFunction
    public static native void _SparseSolveOpaque_Double(VoidPtr Factored, VoidPtr RHS, VoidPtr Soln, VoidPtr workspace);

    @Generated
    @CFunction
    public static native void _SparseDestroyOpaqueNumeric_Double(VoidPtr toFree);

    @Generated
    @CFunction
    public static native void _SparseRetainNumeric_Double(VoidPtr numericFactor);

    @Generated
    @CFunction
    @ByValue
    public static native SparseNumericFactorOptions _SparseGetOptionsFromNumericFactor_Double(VoidPtr factor);

    @Generated
    @CFunction
    @NUInt
    public static native long _SparseGetIterativeStateSize_Double(VoidPtr method, boolean preconditioner, int m, int n,
            int nrhs);

    @Generated
    @CFunction
    public static native void _SparseReleaseOpaquePreconditioner_Double(VoidPtr toFree);

    @Generated
    @CFunction
    public static native void _SparseRefactorSymmetric_Float(VoidPtr Matrix, VoidPtr Factorization,
            @UncertainArgument("Options: reference, array Fallback: reference") SparseNumericFactorOptions nfoptions,
            VoidPtr workspace);

    @Generated
    @CFunction
    public static native void _SparseRefactorQR_Float(VoidPtr Matrix, VoidPtr Factorization,
            @UncertainArgument("Options: reference, array Fallback: reference") SparseNumericFactorOptions nfoptions,
            VoidPtr workspace);

    @Generated
    @CFunction
    public static native void _SparseMultiplySubfactor_Float(VoidPtr Subfactor, VoidPtr x, VoidPtr y,
            BytePtr workspace);

    @Generated
    @CFunction
    public static native void _SparseSolveSubfactor_Float(VoidPtr Subfactor, VoidPtr b, VoidPtr x, BytePtr workspace);

    @Generated
    @CFunction
    public static native void _SparseSolveOpaque_Float(VoidPtr Factored, VoidPtr RHS, VoidPtr Soln, VoidPtr workspace);

    @Generated
    @CFunction
    public static native void _SparseDestroyOpaqueNumeric_Float(VoidPtr toFree);

    @Generated
    @CFunction
    public static native void _SparseRetainNumeric_Float(VoidPtr numericFactor);

    @Generated
    @CFunction
    @ByValue
    public static native SparseNumericFactorOptions _SparseGetOptionsFromNumericFactor_Float(VoidPtr factor);

    @Generated
    @CFunction
    @NUInt
    public static native long _SparseGetIterativeStateSize_Float(VoidPtr method, boolean preconditioner, int m, int n,
            int nrhs);

    @Generated
    @CFunction
    public static native void _SparseReleaseOpaquePreconditioner_Float(VoidPtr toFree);

    /**
     * Create a convolution layer filter
     * <p>
     * Creates a filter applying the convolution described in <tt>layer_params</tt>.
     * Some combinations of the parameters may not be supported, in which case the call will fail.
     *
     * @param layer_params  Layer parameters and input, weights, output, bias and activation descriptors
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerConvolution(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersConvolution layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a transposed convolution layer filter (also known as deconvolution)
     * <p>
     * Creates a filter applying the transposed convolution described in <tt>layer_params</tt>.
     * Some combinations of the parameters may not be supported, in which case the call will fail.
     * Currently only BNNSDataTypeFloat32 data type is supported.
     *
     * @param layer_params  Layer parameters and input, weights, output, bias and activation descriptors
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerTransposedConvolution(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersConvolution layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a fully connected layer filter
     * <p>
     * Creates a filter applying the fully connected layer described in <tt>layer_params</tt>.
     * Some combinations of the parameters may not be supported, in which case the call will fail.
     *
     * @param layer_params  input, weights, output, bias and activation descriptors
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerFullyConnected(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersFullyConnected layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a pooling layer filter
     * <p>
     * Creates a filter applying the pooling layer described in <tt>layer_params</tt>
     * Some combinations of the parameters may not be supported, in which case the call will fail.
     *
     * @param layer_params  Layer parameters and input, weights, output, bias and activation descriptors
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerPooling(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersPooling layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a Activation/Conversion layer filter
     * <p>
     * Creates a filter applying the given activation function or conversions.
     * Input and output must have the same number of elements.
     *
     * @param layer_params  input, output and activation descriptors
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerActivation(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersActivation layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a Loss layer filter
     * <p>
     * Creates a filter applying loss function and loss reduction.
     *
     * @param layer_params  input, output and loss description
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerLoss(ConstVoidPtr layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a Normalization layer filter
     * <p>
     * Creates a normalization filter that normalize inputs based on mean, variance and trainable parameters beta and gamma.
     *
     * @param normType      type of normalization, currently supporting batch, instance, layer and group norm.
     * @param layer_params  normalization layer parameters pointer.
     * @param filter_params Filter runtime parameters, may be NULL for default parameters.
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerNormalization(int normType,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersNormalization layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create an Arithmetic layer filter
     * <p>
     * Creates an Arithmetic filter such as add, subtract, multiply.
     *
     * @param layer_params  Arithmetic layer parameters pointer.
     * @param filter_params Filter runtime parameters, may be NULL for default parameters.
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerArithmetic(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersArithmetic layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a Permute layer filter
     * <p>
     * Creates a permute layer filter that copies one tensor to another whilst permuting the order of the axes
     *
     * @param layer_params  Permute layer parameters pointer.
     * @param filter_params Filter runtime parameters, may be NULL for default parameters.
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerPermute(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersPermute layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a dropout filter
     * <p>
     * The function will:
     * validate correctness of the parameters
     * create a new dropout filter
     *
     * @param layer_params  dropout layer parameters
     * @param filter_params filter parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerDropout(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersDropout layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a padding filter
     * <p>
     * The function will:
     * validate correctness of the filter parameters
     * create a new padding filter
     *
     * @param layer_params  padding layer parameters
     * @param filter_params filter parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerPadding(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersPadding layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a layer representing a broadcast matrix multiplication
     * <p>
     * See BNNSLayerParametersBroadcastMatMul for a full description of this layer.
     *
     * @param layer_params  layer description
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     * @see BNNSLayerParametersBroadcastMatMul
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerBroadcastMatMul(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersBroadcastMatMul layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Creates a layer representing an arbitrary tensor contraction
     * <p>
     * For a full discussion of this layer, see BNNSLayerParametersTensorContraction.
     *
     * @param layer_params  layer description
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     * @see BNNSLayerParametersTensorContraction
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerTensorContraction(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersTensorContraction layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a layer representing a Gram matrix calculation
     * <p>
     * Performs the Gram matrix calculation:
     * y[ f, c ] = alpha * sum_{i,j} x[ i, j, f ] * x[ i, j, c ]
     *
     * @param layer_params  layer description
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     * @see BNNSLayerParametersGram
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerGram(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersGram layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a layer representing a resizing in one or more dimensions
     * <p>
     * See BNNSLayerParametersResize for a full description of this layer.
     *
     * @param layer_params  layer description
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     * @see BNNSLayerParametersResize
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerResize(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersResize layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a multiheaded attention layer
     * <p>
     * See BNNSLayerParametersMultiheadAttention for a full description of this layer.
     *
     * @param layer_params  layer description
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     * @see BNNSLayerParametersMultiheadAttention
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerMultiheadAttention(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersMultiheadAttention layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a reduction layer
     * <p>
     * See BNNSLayerParametersReduction for a full description of this layer.
     *
     * @param layer_params  layer description
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     * @see BNNSLayerParametersReduction
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerReduction(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersReduction layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a fused filter
     * <p>
     * Create an N layer fused filter that process input in the following way: input -> filter0 -> filter1 -> ... -> filter N-1 -> output
     * first N-1 filters must have activation function BNNSActivationFunctionIdentity in training.
     * last filter may have a different activation function. gradient computation restrictions on last activation function are the same as in BNNSFilterApplyBackwardBatch.
     * For K between 0 and N-2, the K filter output descriptor and the K+1 filter input descriptor  must have the same sizes, strides and data type.
     * <p>
     * Initial implementation support fusing 2 filters in the following configurations:
     * Configuration 1: Convolution -> Normalization
     * filter0 is convolution and filter1 is normalization. for example, the filter_type and layer_params arrays when using batchnorm should be as follows:
     * filter_type: [BNNSConvolution, BNNSBatchNorm]
     * layer_params: [pointer to BNNSLayerParametersConvolution, pointer to BNNSLayerParametersNormalization]
     * <p>
     * Configuration 2: FullyConnected -> Normalization
     * filter0 is fully connected and filter1 is normalization. for example, the filter_type and layer_params arrays when using batchnorm should be as follows:
     * filter_type: [BNNSFullyConnected, BNNSBatchNorm]
     * layer_params: [pointer to BNNSLayerParametersFullyConnected, pointer to BNNSLayerParametersNormalization]
     * <p>
     * Configuration 3: Transposed Convolution -> Normalization
     * filter0 is tranposed convolution and filter1 is normalization. for example, the filter_type and layer_params arrays when using batchnorm should be as follows:
     * filter_type: [BNNSTransposedConvolution, BNNSBatchNorm]
     * layer_params: [pointer to BNNSLayerParametersConvolution, pointer to BNNSLayerParametersNormalization]
     * <p>
     * Configuration 4: Convolution -> Quantization
     * filter0 is convolution and filter1 is quantization. The filter_type and layer_params arrays should be as follows:
     * filter_type: [BNNSConvolution, BNNSQuantization]
     * layer_params: [pointer to BNNSLayerParametersConvolution, pointer to BNNSLayerParametersQuantization]
     * input and ouput descriptor data pointers in BNNSLayerParametersQuantization are ignored
     * Note that if the quantization layer uses batch as an axis with scale and/or bias, the batch size is encoded in the quantization layer parameters. In this case, if the batch size changes, the filter must be destroyed and recreated.
     * <p>
     * Configuration 5: FullyConnected -> Quantization
     * filter0 is fully connected and filter1 is quantization. The filter_type and layer_params arrays should be as follows:
     * filter_type: [BNNSFullyConnected, BNNSQuantization]
     * layer_params: [pointer to BNNSLayerParametersFullyConnected, pointer to BNNSLayerParametersQuantization]
     * input and ouput descriptor data pointers in BNNSLayerParametersQuantization are ignored
     * Note that if the quantization layer uses batch as an axis with scale and/or bias, the batch size is encoded in the quantization layer parameters. In this case, if the batch size changes, the filter must be destroyed and recreated.
     * <p>
     * Configuration 6: Transposed Convolution -> Quantization
     * filter0 is tranposed convolution and filter1 is quantization. The filter_type and layer_params arrays should be as follows:
     * filter_type: [BNNSTransposedConvolution, BNNSQuantization]
     * layer_params: [pointer to BNNSLayerParametersConvolution, pointer to BNNSLayerParametersQuantization]
     * input and ouput descriptor data pointers in BNNSLayerParametersQuantization are ignored
     * Note that if the quantization layer uses batch as an axis with scale and/or bias, the batch size is encoded in the quantization layer parameters. In this case, if the batch size changes, the filter must be destroyed and recreated.
     * <p>
     * Configuration 7: Arithmetic -> Normalization
     * filter0 is arithmetic and filter1 is normalization. for example, the filter_type and layer_params arrays when using batchnorm should be as follows:
     * filter_type: [BNNSArithmetic, BNNSBatchNorm]
     * layer_params: [pointer to BNNSLayerParametersArithmetic, pointer to BNNSLayerParametersNormalization]
     *
     * @param number_of_fused_filters number of filters to fuse
     * @param filter_type             pointer to an array of filter type, array size must be number_of_fused_filters
     * @param layer_params            pointer to an array of layer parameter pointers. layer_params array size must be number_of_fused_filters
     *                                every layer parameter structure must be valid and match the type specified in filter_type array, such that layer parameter at index i of layer_params can be used to create a stand-alone filter of the type specified by the filter type in filter_type array at index i.
     * @param filter_params           Filter runtime parameters, may be NULL for default parameters.
     * @return A new non-NULL filter on success, and NULL on failure.
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateFusedLayer(@NUInt long number_of_fused_filters,
            ConstIntPtr filter_type, Ptr<ConstVoidPtr> layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Applies a previously created pooling layer filter
     * <p>
     * Pooling layer filter is applied for each of the batch_size inputs, and produces batch_size outputs. indices is optional.
     * in (resp. out) is expected to point to batch_size times the input (resp. output) object size defined when the filter was created.
     * indices has the same size as output if not null.
     *
     * @param filter     Filter to apply
     * @param batch_size Number of (input, output, indices)  to process
     * @param in         Pointer to the input data
     * @param in_stride  Increment (in values) between inputs
     * @param out        Pointer to the output data
     * @param out_stride Increment (in values) between outputs
     * @param indices    Pointer to the indices data generated by max pooling.
     *                   - max pooling produces indices if not null. indices must have the same dimension and stride as the output data.
     *                   - max unpooling requires a valid pointer. indices must have the same dimension and stride as the input data.
     *                   - ignored for other pooling functions
     * @param idx_stride Increment (in values) between indices
     */
    @Generated
    @CFunction
    public static native int BNNSPoolingFilterApplyBatch(VoidPtr filter, @NUInt long batch_size, ConstVoidPtr in,
            @NUInt long in_stride, VoidPtr out, @NUInt long out_stride, NUIntPtr indices, @NUInt long idx_stride);

    /**
     * Apply a filter
     *
     * @param filter Filter to apply
     * @param inA    Pointer to the first input tensor
     * @param inB    Pointer to the second input tensor
     * @param out    Pointer to the output data
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFilterApplyTwoInput(VoidPtr filter, ConstVoidPtr inA, ConstVoidPtr inB, VoidPtr out);

    /**
     * Apply a filter to a several pairs of (input, output) data
     * <p>
     * The filter is applied for each of the <tt>batch_size</tt> inputs, and produces <tt>batch_size</tt> outputs.
     * <tt>in</tt> (resp. <tt>out</tt>) is expected to point to <tt>batch_size</tt> times the input (resp. output) object size defined when the filter was created.
     *
     * @param filter     Filter to apply
     * @param batch_size Number of (input, output) pairs to process
     * @param inA        Pointer to the first input tensor
     * @param inA_stride Increment (in values) between inputs in the first tensor
     * @param inB        Pointer to the second input tensor
     * @param inB_stride Increment (in values) between inputs in the second tensor
     * @param out        Pointer to the output data
     * @param out_stride Increment (in values) between outputs
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFilterApplyTwoInputBatch(VoidPtr filter, @NUInt long batch_size, ConstVoidPtr inA,
            @NUInt long inA_stride, ConstVoidPtr inB, @NUInt long inB_stride, VoidPtr out, @NUInt long out_stride);

    /**
     * Apply a normalization filter to several pairs of (input, output) data
     * <p>
     * The filter is applied for each of the <tt>batch_size</tt> inputs, and produces <tt>batch_size</tt> outputs.
     * <tt>in</tt> (resp. <tt>out</tt>) is expected to point to <tt>batch_size</tt> times the input (resp. output) object size defined when the filter was created.
     * <p>
     * Normalization filter supports two different modes - training and inference.
     * In training mode, only current batch/instance/layer/group statistics are used to normalize the input.
     * In addition, training mode may store information internally to be used during backward computation.
     * For batch norm and instance norm, moving mean and moving variance are computed during training
     * so they can be later used during inference, ignored if null.
     * For layer norm and group norm, moving mean and moving variance are not supported and ignored.
     * <p>
     * For batch norm and instance norm,  moving mean and moving variance are used to normalize the input during inference if not null.
     * Otherwise, current batch/instance/layer/group statistics are used to normalize the input.
     * <p>
     * output address equal to input address (in-place) is supported for both training and inference
     *
     * @param filter     Filter to apply
     * @param batch_size Number of (input, output) pairs to process
     * @param in         Pointer to the input data
     * @param in_stride  Increment (in values) between inputs
     * @param out        Pointer to the output data
     * @param out_stride Increment (in values) between outputs
     * @param training   true if training, false if inference
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSNormalizationFilterApplyBatch(VoidPtr filter, @NUInt long batch_size, ConstVoidPtr in,
            @NUInt long in_stride, VoidPtr out, @NUInt long out_stride, boolean training);

    /**
     * Apply a fused filter to several pairs of (input, output) data
     * <p>
     * The filter is applied for each of the <tt>batch_size</tt> inputs, and produces <tt>batch_size</tt> outputs.
     * <tt>in</tt> (resp. <tt>out</tt>) is expected to point to <tt>batch_size</tt> times the input (resp. output) object size defined when the filter was created.
     *
     * @param filter     Filter to apply
     * @param batch_size Number of (input, output) pairs to process
     * @param in         Pointer to the input data
     * @param in_stride  Increment (in values) between inputs
     * @param out        Pointer to the output data
     * @param out_stride Increment (in values) between outputs
     * @param training   true if training, false if inference
     *                   -ignored if none of the filters is batchnorm
     *                   -see training flag information in BNNSNormalizationFilterApplyBatch
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFusedFilterApplyBatch(VoidPtr filter, @NUInt long batch_size, ConstVoidPtr in,
            @NUInt long in_stride, VoidPtr out, @NUInt long out_stride, boolean training);

    /**
     * Apply an arithmetic filter to several pairs of (input set, output) data
     * <p>
     * an input set is composed of the inputs necessary to compute a given arithmetic operation.
     * <p>
     * The filter is applied for each of the <tt>batch_size</tt> inputs, and produces <tt>batch_size</tt> outputs.
     * <tt>batch_size</tt> is ignored for an input or output if its type is BNNSConstant or BNNSParameter.
     *
     * <tt>in</tt> is expected to point to an array of arithmetic operation inputs as required by the given arithmetic operation.
     * Inputs and output must have the same data layout. Input support broadcasting such that two descriptors are compatible if for every dimension descriptors sizes are equal or one of them is 1.
     * for example, a valid addition operation could have input1 size [1,3,4], input2 size [2,3,1] and output size [2,3,4]
     * unless specified otherwise, each input size should be equal to output size or be broadcast compatible.
     * inputs are allowed to point to a common address (same input), in which case gradients in backward compute must also point to a common address (same gradient).
     * <p>
     * for example, an addition arithmetic operation require two inputs, and therefore the in array size and the in_stride array size is 2.
     * each pointer in the in array should point to a valid input.
     * in case input1, input2 and output types are all BNNSSample, the output for each output sample in the batch will be the addition of the corresponding batch sample in input1 and in input2.
     * if output and input1 are BNNSSample and input2 is BNNSConstant or BNNSParameter, the output for each output sample in the batch will be the addition of the corresponding batch sample in input1 and input2 where batch is ignored for input2.
     * <p>
     * Some arithmetic functions support in-place processing for forward and backward apply operations. That is the input and output (or output_delta and input_delta) may use the same pointer and descriptor in order to save memory (if the layer has multiple inputs, the user may choose which to use in-place).
     * The input data is destroyed in the process, thus care must be taken during the forward pass to ensure all required inputs to the backward pass are preserved (noting that this layer’s input is normally the preceding layer’s output).
     * In addition, descriptors for input being processed in-place and output must exactly match. in-place descriptor types must also match in case batch size > 1.
     *
     * @param filter           Filter to apply
     * @param batch_size       Number of (input sets, output) pairs to process
     * @param number_of_inputs number of inputs for the arithmetic operation
     * @param in               pointer to an array of input pointers. in array size must be number_of_inputs.
     * @param in_stride        pointer to an array of input strides, each stride is an Increment (in values) between inputs in the batch for a corresponding input in the in array.
     * @param out              Pointer to the output data
     * @param out_stride       Increment (in values) between outputs
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSArithmeticFilterApplyBatch(VoidPtr filter, @NUInt long batch_size,
            @NUInt long number_of_inputs, Ptr<ConstVoidPtr> in, ConstNUIntPtr in_stride, VoidPtr out,
            @NUInt long out_stride);

    /**
     * Applies a previously created multihead attention layer
     * <p>
     * When training, the backward pass can be accelerated by caching intermediate values from the forward pass.
     * This is done by providing a memory buffer backprop_cache. The recommended size for this buffer may be obtained by calling
     * the function with the pointer backprop_cache_size set to non-NULL, and backprop_cache set to NULL. The recommended size
     * will be stored in *backprop_cache_size (the layer application will not be perfomed).
     * The user may optionally provide a scratch workspace. The required size will depend the size of backprop_cache provided, and
     * if no scratch workspace is provided one will be allocated internally. The size of required workspace can be obtained by calling
     * the routine with a non-NULL workspace_size parameter and a NULL workspace pointer, and the required size will be returned
     * in *workspace_size (the layer application will not be perfomed).
     * If both backprop_cache_size and workspace_size are queried simulateneously, the returned workspace size will assume that
     * the full backprop_cache_size is provided.
     *
     * @param F                   Filter to apply created by a previous call to BNNSFilterCreateLayerMultiheadAttention()
     * @param batch_size          Number of inputs in batch
     * @param query               Pointer to data for query input matrix, layout as described by layer_params->query.target_desc
     * @param query_stride        Batch stride for query
     * @param key                 Pointer to data for key input matrix, layout as described by layer_params->key.target_desc
     * @param key_stride          Batch stride for key
     * @param key_mask            Mask applied to key for ignoring entries. A 1D tensor of type BNNSDataTypeBoolean and shape
     *                            source_length. Where this tensor evalautes to true, the corresponding elements of the key matrix are
     *                            ignored in the attention operation. No key mask is applied if NULL is passed.
     * @param key_mask_stride     Batch stride for key_mask
     * @param value               Pointer to data for value input matrix, layout as described by layer_params->value.target_desc
     * @param value_stride        Batch stride for value
     * @param output              Pointer to data for output matrix, layout as described by layer_params->output.target_desc
     * @param output_stride       Batch stride for output
     * @param add_to_attention    Optional, one of:
     *                            1) a 2D tensor of shape target_length x source_length; or
     *                            2) a 3D tensor of shape num_heads x target_length x source_length; or
     *                            3) a 4D tensor of shape batch_size x num_heads x target_length x source_length.
     *                            This is used as part of the mask function prior to softmax in the attention calculation (the matrix X in the layer description).
     *                            If the data type is BNNSDataTypeBoolean, true is treated as adding -inf, and false as adding zero (that is to say attention
     *                            is not permitted in locations indicated by the the mask).
     *                            No matrix is added if this pointer is NULL.
     *                            Note: The 3D, 4D and BNNSDataTypeBoolean variants of this parameter are only supported in macOS 12.0, iOS 15.0,
     *                            watchOS 8.0, tvOS 15.0 and later.
     * @param backprop_cache_size Specifies the size of the array backprop_cache, in bytes.
     *                            If backprop_cache_size is not-NULL but backprop_cache is NULL, the recommended size for backprop_cache_size
     *                            will be set, but not other calculations will be performed (except to set workspace_size if requested).
     * @param backprop_cache      Is used to store intermediate results that can be used to accelerate a future call to
     *                            BNNSApplyMultiheadAttentionBackward.
     * @param workspace_size      Specifies the size of the array workspace, in bytes.
     *                            If workspace_size is not-NULL but workspace is NULL, the recommended size for workspace_size
     *                            will be set, but not other calculations will be performed (except to set backprop_cache_size if requested).
     * @param workspace           Is used as a scratch buffer during the calculation.
     */
    @Generated
    @CFunction
    public static native int BNNSApplyMultiheadAttention(VoidPtr F, @NUInt long batch_size, ConstVoidPtr query,
            @NUInt long query_stride, ConstVoidPtr key, @NUInt long key_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor key_mask,
            @NUInt long key_mask_stride, ConstVoidPtr value, @NUInt long value_stride, VoidPtr output,
            @NUInt long output_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor add_to_attention,
            NUIntPtr backprop_cache_size, VoidPtr backprop_cache, NUIntPtr workspace_size, VoidPtr workspace);

    /**
     * Apply a single step of optimization to one or more parameters
     * <p>
     * The optimizer will use the specified optimization algorithm to update a set of parameters such as weights and bias.
     * Data layout in memory of parameters, gradients and accumulators arrays must be contiguous, such that stride[0]=1 and for every N>0 stride[N]=stride[N-1]*size[N-1]. strides   in the descriptors may be provided as zeros.
     * accumulators must be allocated by caller and have the same size as a matching parameter. accumulator descriptor data must be set to zero the first time the filter is   applied.
     * OptimizerAlgFields pointer is saved internally, changes to the struct fields such as learning_rate for BNNSOptimizerSGDMomentumFields structure are allowed between   filter apply calls.
     * <p>
     * Accumulator requirements depend on the optimzation algorithm and its parameters:
     * <p>
     * BNNSOptimzerFunctionSGDMomentum
     * ===============================
     * Set to NULL for vanilla SGD (indicating momentum is 0).
     * Set to a size number_of_parameters array if use of momentum is desired.
     * <p>
     * BNNSOptimizerFunctionAdam
     * =======================
     * Set to a size 2*number_of_parameters array.
     * The first number_of_parameters pointers are used for the first momentum descriptors, and the subsequent number_of_parameters pointers are used for the second  momentum descriptors.
     * <p>
     * BNNSOptimizerFunctionAdamAMSGrad
     * ===============================
     * Set to a size 3*number_of_parameters array.
     * The first number_of_parameters pointers are used for the first momentum descriptors, the second number_of_parameters pointers are used for the second  momentum descriptors, and the third number_of_parameters pointers are used for the second momentum maxima descriptors.
     * <p>
     * BNNSOptimizerFunctionAdamW
     * ========================
     * Set to a size 2*number_of_parameters array.
     * The first number_of_parameters pointers are used for the first momentum descriptors, and the subsequent number_of_parameters ointers are used for the second  momentum descriptors.
     * <p>
     * BNNSOptimizerFunctionAdamWAMSGrad
     * ===============================
     * Set to a size 3*number_of_parameters array.
     * The first number_of_parameters pointers are used for the first momentum descriptors, the second number_of_parameters pointers are used for the second  momentum descriptors, and the third number_of_parameters pointers are used for the second momentum maxima descriptors.
     * <p>
     * BNNSOptimizerFunctionRMSProp
     * ==========================
     * Should be of size k*number_of_parameters, where
     * k = 1  +  (OptimizerAlgFields.centered ? 1 : 0)  + (OptimizerAlgFields.momentum != 0.0).
     * That is to say a base of one accumulator per parameter, with one extra accumulator required for each of centering and momentum if they are enabled.
     * Using the notation used in the description of BNNSOptimizerRMSPropFields, the first number_of_parameters pointers are used for n_i, the next
     * set are used for g_i (iff centering is used) and the next set are used for the momentum Δ_i (iff momentum γ != 0.0).
     * <p>
     * [@returns] 0 on success, non-zero on failure
     *
     * @param function             Optimization function (algorithm) to use
     * @param OptimizerAlgFields   Parameters for optimization function, pointer to a struct whose type is determined by the value of function.
     * @param number_of_parameters number of parameters to update
     * @param parameters           array of parameter descriptors
     * @param gradients            array of gradient descriptors. Each gradient descriptor data in the array must be the same size as its matching parameter descriptor in the  parameters array.
     * @param accumulators         array of accumulator descriptors. Required number of accumulators varies depending on optimization algorithm and parameters - see function description. In all cases, accumulators must be allocated and initialized to zero by the user prior to the first call optimization step.
     * @param filter_params        Filter runtime parameters, may be NULL for default parameters.
     */
    @Generated
    @CFunction
    public static native int BNNSOptimizerStep(int function, ConstVoidPtr OptimizerAlgFields,
            @NUInt long number_of_parameters, Ptr<Ptr<BNNSNDArrayDescriptor>> parameters,
            Ptr<ConstPtr<BNNSNDArrayDescriptor>> gradients, Ptr<Ptr<BNNSNDArrayDescriptor>> accumulators,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Apply filter backward to generate input delta, weights delta and bias delta
     * <p>
     * For a general filter f that computes output y by using weights w and bias b
     * The forward pass filter computation can be described as:
     * y = f(x,w,b)
     * for example, the output y of a convolution filter f can be described as
     * y = f(x,w,b) = w*x+b
     * <p>
     * The backward computation uses the output delta (dy) to generate the input delta (dx), weight delta (dw) and bias delta (db)
     * In some cases the backward computation function also requires the forward pass input (x) and the forward pass output (y).
     * <p>
     * The following arguments are required for the backward computation:
     * out_delta descriptor (dy) are the gradients arriving from the following filter and must be provided.
     * in pointer is the forward pass input (x) and should be provided if not specified it is ignored
     * out pointer is the forward pass output (y) and should be provided if not specified it is ignored
     * <p>
     * For dropout processing, it only needs delta of input/output, and the result is independent of forward input/output.  So backward apply will ignore input/output.
     * <p>
     * The following gradients are generated by the backward computation.
     * in_delta  - the input delta (dx)
     * weights_delta - the weight delta (dw)
     * bias_delta - the bias delta (db)
     * NULL descriptor pointers will not be computed. data field of a valid descriptor must point to the delta buffer to be produced.
     * <p>
     * Important activation information:
     * For any general activation function, when computing activation layer backward, the forward pass input (x) to the activation is required.
     * However, in most activation functions, it is possible and faster to compute the activation backward from the forward pass output y.
     * In the case of fused computation and activation layers, it is mandatory to provide the forward pass output y.
     * Notice that some activation functions cannot be fused with the computation filters.
     * <p>
     * Activation backward functions that can accept either forward pass input or forward pass output (output is prefered):
     * BNNSActivationFunctionIdentity
     * BNNSActivationFunctionRectifiedLinear
     * BNNSActivationFunctionLeakyRectifiedLinear   (if alpha > 0.0 and weights_delta is not present)
     * BNNSActivationFunctionSigmoid
     * BNNSActivationFunctionLogSigmoid
     * BNNSActivationFunctionTanh
     * BNNSActivationFunctionLinear
     * BNNSActivationFunctionClamp
     * BNNSActivationFunctionSoftmax
     * BNNSActivationFunctionHardSigmoid
     * BNNSActivationFunctionSoftplus
     * BNNSActivationFunctionSoftsign
     * BNNSActivationFunctionELU
     * BNNSActivationFunctionSELU
     * BNNSActivationFunctionCELU
     * BNNSActivationFunctionClampedLeakyRectifiedLinear  (if alpha > 0.0)
     * BNNSActivationFunctionLinearWithBias
     * BNNSActivationFunctionLogSoftmax
     * BNNSActivationFunctionHardShrink
     * BNNSActivationFunctionSoftShrink
     * BNNSActivationFunctionTanhShrink
     * BNNSActivationFunctionThreshold
     * <p>
     * The activation functions above can be fused with computation in training, only if the forward pass output y is provided in backward apply.
     * <p>
     * Other activation functions require forward pass input and does not support fusing computation with activation, such as:
     * BNNSActivationFunctionAbs
     * BNNSActivationFunctionGELUApproximation
     * BNNSActivationFunctionGELUApproximation2
     * BNNSActivationFunctionSiLU
     * <p>
     * Additional requirements:
     * BNNSFlagsUseClientPtr flag must be enabled when creating the filter.
     * data_type of all descriptors must be BNNSDataTypeFloat32.
     *
     * @param filter           Filter to apply backward
     * @param batch_size       Number of (input, output) pairs to process
     * @param in               Pointer to the forward pass input data (x)
     *                         - ignored when computing input delta and bias delta unless filter is pooling or filter is activation and backpropagation from output is supported.
     * @param in_stride        Increment (in values) between inputs
     *                         - ignored when computing input delta or bias delta if the filter is not pooling
     * @param in_delta         Pointer to the input delta descriptor
     *                         - not produced if null
     * @param in_delta_stride  Increment (in values) between input deltas
     * @param out              Pointer to the forward pass output data (y)
     *                         - out is ignored in all filters if activation is BNNSActivationFunctionIdentity
     *                         - some activation function backward computation can run faster if provided with the forward output
     *                         - fused computation and activation filters such as convolution with activation must provide the forward pass output
     * @param out_stride       Increment (in values) between outputs
     * @param out_delta        Pointer to the output delta descriptor (dy)
     * @param out_delta_stride Increment (in values) between output deltas
     * @param weights_delta    Pointer to the weights delta descriptor
     *                         - delta is aggregated across batch
     *                         - not produced if null
     *                         - computed weights_delta layout will match the filter weight layout that was provided at the creation of the filter
     * @param bias_delta       Pointer to the bias delta descriptor
     *                         - not produced if null
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFilterApplyBackwardBatch(VoidPtr filter, @NUInt long batch_size, ConstVoidPtr in,
            @NUInt long in_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in_delta,
            @NUInt long in_delta_stride, ConstVoidPtr out, @NUInt long out_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            @NUInt long out_delta_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor weights_delta,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor bias_delta);

    /**
     * Apply pooling filter backward to generate input delta and bias delta
     * <p>
     * This is similar to BNNSFilterApplyBackwardBatch, but takes indices as an optional input.
     * It is mandatory to compute all active gradients in a single function call. computation of input delta is not required in case the filter is the first layer in the network
     *
     * @param filter           Filter to apply backward
     * @param batch_size       Number of (input, output, indices) to process
     * @param in               Pointer to the forward pass input data (x)
     * @param in_stride        Increment (in values) between inputs
     * @param in_delta         Pointer to the input delta descriptor
     *                         - not produced if null
     * @param in_delta_stride  Increment (in values) between input deltas
     * @param out              Pointer to the forward pass output data (y)
     *                         - out is ignored if activation is BNNSActivationFunctionIdentity
     *                         - fused pooling and activation filters  must provide the forward pass output
     * @param out_stride       Increment (in values) between outputs
     * @param out_delta        Pointer to the output delta descriptor (dy)
     * @param out_delta_stride Increment (in values) between output deltas
     * @param bias_delta       Pointer to the bias delta descriptor
     *                         - not produced if null
     * @param indices          Pointer to the forward pass indices data generated by max pooling.
     *                         - max pooling could use indices to reduce computation if not null. indices must have the same dimension and stride as the output data.
     *                         - max unpooling requires a valid pointer. indices must have the same dimension and stride as the input data.
     *                         - ignored for other pooling functions
     * @param idx_stride       Increment (in values) between indices
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSPoolingFilterApplyBackwardBatch(VoidPtr filter, @NUInt long batch_size,
            ConstVoidPtr in, @NUInt long in_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in_delta,
            @NUInt long in_delta_stride, ConstVoidPtr out, @NUInt long out_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            @NUInt long out_delta_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor bias_delta,
            ConstNUIntPtr indices, @NUInt long idx_stride);

    /**
     * Apply filter backward to generate input deltas, weights delta and bias delta (two input version)
     * <p>
     * For a general filter f that computes output y by using weights w and bias b
     * The forward pass filter computation can be described as:
     * y = f(x,w,b)
     * for example, the output y of a convolution filter f can be described as
     * y = f(x,w,b) = w*x+b
     * <p>
     * The backward computation uses the output delta (dy) to generate the input deltas (dxA, dxB), weight delta (dw) and bias delta (db) [as applicable]
     * In some cases the backward computation function also requires the forward pass input (x) and the forward pass output (y).
     * <p>
     * The following arguments are required for the backward computation:
     * out_delta descriptor (dy) are the gradients arriving from the following filter and must be provided.
     * in pointer is the forward pass input (x) and should be provided if not specified it is ignored
     * out pointer is the forward pass output (y) and should be provided if not specified it is ignored
     * <p>
     * The following gradients are generated by the backward computation.
     * in_delta  - the input delta (dx)
     * weights_delta - the weight delta (dw)
     * bias_delta - the bias delta (db)
     * NULL descriptor pointers will not be computed. data field of a valid descriptor must point to the delta buffer to be produced.
     * <p>
     * Important activation information:
     * For any general activation function, when computing activation layer backward, the forward pass input (x) to the activation is required.
     * However, in most activation functions, it is possible and faster to compute the activation backward from the forward pass output y.
     * In the case of fused computation and activation layers, it is mandatory to provide the forward pass output y.
     * Notice that some activation functions cannot be fused with the computation filters.
     * <p>
     * Activation backward functions that can accept either forward pass input or forward pass output (output is prefered):
     * BNNSActivationFunctionIdentity
     * BNNSActivationFunctionRectifiedLinear
     * BNNSActivationFunctionLeakyRectifiedLinear (if alpha >= 0.0)
     * BNNSActivationFunctionSigmoid
     * BNNSActivationFunctionLogSigmoid
     * BNNSActivationFunctionTanh
     * BNNSActivationFunctionLinear
     * BNNSActivationFunctionClamp
     * BNNSActivationFunctionSoftmax
     * BNNSActivationFunctionHardSigmoid
     * BNNSActivationFunctionSoftplus
     * BNNSActivationFunctionSoftsign
     * BNNSActivationFunctionELU
     * BNNSActivationFunctionSELU
     * BNNSActivationFunctionCELU
     * BNNSActivationFunctionClampedLeakyRectifiedLinear (if alpha >= 0.0)
     * BNNSActivationFunctionLinearWithBias
     * BNNSActivationFunctionLogSoftmax
     * BNNSActivationFunctionHardShrink
     * BNNSActivationFunctionSoftShrink
     * BNNSActivationFunctionTanhShrink
     * BNNSActivationFunctionThreshold
     * <p>
     * The activation functions above can be fused with computation in training, only if the forward pass output y is provided in backward apply.
     * <p>
     * Other activation functions require forward pass input and does not support fusing computation with activation, such as:
     * BNNSActivationFunctionAbs
     * BNNSActivationFunctionGELUApproximation
     * BNNSActivationFunctionGELUApproximation2
     * BNNSActivationFunctionSiLU
     * <p>
     * Additional requirements:
     * BNNSFlagsUseClientPtr flag must be enabled when creating the filter.
     * data_type of all descriptors must be BNNSDataTypeFloat32.
     *
     * @param filter           Filter to apply backward
     * @param batch_size       Number of (input, output) pairs to process
     * @param inA              Pointer to the forward pass input data (x)
     * @param inA_stride       Increment (in values) between inputs
     * @param inA_delta        Pointer to the input delta descriptor
     *                         - not produced if null
     * @param inA_delta_stride Increment (in values) between input deltas
     * @param inB              Pointer to the forward pass input data (x)
     * @param inB_stride       Increment (in values) between inputs
     * @param inB_delta        Pointer to the input delta descriptor
     *                         - not produced if null
     * @param inB_delta_stride Increment (in values) between input deltas
     * @param out              Pointer to the forward pass output data (y)
     * @param out_stride       Increment (in values) between outputs
     * @param out_delta        Pointer to the output delta descriptor (dy)
     * @param out_delta_stride Increment (in values) between output deltas
     * @param weights_delta    Pointer to the weights delta descriptor
     *                         - delta is aggregated across batch
     *                         - not produced if null
     *                         - computed weights_delta layout will match the filter weight layout that was provided at the creation of the filter
     * @param bias_delta       Pointer to the bias delta descriptor
     *                         - not produced if null
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFilterApplyBackwardTwoInputBatch(VoidPtr filter, @NUInt long batch_size,
            ConstVoidPtr inA, @NUInt long inA_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor inA_delta,
            @NUInt long inA_delta_stride, ConstVoidPtr inB, @NUInt long inB_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor inB_delta,
            @NUInt long inB_delta_stride, ConstVoidPtr out, @NUInt long out_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            @NUInt long out_delta_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor weights_delta,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor bias_delta);

    /**
     * Apply a normalization filter backward to generate input delta, beta delta and gamma delta
     * <p>
     * similar to BNNSFilterApplyBackwardBatch, but computing input delta, beta delta and gamma delta
     * It is mandatory to compute all active gradients in a single function call. computation of input delta is not required in case the filter is the first layer in the network
     *
     * @param filter           Filter to apply backward
     * @param batch_size       Number of (input, output) pairs to process
     * @param in_delta         Pointer to the input delta descriptor
     *                         - not produced if null
     * @param in_delta_stride  Increment (in values) between input deltas
     * @param out              Pointer to the forward pass output data (y)
     *                         - out is ignored if activation is BNNSActivationFunctionIdentity
     *                         - forward pass output must be provided in case of fused instance normalization and activation
     * @param out_stride       Increment (in values) between outputs
     * @param out_delta        Pointer to the output delta descriptor (dy)
     *                         - out delta may be modified in order to save memory allocations when computing fused activation backward
     * @param out_delta_stride Increment (in values) between output deltas
     * @param beta_delta       Pointer to the beta delta descriptor
     *                         - not produced if null
     * @param gamma_delta      Pointer to the gamma delta descriptor
     *                         - not produced if null
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSNormalizationFilterApplyBackwardBatch(VoidPtr filter, @NUInt long batch_size,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in_delta,
            @NUInt long in_delta_stride, ConstVoidPtr out, @NUInt long out_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            @NUInt long out_delta_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor beta_delta,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor gamma_delta);

    /**
     * Apply a fused filter backward to generate gradients.
     * <p>
     * similar to BNNSFilterApplyBackwardBatch, but computing gradients of an N layer fused filter.
     * It is mandatory to compute all active parameter delta in a single function call. computation of input delta is not required in case the fused filter is the first layer in the network
     *
     * @param filter           Filter to apply backward
     * @param batch_size       Number of (input, output) pairs to process
     * @param in               Pointer to the forward pass computation input data (x)
     * @param in_stride        Increment (in values) between inputs
     *                         - ignored when computing input delta or bias delta if the filter is not pooling
     * @param in_delta         Pointer to the computation input delta descriptor
     *                         - not produced if null
     * @param in_delta_stride  Increment (in values) between input deltas
     * @param out              Pointer to the forward pass output data (y)
     *                         - out is ignored if last filter activation is BNNSActivationFunctionIdentity
     * @param out_stride       Increment (in values) between outputs
     * @param out_delta        Pointer to the last filter output delta descriptor (dy)
     *                         - out delta may be modified to save memory when computing fused activation backward
     * @param out_delta_stride Increment (in values) between output deltas
     * @param delta_parameters a pointer to an array of parameter delta pointers
     *                         order of parameter must be first filter parameters followed by second filter parameters until reaching the last filter parameters
     *                         for each filter parameters, the parameter order must follow the same order as in the stand-alone filter backward apply api
     *                         all filter parameters must be provided, excluding input delta and output delta which are provided separately
     *                         null pointer must be used for each non active parameter
     *                         for example, if first filter is convolution and second filter is batchnorm, parameters could be extracted in the following way:
     *                         BNNSNDArrayDescriptor* weights_delta = delta_parameters[0]; //weight delta is the first convolution parameter in BNNSFilterApplyBackwardBatch
     *                         BNNSNDArrayDescriptor* bias_delta = delta_parameters[1];  //bias delta is the second convolution parameter in BNNSFilterApplyBackwardBatch
     *                         BNNSNDArrayDescriptor* beta_delta = delta_parameters[2]; //first batchnorm parameter in BNNSNormalizationFilterApplyBackwardBatch
     *                         BNNSNDArrayDescriptor* gamma_delta = delta_parameters[3]; //second batchnorm parameter in BNNSNormalizationFilterApplyBackwardBatch
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFusedFilterApplyBackwardBatch(VoidPtr filter, @NUInt long batch_size, ConstVoidPtr in,
            @NUInt long in_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in_delta,
            @NUInt long in_delta_stride, ConstVoidPtr out, @NUInt long out_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            @NUInt long out_delta_stride, Ptr<Ptr<BNNSNDArrayDescriptor>> delta_parameters);

    /**
     * Apply an arithmetic filter backward to generate input gradients
     * <p>
     * Compute gradients for all arithmetic operation inputs
     * It is mandatory to compute all input gradients in a single function call.
     * if inputs were pointing to a common address during forward computation (same input), gradients should also point to a common address (same gradient)
     * descriptors for output delta and input delta that are being processed in-place must exactly match. in-place descriptor types must also match in case batch size > 1.
     *
     * @param filter           Filter to apply
     * @param batch_size       Number of (input sets, output) pairs to process
     * @param number_of_inputs number of inputs for the arithmetic operation
     * @param in               pointer to an array of input pointers. in array size must be number_of_inputs.
     *                         - in may be NULL for arithmetic layers that support forward in-place processing
     * @param in_stride        pointer to an array of input strides, each stride is an Increment (in values) between inputs in the batch for a corresponding input in the in array.
     * @param in_delta         pointer to an array of input delta pointers. in array size must be number_of_inputs.
     * @param in_delta_stride  pointer to an array of input delta strides, each stride is an Increment (in values) between inputs deltas in the batch for a corresponding input in the in_delta array.
     * @param out              Pointer to the forward pass output data (y)
     *                         - forward pass output must be provided in case of fused arithmetic and activation
     *                         - out may not be provided when activation is BNNSActivationFunctionIdentity, but in some arithmetic functions, providing the forward output may speedup the backward compute.
     * @param out_stride       Increment (in values) between outputs
     * @param out_delta        Pointer to the output delta descriptor (dy)
     * @param out_delta_stride Increment (in values) between output deltas
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSArithmeticFilterApplyBackwardBatch(VoidPtr filter, @NUInt long batch_size,
            @NUInt long number_of_inputs, Ptr<ConstVoidPtr> in, ConstNUIntPtr in_stride,
            Ptr<Ptr<BNNSNDArrayDescriptor>> in_delta, ConstNUIntPtr in_delta_stride, ConstVoidPtr out,
            @NUInt long out_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            @NUInt long out_delta_stride);

    /**
     * Apply permute filter backward to generate input gradient
     * <p>
     * similar to BNNSFilterApplyBackwardBatch with only the necessary argument subset for permute.
     *
     * @param filter           Filter to apply
     * @param batch_size       Number of (input, output) pairs to process
     * @param in_delta         Pointer to the input delta descriptor
     * @param in_delta_stride  Increment (in values) between input deltas
     * @param out_delta        Pointer to the output delta descriptor
     * @param out_delta_stride Increment (in values) between output deltas
     */
    @Generated
    @CFunction
    public static native int BNNSPermuteFilterApplyBackwardBatch(VoidPtr filter, @NUInt long batch_size,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in_delta,
            @NUInt long in_delta_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            @NUInt long out_delta_stride);

    /**
     * Apply a loss filter to compute forward loss and loss gradient on a batch with several pairs of (input, labels)
     * <p>
     * The filter is applied for each of the <tt>batch_size</tt> inputs,labels and computes reduced loss and an optional loss gradient.
     * <tt>in</tt> (resp. <tt>out</tt>) is expected to point to <tt>batch_size</tt> times the input (resp. output) object size defined when the filter was created.
     * The function supports forward loss computation, and also backward loss without back propagation from output delta.
     * Input delta computation is an optimization that can be used if the loss layer is the last layer in the network.
     *
     * @param filter          Loss filter to apply
     * @param batch_size      Number of (input, labels) pairs to compute
     * @param in              Pointer to the input data
     * @param in_stride       Increment (in values) between inputs
     * @param labels          Pointer to the labels
     * @param labels_stride   Increment (in values) between labels
     * @param weights         optional loss computation weight
     * @param weights_size    weight size must be one of:
     *                        for softmax cross entropy:
     *                        0 results in no weight loss scaling.
     *                        1 results in same weight scaling for all samples in the batch.
     *                        batch_size results in different weight per each sample in the batch
     *                        for sigmoid cross enrtopy, mse and huber loss, weights_size must be one of:
     *                        0 results in no weight loss scaling.
     *                        1 results in same weight scaling for all samples in the batch.
     *                        batch_size*input_width results in different weight per each sample in the batch
     * @param out             Pointer to the computed loss. output size depand on loss function and reduction function.
     *                        Loss array expected to be consecutive in memory (in case loss is unreduced), such that the stride between loss of consecutive samples in the batch is 1.
     *                        if loss is reduced, out will be a single result.
     *                        for softmax cross entropy, if loss is unreduced, out should be large enough to contain batch_size consecutive loss results.
     *                        for sigmoid cross entropy unreduced loss, mse unreduced loss and huber unreduced loss, out should be large enough to contain batch_size*input_width consecutive loss results, where input_width is size[0] of the input descriptor.
     * @param in_delta        Pointer to the input delta descriptor
     *                        - not produced if null
     * @param in_delta_stride Increment (in values) between input deltas
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSLossFilterApplyBatch(VoidPtr filter, @NUInt long batch_size, ConstVoidPtr in,
            @NUInt long in_stride, ConstVoidPtr labels, @NUInt long labels_stride, ConstVoidPtr weights,
            @NUInt long weights_size, VoidPtr out,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in_delta,
            @NUInt long in_delta_stride);

    /**
     * Apply a loss filter backward to generate gradients.
     * <p>
     * The filter is applied for each of the <tt>batch_size</tt> inputs,labels and computes the backward loss gradient.
     * <tt>in</tt> (resp. <tt>out</tt>) is expected to point to <tt>batch_size</tt> times the input (resp. output) object size defined when the filter was created.
     * Note that if the loss layer is the last layer in the network, the BNNSLossFilterApplyBatch can be used to compute both forward and backward without back propagation from output delta.
     *
     * @param filter           Loss filter to apply
     * @param batch_size       Number of (input, labels) pairs to compute
     * @param in               Pointer to the input data
     * @param in_stride        Increment (in values) between inputs
     * @param in_delta         Pointer to the input delta descriptor
     * @param in_delta_stride  Increment (in values) between input deltas
     * @param labels           Pointer to the labels
     * @param labels_stride    Increment (in values) between labels
     * @param weights          optional loss computation weight
     * @param weights_size     weight size must be one of:
     *                         for softmax cross entropy:
     *                         0 results in no weight loss scaling.
     *                         1 results in same weight scaling for all samples in the batch.
     *                         batch_size results in different weight per each sample in the batch
     *                         for sigmoid cross enrtopy, mse and huber loss, weights_size must be one of:
     *                         0 results in no weight loss scaling.
     *                         1 results in same weight scaling for all samples in the batch.
     *                         batch_size*input_width results in different weight per each sample in the batch
     * @param out_delta        Pointer to the output delta descriptor
     * @param out_delta_stride Increment (in values) between output deltas
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSLossFilterApplyBackwardBatch(VoidPtr filter, @NUInt long batch_size, ConstVoidPtr in,
            @NUInt long in_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in_delta,
            @NUInt long in_delta_stride, ConstVoidPtr labels, @NUInt long labels_stride, ConstVoidPtr weights,
            @NUInt long weights_size,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            @NUInt long out_delta_stride);

    /**
     * Applies a previously created multihead attention layer backwards to obtain gradients
     * <p>
     * Two common cases are that query=key=value or query=key. In these cases the backpropogated gradient for these parameters
     * the gradient calculation is then the sum of the individual deltas. If any the pointers query_param_delta.target_desc.data,
     * key_param_delta.target_desc.data or value_param_delta.target_desc.data are equal to each other, the returned tensor will
     * be set correctly to the sum of the components.
     *
     * @param F                   Filter to apply created by a previous call to BNNSFilterCreateLayerMultiheadAttention()
     * @param batch_size          Number of inputs in batch
     * @param query               Pointer to data for query input matrix, layout as described by layer_params->query.target_desc
     * @param query_stride        Batch stride for query
     * @param query_param_delta   Pointer to data structure used to hold deltas for corresponding components. A NULL value
     *                            in a member's data component indicates that it should not be computed.
     *                            The value query_param_delta.target_desc.stride[2] is used as the batch stride for query_param_delta.target_desc.
     * @param key                 Pointer to data for key input matrix, layout as described by layer_params->key.target_desc
     * @param key_stride          Batch stride for key
     * @param key_mask            Mask applied to key for ignoring entries, layout as described in forward call.
     *                            No mask is applied if this pointer is NULL.
     * @param key_mask_stride     Batch stride for key_mask
     * @param key_param_delta     Pointer to data structure used to hold deltas for corresponding components. A NULL value
     *                            in a member's data component indicates that it should not be computed.
     *                            The value key_param_delta.target_desc.stride[2] is used as the batch stride for key_param_delta.target_desc.
     * @param value               Pointer to data for value input matrix, layout as described by layer_params->value.target_desc
     * @param value_stride        Batch stride for value
     * @param value_param_delta   Pointer to data structure used to hold deltas for corresponding components. A NULL value
     *                            in a member's data component indicates that it should not be computed.
     *                            The value value_param_delta.target_desc.stride[2] is used as the batch stride for value_param_delta.target_desc.
     * @param add_to_attention    Optional, a 2D tensor of shape target_length x source_length that is used as part of the mask function prior
     *                            to softmax in the attention calculation (the matrix X in the layer description). No matrix is added if this pointer is NULL.
     * @param output              Pointer to data for output matrix, , layout as described by layer_params->output.target_desc
     * @param output_stride       Batch stride for output.
     * @param output_param_delta  Pointer to data structure used to hold deltas for corresponding components. A NULL value
     *                            in a member's data component indicates that it should not be computed.
     *                            The value output_param_delta.target_desc.stride[2] is used as the batch stride for output_param_delta.target_desc.
     * @param backprop_cache_size Specifies the size of the array backprop_cache, in bytes. If 0, or backprop_cache is NULL,
     *                            backprop_cache is not accessed.
     * @param backprop_cache      Is used to store intermediate results that can be used to accelerate a future call to
     *                            BNNSApplyMultiheadAttentionBackward.
     * @param workspace_size      Specifies the size of the array workspace, in bytes.
     *                            If workspace_size is not-NULL but workspace is NULL, the recommended size for workspace_size
     *                            will be set, but not other calculations will be performed (except to set backprop_cache_size if requested).
     * @param workspace           Is used as a scratch buffer during the calculation.
     */
    @Generated
    @CFunction
    public static native int BNNSApplyMultiheadAttentionBackward(VoidPtr F, @NUInt long batch_size, ConstVoidPtr query,
            @NUInt long query_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSMHAProjectionParameters query_param_delta,
            ConstVoidPtr key, @NUInt long key_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor key_mask,
            @NUInt long key_mask_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSMHAProjectionParameters key_param_delta,
            ConstVoidPtr value, @NUInt long value_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSMHAProjectionParameters value_param_delta,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor add_to_attention,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor key_attn_bias_delta,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor value_attn_bias_delta,
            ConstVoidPtr output, @NUInt long output_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSMHAProjectionParameters output_param_delta,
            @NUInt long backprop_cache_size, VoidPtr backprop_cache, NUIntPtr workspace_size, VoidPtr workspace);

    /**
     * return the minimum bytes capacity of the training cache buffer (used to store intermediate results during the forward pass)
     *
     * @return minimum bytes capacity of the training cache buffer
     */
    @Generated
    @CFunction
    @NUInt
    public static native long BNNSComputeLSTMTrainingCacheCapacity(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersLSTM layer_params);

    /**
     * Direct Apply LSTM with training caching
     * <p>
     * compute LSTM forward and cache intermediate results to accelerate backward computation
     * - the user can query the minimum buffer size for training cache using BNNSComputeLSTMTrainingCacheCapacity
     * - training_cache_ptr == NULL means not to cache
     * - BNNS will return failure when training_cache_capacity is lower than the minimum bytes capacity of the training cache buffer that BNNSComputeLSTMTrainingCacheCapacity returned
     *
     * @param layer_params            - layer parameters
     * @param filter_params           - filter parameters
     * @param training_cache_ptr      - buffer to store intermediate results to accelerate backward computation. if Null, intermediate results aren't cached
     * @param training_cache_capacity - size in bytes of training_cache_ptr
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSDirectApplyLSTMBatchTrainingCaching(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersLSTM layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params,
            VoidPtr training_cache_ptr, @NUInt long training_cache_capacity);

    /**
     * Direct Apply an Activation/Conversion filter to several pairs of (input, output) data
     * <p>
     * equal to calling BNNSCreateActivation & BNNSFilterApplyBatch & BNNSDestroy
     *
     * @param layer_params  Layer parameters and input, weights, output, bias and activation descriptors
     *                      should set i_desc.data pointing to input data and o_desc.data pointing to output data
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @param batch_size    Number of (input, output) pairs to process
     * @param in_stride     Increment (in values) between inputs
     * @param out_stride    Increment (in values) between outputs
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSDirectApplyActivationBatch(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersActivation layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params,
            @NUInt long batch_size, @NUInt long in_stride, @NUInt long out_stride);

    /**
     * Copies the contents of one BNNSNDArrayDescriptor to another of the same shape.
     * <p>
     * Equivalent to using a contraction layer with opstring "src_* -> dest_*"
     *
     * @param dest The destination tensor
     * @param src  The source tensor - must not overlap in memory with the destination tensor
     */
    @Generated
    @CFunction
    public static native int BNNSCopy(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor dest,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor src,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Directly apply a broadcast matrix multiplication layer.
     * <p>
     * [@description]
     * Performs the same action as a broadcast matrix multiplication layer without instantiating a BNNSFilter.
     *
     * @param transA        - if true, transposes the last two dimensions of A
     * @param transB        - if true, transposes the last two dimensions of B
     * @param alpha         - scalar by which to scale the result
     * @param inputA        - descriptor for tensor A
     * @param inputB        - descriptor for tensor B
     * @param output        - descriptor for tensor C; on output only the data values are changed
     * @param filter_params - filter runtime parameters, may be NULL for default parameters
     */
    @Generated
    @CFunction
    public static native void BNNSDirectApplyBroadcastMatMul(boolean transA, boolean transB, float alpha,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor inputA,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor inputB,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor output,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Transposes a tensor by swapping two of its dimensions.
     * <p>
     * Users should consider whether a data transposition with memory copy (i.e. this operation) is required, or if the same effect can be
     * achieved by just switching layout in the descriptor of the same memory (e.g. for a 2D matrix can switching from row major to column
     * major storage satsify the requirements). Consideration will be needed for both whether individual layers support alternative data
     * layouts, and runtime performance.
     * <p>
     * This routine is not presented as a layer, but as a data manipulation. If deployed in a training scenario, observe that backpropagation
     * can be achieved by applying exactly the same operation to the output delta as was applied to the original input.
     * <p>
     * This operation is equivalent to using the TensorContraction layer with operation string similar to "x_*ij -> y_*ji", only with the appropriate
     * axes represented for the transposition.
     * <p>
     * In place operation is NOT supported.
     *
     * @param dest          Descriptor for the destination tensor
     * @param src           Descriptor for the source tensor
     * @param axis0         First axis of transposition
     * @param axis1         Second axis of transposition
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     */
    @Generated
    @CFunction
    public static native int BNNSTranspose(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor dest,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor src,
            @NUInt long axis0, @NUInt long axis1,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Apply Reduction on selected axis
     *
     * @param layer_params  Layer parameters: input descriptor, output descriptor, reduce function and epsilon
     *                      need to set the pointers:
     *                      layer_params.i_desc.data - pointer to input buffer
     *                      layer_params.o_desc.data - pointer to output buffer
     *                      layer_params.w_desc.data - pointer to weights buffer (set to NULL if not needed)
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSDirectApplyReduction(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersReduction layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * create and return a new tensor of bool type by comparing two input tensors
     * <p>
     * compare two input tensors and generate a tensor of bool type containing the results of element-by-element comparison
     *
     * @param in0 pointer to the tensor descriptor of type BNNSNDArrayDescriptor for comparison/logical operations - left side of the operator
     * @param in1 pointer to the tensor descriptor of type BNNSNDArrayDescriptor for comparison/logical operations - right side of the operator
     * @param op  type of comparison in BNNSRelationalOperator type
     * @param out pointer to the tensor descriptor of type BNNSNDArrayDescriptor for the output of comparison.
     *            The active dimensions should match those of inA/inB, and the type should be BNNSDataTypeBoolean8.
     * @return the error code of the processing - error only if I/O tensor descriptors have invalid or mismatching information
     */
    @Generated
    @CFunction
    public static native int BNNSCompareTensor(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in0,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in1, int op,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out);

    /**
     * Returns top K values
     * <p>
     * Returns a sparse vector of the top K entries from the input.
     * In the case of ties that span the top-K boundary, only the lexigraphically first entries will be returned.
     *
     * @param K                         Number of entries to find
     * @param axis                      Axis along which to find top K entries
     * @param batch_size                Number of batches
     * @param input                     The input tensor
     * @param input_batch_stride        The batch stride for input.data
     * @param best_values               Descriptor of a K-length vector. On return contains the K best values in descending order.
     * @param best_values_batch_stride  The batch stride for best_values
     * @param best_indices              Descriptor of a K-length vector. On return contains the indices of the K best values in descending order.
     * @param best_indices_batch_stride The batch stride in size_t elements for best_indices
     * @param filter_params             Filter runtime parameters, may be NULL for default parameters
     * @return Zero on success, non-zero on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSDirectApplyTopK(@NUInt long K, @NUInt long axis, @NUInt long batch_size,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor input,
            @NUInt long input_batch_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor best_values,
            @NUInt long best_values_batch_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor best_indices,
            @NUInt long best_indices_batch_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Given a tensor index for each member of a batch, returns a boolean vector indicating whether each index
     * corresponds to a top-k value of the input.
     * <p>
     * Consider the 4x4 tensor in a batch size of 3:
     * X(:,:,0) = [ 1 3 5 7 ]         X(:,:,1) = [ 1 8 3 4 ]         X(:,:,2) = [ 4 8 7 7 ]
     * [ 2 5 1 9 ]                       [ 8 1 3 5 ]                        [ 4 3 8 5 ]
     * [ 1 5 3 2 ]                       [ 1 7 2 3 ]                        [ 5 7 3 1 ]
     * and the test indices:
     * T(:, 0) = (0, 3, 1)
     * T(:, 1) = (2, 2, 0)
     * T(:, 2) = (3, 2, 1)
     * with K= 2 and axis=1, the result would be:
     * (F, F, T)      from comparing values (1, 1, 5) against the top K sets (5, 7), (5, 9), (3,5) in the first batch
     * (F, F, F)      from comparing values (3, 3, 1) against the top K set (4, 8), (5, 8), (3,7) in the second batch
     * (T, T, T)      from comparing values (7, 8, 7) against the top K set (7, 8), (5, 8), (5, 7) in the third batch
     * Observe that in the case of ties, all possible entries are included in the top K.
     *
     * @param K                         Number of entries to find
     * @param axis                      Axis along which to find top K entries
     * @param batch_size                Number of batches
     * @param input                     The input tensor
     * @param input_batch_stride        The batch stride for input.data
     * @param test_indices              Test index tensor, shape must match that of input, with the given axis removed
     * @param test_indices_batch_stride The batch stride for test_indices.data
     * @param output                    The boolean output tensor
     * @param output_batch_stride       The batch stride for output.data, of shape matching test_indices
     * @param filter_params             Filter runtime parameters, may be NULL for default parameters
     * @return Zero on success, non-zero on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSDirectApplyInTopK(@NUInt long K, @NUInt long axis, @NUInt long batch_size,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor input,
            @NUInt long input_batch_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor test_indices,
            @NUInt long test_indices_batch_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor output,
            @NUInt long output_batch_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Direct Apply LSTM with training caching
     * <p>
     * compute LSTM backward
     *
     * @param layer_params            - layer parameters
     * @param layer_delta_params      - layer delta parameters (include inputs & outputs for backward)
     * @param filter_params           - filter parameters
     * @param training_cache_ptr      - buffer with intermediate results to accelerate backward computation. if Null, intermediate results weren't cached and forward pass will be recomupted
     * @param training_cache_capacity - size in bytes of training_cache_ptr. return failure when training_cache_capacity is lower than the minimum bytes capacity of the training cache
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSDirectApplyLSTMBatchBackward(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersLSTM layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersLSTM layer_delta_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params,
            ConstVoidPtr training_cache_ptr, @NUInt long training_cache_capacity);

    /**
     * Get NDArray descriptor containing reference to filter data member
     * <p>
     * Some filters have potentially trainiable parameters embedded in the filter structure (for example activation layers often have an alpha or beta parameter).
     * To facilitate training or otherwise modifying these parameters after layer creation, we provide the following function.
     * Note that the pointer is only valid until the BNNSFilter is destroyed, and that care must be taken if the filter is used on multiple threads.
     * <p>
     * [@returns] On success, a BNNSNDArrayDescriptor describing the requested parameter.
     * On failure, a BNNSNDArrayDescriptor with data member set to NULL.
     *
     * @param filter Filter to obtain pointer into
     * @param target enum specifying what a pointer is required to
     */
    @Generated
    @CFunction
    @ByValue
    public static native BNNSNDArrayDescriptor BNNSGetPointer(VoidPtr filter, int target);

    /**
     * [@function] vImageSepConvolve_Planar8
     * <p>
     * Separable convolution on a Planar8 image.
     * <p>
     * This filter applies two separate 1D filters along the rows and columns of
     * a Planar8 image.
     * <p>
     * For each pixel:
     * <pre>@textblock
     *         for each pixel[y][x] in image {
     *             float sum = bias;
     *
     *             // Calculate weighted average over kernel area
     *             for each kernelY_element[i] in kernelY {
     *                 for each kernelX_element[j] in kernelX {
     *                 sum += kernelY_element[i] * kernelX_element[j] *
     *                         pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                              [x+j+srcOffsetToROI_X- kernel_width/2];
     *                 }
     *             }
     *             // Add 0.5 to round to nearest int when converting float to uint8_t
     *             sum = sum + 0.5f;
     *
     *             // write out result
     *             result[y][x] = (uint8_t)CLAMP(sum, 0, 255);
     *         }
     *     @/textblock </pre>
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernelX          A pointer to a 1D array of weights of dimension kernelX_width.
     *                         For example, for a simple 3x3 Sobel x-derivative filter it's {-1.0, 0.0, 1.0}.
     * @param kernelX_width    The width of the 1D array of weights passed in as kernelX. It must be an odd number.
     * @param kernelY          A pointer to a 1D array of weights of dimension kernelY_width.
     *                         For example, for a simple 3x3 Sobel x-derivative filter it's {1.0, 2.0, 1.0}.
     * @param kernelY_width    The width of the 1D array of weights passed in as kernelY. It must be an odd number.
     * @param bias             This value is added to the sum of weighted pixels.
     *                         You might provide a bias of 128 to move the encoding for 0 to 128 so that
     *                         negative numbers are representable, such as Sobel derivative filters.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageNullPointerArgument  kernel may not be NULL
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel sizes must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageSepConvolve_Planar8(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernelX, int kernelX_width,
            ConstFloatPtr kernelY, int kernelY_width, float bias, char backgroundColor, int flags);

    /**
     * [@function] vImageSepConvolve_PlanarF
     * <p>
     * Separable convolution on a PlanarF image.
     * <p>
     * This filter applies two separate 1D filters along the rows and columns of
     * a PlanarF image.
     * <p>
     * For each pixel:
     * <pre>@textblock
     *         for each pixel[y][x] in image {
     *             float sum = bias;
     *
     *             // Calculate weighted average over kernel area
     *             for each kernelY_element[i] in kernelY {
     *                 for each kernelX_element[j] in kernelX {
     *                 sum += kernelY_element[i] * kernelX_element[j] *
     *                         pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                              [x+j+srcOffsetToROI_X- kernel_width/2];
     *                 }
     *             }
     *
     *             // write out result
     *             result[y][x] = sum;
     *         }
     *     @/textblock </pre>
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernelX          A pointer to a 1D array of weights of dimension kernelX_width.
     * @param kernelX_width    The width of the 1D array of weights passed in as kernelX. It must be an odd number.
     * @param kernelY          A pointer to a 1D array of weights of dimension kernelY_width.
     * @param kernelY_width    The width of the 1D array of weights passed in as kernelY. It must be an odd number.
     * @param bias             This value is added to the sum of weighted pixels.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageNullPointerArgument  kernel may not be NULL
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel sizes must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageSepConvolve_PlanarF(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernelX, int kernelX_width,
            ConstFloatPtr kernelY, int kernelY_width, float bias, float backgroundColor, int flags);

    /**
     * [@function] vImageSepConvolve_Planar16U
     * <p>
     * Separable convolution on a Planar16U image.
     * <p>
     * This filter applies two separate 1D filters along the rows and columns of
     * a Planar16U image.
     * <p>
     * For each pixel:
     * <pre>@textblock
     *         for each pixel[y][x] in image {
     *             float sum = bias;
     *
     *             // Calculate weighted average over kernel area
     *             for each kernelY_element[i] in kernelY {
     *                 for each kernelX_element[j] in kernelX {
     *                 sum += kernelY_element[i] * kernelX_element[j] *
     *                         pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                              [x+j+srcOffsetToROI_X- kernel_width/2];
     *                 }
     *             }
     *             // Add 0.5 to round to nearest int when converting float to uint16_t
     *             sum = sum + 0.5f;
     *
     *             // write out result
     *             result[y][x] = (uint16_t)CLAMP(sum, 0, 65535);
     *         }
     *     @/textblock </pre>
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernelX          A pointer to a 1D array of weights of dimension kernelX_width.
     * @param kernelX_width    The width of the 1D array of weights passed in as kernelX. It must be an odd number.
     * @param kernelY          A pointer to a 1D array of weights of dimension kernelY_width.
     * @param kernelY_width    The width of the 1D array of weights passed in as kernelY. It must be an odd number.
     * @param bias             This value is added to the sum of weighted pixels.
     *                         You might provide a bias of 2 ** 15 = 32768 to move the encoding so that
     *                         negative numbers are representable.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageNullPointerArgument  kernel may not be NULL
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel sizes must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageSepConvolve_Planar16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernelX, int kernelX_width,
            ConstFloatPtr kernelY, int kernelY_width, float bias, char backgroundColor, int flags);

    /**
     * [@function] vImageSepConvolve_Planar8to16U
     * <p>
     * Separable convolution on a Planar8 image.
     * <p>
     * This filter applies two separate 1D filters along the rows and columns of
     * a Planar8 source image and writing the result to a Planar16U destination image.
     * Both a bias and scale factor can be specified to control the range of the result.
     * <p>
     * For each pixel:
     * <pre>@textblock
     *         for each pixel[y][x] in image {
     *             float sum = 0.0f;
     *
     *             // Calculate weighted average over kernel area
     *             for each kernelY_element[i] in kernelY {
     *                 for each kernelX_element[j] in kernelX {
     *                 sum += kernelY_element[i] * kernelX_element[j] *
     *                         pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
     *                              [x+j+srcOffsetToROI_X- kernel_width/2];
     *                 }
     *             }
     *             // Scale sum and add bias and 0.5 to round float to uint16_t
     *             sum = scale * sum + bias + 0.5f;
     *
     *             // write out result
     *             result[y][x] = (uint16_t)CLAMP(sum, 0, 65535);
     *         }
     *     @/textblock </pre>
     * <p>
     * This filter does not work in place.
     *
     * @param src              The input image
     * @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
     *                         This may not alias the src image.
     * @param tempBuffer       An optional pointer to a region of memory to use as a working area during
     *                         computation.  The size of the tempBuffer is given by calling the function
     *                         with the same parameters and the kvImageGetTempBufferSize flag, in which case
     *                         the size is returned instead of an error code from the left hand side.
     *                         You may pass NULL here, in which case a region of memory of similar size
     *                         will be allocated by the function and freed before it returns.  Temp Buffers
     *                         are a way of avoiding lost time due to VM faults to initialize newly allocated
     *                         buffers. If you will be calling this function repeatedly with similar parameters
     *                         you should use a temp buffer. If the function is called from different threads
     *                         concurrently, a different temp buffer should be used for each.
     * @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the left edge of the image.
     * @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
     *                         relative to the src image. Typically this is 0. Non-Zero values are needed
     *                         when the destination tile is not aligned with the top edge of the image.
     * @param kernelX          A pointer to a 1D array of weights of dimension kernelX_width.
     * @param kernelX_width    The width of the 1D array of weights passed in as kernelX. It must be an odd number.
     * @param kernelY          A pointer to a 1D array of weights of dimension kernelY_width.
     * @param kernelY_width    The width of the 1D array of weights passed in as kernelY. It must be an odd number.
     * @param scale            This value is multiplied with the sum of weighted pixels, before the bias
     *                         is applied. For example, for normalized kernels, where the weights add to 1.0,
     *                         specifying a scale of 257 ( = 65535 / 255 ) would expand the 8-bit input
     *                         range to a full 16-bit output range.
     * @param bias             This value is added to the sum of weighted pixels.
     * @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
     *                         parameter provides the background color to be used for missing pixels when the
     *                         kernel extends off the edge of the image.
     * @param flags            The following flags are allowed:
     *                         <pre>@textblock
     *                                     kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
     *                                                                 copy the corresponding source pixel to the destination. This
     *                                                                 will result in a ring off unconvolved content at the edges
     *                                                                 and convolved content in the middle.
     *
     *                                     kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
     *                                                                 For a blur filter this will look like the edges of the image
     *                                                                 have been blurred into a particular color. This is usually
     *                                                                 appropriate when the color of the surface onto which the image
     *                                                                 will be drawn is known.  You can also use {Alpha = 0, color = 0}
     *                                                                 as a background color, and let the downstream image compositor
     *                                                                 blend in the background color. In this case, the result image
     *                                                                 should be treated as a premultiplied image.
     *
     *                                     kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
     *                                                                 This is better when the image is drawn into a frame or other
     *                                                                 context where the background is not expected to contribute to
     *                                                                 the final content.
     *
     *                                     kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
     *                                                                 simply ignored, and the bias and divisor are adjusted accordingly.
     *                                                                 Because of the complication at the edges, this edging mode can
     *                                                                 be significantly slower than the others. It can be numerically
     *                                                                 unstable if the sum over any rectangular subsection of the kernel
     *                                                                 is zero, which can result in division by zero during the computation.
     *                                                                 The results for this edging mode are usually quite visually similar
     *                                                                 to kvImageEdgeExtend.
     *
     *                                     kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
     *                                                                 size of the temp buffer needed for this set of parameters. Does
     *                                                                 not touch the src or dest image.
     *
     *                                     kvImageDoNotTile            Disable internal multithreading.
     *
     *                             @/textblock </pre>
     *                         The first four flags listed are edging modes. One and only one edging mode must be
     *                         provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
     *                         be returned.
     * @return One of the following error codes may be returned:
     * <pre>@textblock
     *         kvImageNoError              Success.
     *             >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
     *                                     the temp buffer to use with this function and this set of
     *                                     parameters.
     *
     *         kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
     *                                        { kvImageCopyInPlace, kvImageBackgroundColorFill,
     *                                          kvImageEdgeExtend,  kvImageTruncateKernel }
     *
     *         kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
     *                                         to corresponding dimensions of the source buffer.
     *
     *         kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
     *
     *         kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
     *
     *         kvImageNullPointerArgument  kernel may not be NULL
     *
     *         kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
     *
     *         kvImageInvalidKernelSize    The kernel sizes must be odd numbers.
     *     @/textblock </pre>
     */
    @Generated
    @CFunction
    @NInt
    public static native long vImageSepConvolve_Planar8to16U(
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer src,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_Buffer dest, VoidPtr tempBuffer,
            @NUInt long srcOffsetToROI_X, @NUInt long srcOffsetToROI_Y, ConstFloatPtr kernelX, int kernelX_width,
            ConstFloatPtr kernelY, int kernelY_width, float scale, float bias, byte backgroundColor, int flags);

    /**
     * [@function] vImageConverter_CreateWithCGColorConversionInfo
     * <p>
     * Create a vImageConverterRef substituting in CGColorConversionInfo for the one vImage usually generates for the color conversion steps.
     * <p>
     * vImageConverter_CreateWithCGColorConversionInfo is like vImageConverter_CreateWithCGImageFormat, except that
     * instead of creating its own colorspace transform for any colorspace conversions, it uses the one you pass in through CGColorConversionInfo.
     * This gives you greater control over the fine details of colorspace conversion, for exacting color fidelity.
     * The colorspaces for source and destination images must refer to colorspaces that have the same number of channels
     * as the codeFragment is designed to accept / produce.
     * <p>
     * See Apple Sample Code "Converting an Image with Black Point Compensation" https://developer.apple.com/library/mac/samplecode/convertImage/Introduction/Intro.html
     * for an example of usage.
     *
     * @param colorConversionInfoRef CGColorConversionInfo described in CGColorConversionInfo.h
     * @param srcFormat              A pointer to a populated vImage_CGImageFormat struct describing the image format
     *                               of the source image. CGColorSpaceRef will be ignored since vImage will get color space conversion
     *                               information through CGColorConversionInfo.
     * @param destFormat             A pointer to a populated vImage_CGImageFormat struct describing the image format
     *                               of the destination image. CGColorSpaceRef will be ignored since vImage will get color space conversion
     *                               information through CGColorConversionInfo.
     * @param backgroundColor        Points to an array of floats to be used as a background color if one is needed. The
     *                               backgroundColor range is assumed to be [0,1]. The channel ordering and number of color
     *                               channels must match the natural order of the destination colorSpace (e.g. RGB or CMYK).
     *                               The backgroundColor may be NULL if no background color is needed.
     *                               <p>
     *                               A background color is used when the image is converted from an alpha-containing format
     *                               to an alpha-none format, in which case the alpha is removed by compositing against the
     *                               opaque background color pointed to by this parameter. If the image is instead converted
     *                               from one alpha containing format to another, then the image will be premultiplied or
     *                               unpremultiplied as necessary and no background color is necessary. (For unpremultiplication,
     *                               the result color value for pixels with alpha 0 is 0.)  Likewise, when converting between
     *                               alpha-none formats, a background color is not use. In the case of kCGImageAlphaNone ->
     *                               kCGImageAlphaNoneSkipFirst/Last, the vacant alpha channel is filled in with 1.0. If NULL
     *                               is passed here, then 0 will be used for the color channels.
     *                               <p>
     *                               The vImageConverter will contain a copy of the data passed in this field.
     * @param flags                  Any of the following flags are allowed:
     *
     *                               <pre>@textblock
     *                                         kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug
     *                                                                             messages.
     *
     *                                         kvImageDoNotTile                    A converter created with this flag will operate as if
     *                                                                             kvImageDoNotTile was passed to vImageConvert_AnyToAny
     *                                                                             whether it was or not.
     *                                @/textblock </pre>
     * @param error                  May be NULL.  If not NULL, then a vImage_Error is returned at the address pointed to by error.
     *                               The vImage_Error will be less than 0 if an error condition occurred. Checking the vImageConverter
     *                               returned to make sure it is non-NULL is sufficient to verify success or failure of the function.
     *                               <p>
     *                               Some possible error values that can occur are :
     *                               <pre>@textblock
     *                                    kvImageNoError                      Success.
     *
     *                                    kvImageNullPointerArgument          srcFormat and/or destFormat is NULL.
     *
     *                                    kvImageUnknownFlagsBit              Currently only kvImagePrintDiagnosticsToConsole and kvImageDoNotTile are
     *                                                                                            allowed. All other bits in the flags field must be 0.
     *
     *                                    kvImageInvalidParameter             backgroundColor is NULL and the conversion needed a backgroundColor
     *
     *                                    kvImageInvalidImageFormat           The base colorspace must be grayscale for destination images using indexed color.
     *                                    kvImageInvalidImageFormat           The colorspace may be indexed color for images only if it is {1,2,4,8} bitsPerComponent
     *                                                                        and kCGImageAlphaNone.
     *                                    kvImageInvalidImageFormat           vImage_CGImageFormat.bitmapInfo & kCGBitmapAlphaInfoMask  does not encode a valid alpha
     *                                    kvImageInvalidImageFormat           floating point formats must be 16 or 32 bits per component. 16-bit floats are
     *                                                                        IEEE-754-2008 binary16 interchange format  (a.k.a. OpenEXR half float). 32-bit floats
     *                                                                        are the standard IEEE-754-2008 binary32 interchange format. (a.k.a float in C/C++/ObjC)
     *                                    kvImageInvalidImageFormat           format->renderingIntent is not a known value
     *                                    kvImageInvalidImageFormat           The conversion called for conversion to an input-only colorspace. Some color profiles
     *                                                                        (e.g. those arising from a scanner) are described as input only, because the device can
     *                                                                        not produce image output.
     *
     *                                    kvImageInvalidImageFormat           CGColorConversionInfo was found to be otherwise invalid / unusable
     *
     *                                    kvImageInternalError                The converter was unable to find a path from the source format to the destination format.
     *                                                                        This should not happen and indicates incorrect operation of the function. Please file a bug.
     *                                                                        The kvImagePrintDiagnosticsToConsole flag will provide additional diagnostic info.
     *                                @/textblock </pre>
     *                               <p>
     *                               In cases where the error code is not sufficient to quickly determine the problem, the kvImagePrintDiagnosticsToConsole flag
     *                               should provide additional diagnostic info.
     * @return A vImageConverter object with reference count of 1 is created. If the call fails due to an error, then NULL
     * will be returned. Use vImageConverter_Release to release your reference to it and allow the resources used
     * by the converter to be returned to the system.
     * <p>
     * If error is not NULL, an error code will be written to that address on return.
     */
    @Generated
    @CFunction
    public static native vImageConverterRef vImageConverter_CreateWithCGColorConversionInfo(
            CGColorConversionInfoRef colorConversionInfoRef,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat sFormat,
            @UncertainArgument("Options: reference, array Fallback: reference") vImage_CGImageFormat dFormat,
            ConstNFloatPtr bg, int flags, NIntPtr error);

    /**
     * vDSP_biquad_SetCoefficientsDouble will
     * update the filter coefficients within a valid vDSP_biquad_Setup object.
     * <p>
     * Coefficients are specified in double precision.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquad_SetCoefficientsDouble(vDSP_biquad_Setup __setup, ConstDoublePtr __coeffs,
            @NUInt long __start_sec, @NUInt long __nsec);

    /**
     * vDSP_biquad_SetCoefficientsSingle will
     * update the filter coefficients within a valid vDSP_biquad_Setup object.
     * <p>
     * Coefficients are specified in single precision.
     */
    @Generated
    @CFunction
    public static native void vDSP_biquad_SetCoefficientsSingle(vDSP_biquad_Setup __setup, ConstFloatPtr __coeffs,
            @NUInt long __start_sec, @NUInt long __nsec);

    /**
     * DFT setup routine for interleaved complex data, single-precision
     * <p>
     * This routine creates the required butterfly weight factors needed in the computation
     * of the interleaved complex number DFT of a specified length. It returns with the pointer
     * to the DFT setup, if the length is supported, or NULL otherwise.
     *
     * @param Previous      (input) Previous is either zero or a previous DFT_Interleaved setup
     * @param Length        (input) the number of complex elements to be transformed.
     * @param Direction     (input) Transform direction, vDSP_DFT_FORWARD or vDSP_DFT_INVERSE.
     * @param RealtoComplex (input) flag for real to complex transform, true or false.
     * @return a pointer to the requested DFT setup on success, or 0 if the Length is not supported,
     * or having other issues, such as memory allocation.
     */
    @Generated
    @CFunction
    public static native vDSP_DFT_Interleaved_Setup vDSP_DFT_Interleaved_CreateSetup(
            vDSP_DFT_Interleaved_Setup Previous, @NUInt long Length, int Direction, byte RealtoComplex);

    /**
     * DFT setup routine for interleaved complex data, double-precision
     * <p>
     * This routine creates the required butterfly weight factors needed in the computation
     * of the interleaved complex number DFT of a specified length. It returns with the pointer
     * to the DFT setup, if the length is supported, or NULL otherwise.
     *
     * @param Previous      (input) Previous is either zero or a previous DFT_Interleaved setup
     * @param Length        (input) the number of complex elements to be transformed.
     * @param Direction     (input) Transform direction, vDSP_DFT_FORWARD or vDSP_DFT_INVERSE.
     * @param RealtoComplex (input) flag for real to complex transform, true or false.
     * @return a pointer to the requested DFT setup on success, or 0 if the Length is not supported,
     * or having other issues, such as memory allocation.
     */
    @Generated
    @CFunction
    public static native vDSP_DFT_Interleaved_SetupD vDSP_DFT_Interleaved_CreateSetupD(
            vDSP_DFT_Interleaved_SetupD Previous, @NUInt long Length, int Direction, byte RealtoComplex);

    /**
     * DFT execution routine for real data, single-precision
     * <p>
     * This routine perform a DFT for real numbers, with the aid of previously created setup data.
     *
     * @param Setup (input) A setup object returned by a previous call to vDSP_DFT_Interleaved_CreateSetup
     * @param Iri   (input) Pointer to input data.
     * @param Ori   (input) Pointer to output data.
     */
    @Generated
    @CFunction
    public static native void vDSP_DFT_Interleaved_Execute(vDSP_DFT_Interleaved_Setup Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPComplex Iri,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPComplex Ori);

    /**
     * DFT execution routine for interleaved complex data, double-precision
     * <p>
     * This routine perform a DFT for interleaved complex numbers, with the aid of previously created setup data.
     *
     * @param Setup (input) A setup object returned by a previous call to vDSP_DFT_Interleaved_CreateSetupD
     * @param Iri   (input) Pointer to input data.
     * @param Ori   (input) Pointer to output data.
     */
    @Generated
    @CFunction
    public static native void vDSP_DFT_Interleaved_ExecuteD(vDSP_DFT_Interleaved_SetupD Setup,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleComplex Iri,
            @UncertainArgument("Options: reference, array Fallback: reference") DSPDoubleComplex Ori);

    /**
     * DFT destroy routine, single-precision
     * <p>
     * This routine releases the memory used by a setup object.
     *
     * @param Setup (input) A setup object vDSP_DFT_Interleaved_Setup,
     *              created by either vDSP_DFT_Interleaved_CreateSetup
     */
    @Generated
    @CFunction
    public static native void vDSP_DFT_Interleaved_DestroySetup(vDSP_DFT_Interleaved_Setup Setup);

    /**
     * DFT destroy routine, double-precision
     * <p>
     * This routine releases the memory used by a setup object.
     *
     * @param Setup (input) A setup object vDSP_DFT_Interleaved_SetupD,
     *              created by either vDSP_DFT_Interleaved_CreateSetupD
     */
    @Generated
    @CFunction
    public static native void vDSP_DFT_Interleaved_DestroySetupD(vDSP_DFT_Interleaved_SetupD Setup);

    /**
     * =====================================
     * Prototypes for level 1 BLAS functions
     * =====================================
     */
    @Generated
    @CFunction
    public static native int isamax_(IntPtr n, FloatPtr sx, IntPtr incx);

    @Generated
    @CFunction
    public static native int idamax_(IntPtr n, DoublePtr dx, IntPtr incx);

    @Generated
    @CFunction
    public static native int icamax_(IntPtr n, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native int izamax_(IntPtr n, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native double sasum_(IntPtr n, FloatPtr sx, IntPtr incx);

    @Generated
    @CFunction
    public static native double dasum_(IntPtr n, DoublePtr dx, IntPtr incx);

    @Generated
    @CFunction
    public static native double scasum_(IntPtr n, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native double dzasum_(IntPtr n, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native int saxpy_(IntPtr n, FloatPtr da, FloatPtr sx, IntPtr incx, FloatPtr sy, IntPtr incy);

    @Generated
    @CFunction
    public static native int daxpy_(IntPtr n, DoublePtr da, DoublePtr dx, IntPtr incx, DoublePtr dy, IntPtr incy);

    @Generated
    @CFunction
    public static native int caxpy_(IntPtr n, VoidPtr ca, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    @Generated
    @CFunction
    public static native int zaxpy_(IntPtr n, VoidPtr ca, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    @Generated
    @CFunction
    public static native int scopy_(IntPtr n, FloatPtr sx, IntPtr incx, FloatPtr sy, IntPtr incy);

    @Generated
    @CFunction
    public static native int dcopy_(IntPtr n, DoublePtr dx, IntPtr incx, DoublePtr dy, IntPtr incy);

    @Generated
    @CFunction
    public static native int ccopy_(IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    @Generated
    @CFunction
    public static native int zcopy_(IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    @Generated
    @CFunction
    public static native double sdot_(IntPtr n, FloatPtr sx, IntPtr incx, FloatPtr sy, IntPtr incy);

    @Generated
    @CFunction
    public static native double ddot_(IntPtr n, DoublePtr dx, IntPtr incx, DoublePtr dy, IntPtr incy);

    @Generated
    @CFunction
    public static native double sdsdot_(IntPtr n, FloatPtr sb, FloatPtr sx, IntPtr incx, FloatPtr sy, IntPtr incy);

    @Generated
    @CFunction
    public static native double dsdot_(IntPtr n, FloatPtr sx, IntPtr incx, FloatPtr sy, IntPtr incy);

    @Generated
    @CFunction
    public static native void cdotc_(VoidPtr ret_val, IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    @Generated
    @CFunction
    public static native void zdotc_(VoidPtr ret_val, IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    @Generated
    @CFunction
    public static native void cdotu_(VoidPtr ret_val, IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    @Generated
    @CFunction
    public static native void zdotu_(VoidPtr ret_val, IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    @Generated
    @CFunction
    public static native double snrm2_(IntPtr n, FloatPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native double dnrm2_(IntPtr n, DoublePtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native double scnrm2_(IntPtr n, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native double dznrm2_(IntPtr n, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native int srot_(IntPtr n, FloatPtr sx, IntPtr incx, FloatPtr sy, IntPtr incy, FloatPtr c,
            FloatPtr s);

    @Generated
    @CFunction
    public static native int drot_(IntPtr n, DoublePtr dx, IntPtr incx, DoublePtr dy, IntPtr incy, DoublePtr c,
            DoublePtr s);

    @Generated
    @CFunction
    public static native int csrot_(IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy, FloatPtr c, FloatPtr s);

    @Generated
    @CFunction
    public static native int zdrot_(IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy, DoublePtr c,
            DoublePtr s);

    @Generated
    @CFunction
    public static native int srotg_(FloatPtr sa, FloatPtr sb, FloatPtr c, FloatPtr s);

    @Generated
    @CFunction
    public static native int drotg_(DoublePtr da, DoublePtr db, DoublePtr c, DoublePtr s);

    @Generated
    @CFunction
    public static native int crotg_(VoidPtr ca, VoidPtr cb, FloatPtr c, VoidPtr cs);

    @Generated
    @CFunction
    public static native int zrotg_(VoidPtr ca, VoidPtr cb, DoublePtr c, VoidPtr cs);

    @Generated
    @CFunction
    public static native int srotm_(IntPtr n, FloatPtr sx, IntPtr incx, FloatPtr sy, IntPtr incy, FloatPtr param);

    @Generated
    @CFunction
    public static native int drotm_(IntPtr n, DoublePtr dx, IntPtr incx, DoublePtr dy, IntPtr incy, DoublePtr dparam);

    @Generated
    @CFunction
    public static native int srotmg_(FloatPtr sd1, FloatPtr sd2, FloatPtr sx1, FloatPtr sy1, FloatPtr param);

    @Generated
    @CFunction
    public static native int drotmg_(DoublePtr dd1, DoublePtr dd2, DoublePtr dx1, DoublePtr dy1, DoublePtr dparam);

    @Generated
    @CFunction
    public static native int sscal_(IntPtr n, FloatPtr sa, FloatPtr sx, IntPtr incx);

    @Generated
    @CFunction
    public static native int dscal_(IntPtr n, DoublePtr da, DoublePtr dx, IntPtr incx);

    @Generated
    @CFunction
    public static native int cscal_(IntPtr n, VoidPtr ca, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native int zscal_(IntPtr n, VoidPtr ca, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native int csscal_(IntPtr n, FloatPtr sa, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native int zdscal_(IntPtr n, DoublePtr sa, VoidPtr cx, IntPtr incx);

    @Generated
    @CFunction
    public static native int sswap_(IntPtr n, FloatPtr sx, IntPtr incx, FloatPtr sy, IntPtr incy);

    @Generated
    @CFunction
    public static native int dswap_(IntPtr n, DoublePtr dx, IntPtr incx, DoublePtr dy, IntPtr incy);

    @Generated
    @CFunction
    public static native int cswap_(IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    @Generated
    @CFunction
    public static native int zswap_(IntPtr n, VoidPtr cx, IntPtr incx, VoidPtr cy, IntPtr incy);

    /**
     * =====================================
     * Prototypes for level 2 BLAS functions
     * =====================================
     */
    @Generated
    @CFunction
    public static native int sgemv_(BytePtr trans, IntPtr m, IntPtr n, FloatPtr alpha, FloatPtr a, IntPtr lda,
            FloatPtr x, IntPtr incx, FloatPtr beta, FloatPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int dgemv_(BytePtr trans, IntPtr m, IntPtr n, DoublePtr alpha, DoublePtr a, IntPtr lda,
            DoublePtr x, IntPtr incx, DoublePtr beta, DoublePtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int cgemv_(BytePtr trans, IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr x,
            IntPtr incx, VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int zgemv_(BytePtr trans, IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr x,
            IntPtr incx, VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int sgbmv_(BytePtr trans, IntPtr m, IntPtr n, IntPtr kl, IntPtr ku, FloatPtr alpha, FloatPtr a,
            IntPtr lda, FloatPtr x, IntPtr incx, FloatPtr beta, FloatPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int dgbmv_(BytePtr trans, IntPtr m, IntPtr n, IntPtr kl, IntPtr ku, DoublePtr alpha,
            DoublePtr a, IntPtr lda, DoublePtr x, IntPtr incx, DoublePtr beta, DoublePtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int cgbmv_(BytePtr trans, IntPtr m, IntPtr n, IntPtr kl, IntPtr ku, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr x, IntPtr incx, VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int zgbmv_(BytePtr trans, IntPtr m, IntPtr n, IntPtr kl, IntPtr ku, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr x, IntPtr incx, VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int ssymv_(BytePtr uplo, IntPtr n, FloatPtr alpha, FloatPtr a, IntPtr lda, FloatPtr x,
            IntPtr incx, FloatPtr beta, FloatPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int dsymv_(BytePtr uplo, IntPtr n, DoublePtr alpha, DoublePtr a, IntPtr lda, DoublePtr x,
            IntPtr incx, DoublePtr beta, DoublePtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int chemv_(BytePtr uplo, IntPtr n, VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr x,
            IntPtr incx, VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int zhemv_(BytePtr uplo, IntPtr n, VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr x,
            IntPtr incx, VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int ssbmv_(BytePtr uplo, IntPtr n, IntPtr k, FloatPtr alpha, FloatPtr a, IntPtr lda,
            FloatPtr x, IntPtr incx, FloatPtr beta, FloatPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int dsbmv_(BytePtr uplo, IntPtr n, IntPtr k, DoublePtr alpha, DoublePtr a, IntPtr lda,
            DoublePtr x, IntPtr incx, DoublePtr beta, DoublePtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int chbmv_(BytePtr uplo, IntPtr n, IntPtr k, VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr x,
            IntPtr incx, VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int zhbmv_(BytePtr uplo, IntPtr n, IntPtr k, VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr x,
            IntPtr incx, VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int sspmv_(BytePtr uplo, IntPtr n, FloatPtr alpha, FloatPtr ap, FloatPtr x, IntPtr incx,
            FloatPtr beta, FloatPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int dspmv_(BytePtr uplo, IntPtr n, DoublePtr alpha, DoublePtr ap, DoublePtr x, IntPtr incx,
            DoublePtr beta, DoublePtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int chpmv_(BytePtr uplo, IntPtr n, VoidPtr alpha, VoidPtr ap, VoidPtr x, IntPtr incx,
            VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int zhpmv_(BytePtr uplo, IntPtr n, VoidPtr alpha, VoidPtr ap, VoidPtr x, IntPtr incx,
            VoidPtr beta, VoidPtr y, IntPtr incy);

    @Generated
    @CFunction
    public static native int strmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, FloatPtr a, IntPtr lda,
            FloatPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int dtrmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, DoublePtr a, IntPtr lda,
            DoublePtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int ctrmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, VoidPtr a, IntPtr lda,
            VoidPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int ztrmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, VoidPtr a, IntPtr lda,
            VoidPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int stbmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, IntPtr k, FloatPtr a,
            IntPtr lda, FloatPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int dtbmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, IntPtr k, DoublePtr a,
            IntPtr lda, DoublePtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int ctbmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, IntPtr k, VoidPtr a,
            IntPtr lda, VoidPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int ztbmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, IntPtr k, VoidPtr a,
            IntPtr lda, VoidPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int stpmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, FloatPtr ap, FloatPtr x,
            IntPtr incx);

    @Generated
    @CFunction
    public static native int dtpmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, DoublePtr ap, DoublePtr x,
            IntPtr incx);

    @Generated
    @CFunction
    public static native int ctpmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, VoidPtr ap, VoidPtr x,
            IntPtr incx);

    @Generated
    @CFunction
    public static native int ztpmv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, VoidPtr ap, VoidPtr x,
            IntPtr incx);

    @Generated
    @CFunction
    public static native int strsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, FloatPtr a, IntPtr lda,
            FloatPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int dtrsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, DoublePtr a, IntPtr lda,
            DoublePtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int ctrsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, VoidPtr a, IntPtr lda,
            VoidPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int ztrsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, VoidPtr a, IntPtr lda,
            VoidPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int stbsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, IntPtr k, FloatPtr a,
            IntPtr lda, FloatPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int dtbsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, IntPtr k, DoublePtr a,
            IntPtr lda, DoublePtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int ctbsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, IntPtr k, VoidPtr a,
            IntPtr lda, VoidPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int ztbsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, IntPtr k, VoidPtr a,
            IntPtr lda, VoidPtr x, IntPtr incx);

    @Generated
    @CFunction
    public static native int stpsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, FloatPtr ap, FloatPtr x,
            IntPtr incx);

    @Generated
    @CFunction
    public static native int dtpsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, DoublePtr ap, DoublePtr x,
            IntPtr incx);

    @Generated
    @CFunction
    public static native int ctpsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, VoidPtr ap, VoidPtr x,
            IntPtr incx);

    @Generated
    @CFunction
    public static native int ztpsv_(BytePtr uplo, BytePtr trans, BytePtr diag, IntPtr n, VoidPtr ap, VoidPtr x,
            IntPtr incx);

    @Generated
    @CFunction
    public static native int sger_(IntPtr m, IntPtr n, FloatPtr alpha, FloatPtr x, IntPtr incx, FloatPtr y, IntPtr incy,
            FloatPtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int dger_(IntPtr m, IntPtr n, DoublePtr alpha, DoublePtr x, IntPtr incx, DoublePtr y,
            IntPtr incy, DoublePtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int cgerc_(IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr x, IntPtr incx, VoidPtr y, IntPtr incy,
            VoidPtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int zgerc_(IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr x, IntPtr incx, VoidPtr y, IntPtr incy,
            VoidPtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int cgeru_(IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr x, IntPtr incx, VoidPtr y, IntPtr incy,
            VoidPtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int zgeru_(IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr x, IntPtr incx, VoidPtr y, IntPtr incy,
            VoidPtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int ssyr_(BytePtr uplo, IntPtr n, FloatPtr alpha, FloatPtr x, IntPtr incx, FloatPtr a,
            IntPtr lda);

    @Generated
    @CFunction
    public static native int dsyr_(BytePtr uplo, IntPtr n, DoublePtr alpha, DoublePtr x, IntPtr incx, DoublePtr a,
            IntPtr lda);

    @Generated
    @CFunction
    public static native int cher_(BytePtr uplo, IntPtr n, FloatPtr alpha, VoidPtr x, IntPtr incx, VoidPtr a,
            IntPtr lda);

    @Generated
    @CFunction
    public static native int zher_(BytePtr uplo, IntPtr n, DoublePtr alpha, VoidPtr x, IntPtr incx, VoidPtr a,
            IntPtr lda);

    @Generated
    @CFunction
    public static native int ssyr2_(BytePtr uplo, IntPtr n, FloatPtr alpha, FloatPtr x, IntPtr incx, FloatPtr y,
            IntPtr incy, FloatPtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int dsyr2_(BytePtr uplo, IntPtr n, DoublePtr alpha, DoublePtr x, IntPtr incx, DoublePtr y,
            IntPtr incy, DoublePtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int cher2_(BytePtr uplo, IntPtr n, VoidPtr alpha, VoidPtr x, IntPtr incx, VoidPtr y,
            IntPtr incy, VoidPtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int zher2_(BytePtr uplo, IntPtr n, VoidPtr alpha, VoidPtr x, IntPtr incx, VoidPtr y,
            IntPtr incy, VoidPtr a, IntPtr lda);

    @Generated
    @CFunction
    public static native int sspr_(BytePtr uplo, IntPtr n, FloatPtr alpha, FloatPtr x, IntPtr incx, FloatPtr ap);

    @Generated
    @CFunction
    public static native int dspr_(BytePtr uplo, IntPtr n, DoublePtr alpha, DoublePtr x, IntPtr incx, DoublePtr ap);

    @Generated
    @CFunction
    public static native int chpr_(BytePtr uplo, IntPtr n, FloatPtr alpha, VoidPtr x, IntPtr incx, VoidPtr ap);

    @Generated
    @CFunction
    public static native int zhpr_(BytePtr uplo, IntPtr n, DoublePtr alpha, VoidPtr x, IntPtr incx, VoidPtr ap);

    @Generated
    @CFunction
    public static native int sspr2_(BytePtr uplo, IntPtr n, FloatPtr alpha, FloatPtr x, IntPtr incx, FloatPtr y,
            IntPtr incy, FloatPtr ap);

    @Generated
    @CFunction
    public static native int dspr2_(BytePtr uplo, IntPtr n, DoublePtr alpha, DoublePtr x, IntPtr incx, DoublePtr y,
            IntPtr incy, DoublePtr ap);

    @Generated
    @CFunction
    public static native int chpr2_(BytePtr uplo, IntPtr n, VoidPtr alpha, VoidPtr x, IntPtr incx, VoidPtr y,
            IntPtr incy, VoidPtr ap);

    @Generated
    @CFunction
    public static native int zhpr2_(BytePtr uplo, IntPtr n, VoidPtr alpha, VoidPtr x, IntPtr incx, VoidPtr y,
            IntPtr incy, VoidPtr ap);

    /**
     * =====================================
     * Prototypes for level 3 BLAS functions
     * =====================================
     */
    @Generated
    @CFunction
    public static native int sgemm_(BytePtr transa, BytePtr transb, IntPtr m, IntPtr n, IntPtr k, FloatPtr alpha,
            FloatPtr a, IntPtr lda, FloatPtr b, IntPtr ldb, FloatPtr beta, FloatPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int dgemm_(BytePtr transa, BytePtr transb, IntPtr m, IntPtr n, IntPtr k, DoublePtr alpha,
            DoublePtr a, IntPtr lda, DoublePtr b, IntPtr ldb, DoublePtr beta, DoublePtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int cgemm_(BytePtr transa, BytePtr transb, IntPtr m, IntPtr n, IntPtr k, VoidPtr alpha,
            VoidPtr a, IntPtr lda, VoidPtr b, IntPtr ldb, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int zgemm_(BytePtr transa, BytePtr transb, IntPtr m, IntPtr n, IntPtr k, VoidPtr alpha,
            VoidPtr a, IntPtr lda, VoidPtr b, IntPtr ldb, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int ssymm_(BytePtr side, BytePtr uplo, IntPtr m, IntPtr n, FloatPtr alpha, FloatPtr a,
            IntPtr lda, FloatPtr b, IntPtr ldb, FloatPtr beta, FloatPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int dsymm_(BytePtr side, BytePtr uplo, IntPtr m, IntPtr n, DoublePtr alpha, DoublePtr a,
            IntPtr lda, DoublePtr b, IntPtr ldb, DoublePtr beta, DoublePtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int csymm_(BytePtr side, BytePtr uplo, IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr b, IntPtr ldb, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int zsymm_(BytePtr side, BytePtr uplo, IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr b, IntPtr ldb, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int chemm_(BytePtr side, BytePtr uplo, IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr b, IntPtr ldb, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int zhemm_(BytePtr side, BytePtr uplo, IntPtr m, IntPtr n, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr b, IntPtr ldb, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int strmm_(BytePtr side, BytePtr uplo, BytePtr transa, BytePtr diag, IntPtr m, IntPtr n,
            FloatPtr alpha, FloatPtr a, IntPtr lda, FloatPtr b, IntPtr ldb);

    @Generated
    @CFunction
    public static native int dtrmm_(BytePtr side, BytePtr uplo, BytePtr transa, BytePtr diag, IntPtr m, IntPtr n,
            DoublePtr alpha, DoublePtr a, IntPtr lda, DoublePtr b, IntPtr ldb);

    @Generated
    @CFunction
    public static native int ctrmm_(BytePtr side, BytePtr uplo, BytePtr transa, BytePtr diag, IntPtr m, IntPtr n,
            VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr b, IntPtr ldb);

    @Generated
    @CFunction
    public static native int ztrmm_(BytePtr side, BytePtr uplo, BytePtr transa, BytePtr diag, IntPtr m, IntPtr n,
            VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr b, IntPtr ldb);

    @Generated
    @CFunction
    public static native int strsm_(BytePtr side, BytePtr uplo, BytePtr transa, BytePtr diag, IntPtr m, IntPtr n,
            FloatPtr alpha, FloatPtr a, IntPtr lda, FloatPtr b, IntPtr ldb);

    @Generated
    @CFunction
    public static native int dtrsm_(BytePtr side, BytePtr uplo, BytePtr transa, BytePtr diag, IntPtr m, IntPtr n,
            DoublePtr alpha, DoublePtr a, IntPtr lda, DoublePtr b, IntPtr ldb);

    @Generated
    @CFunction
    public static native int ctrsm_(BytePtr side, BytePtr uplo, BytePtr transa, BytePtr diag, IntPtr m, IntPtr n,
            VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr b, IntPtr ldb);

    @Generated
    @CFunction
    public static native int ztrsm_(BytePtr side, BytePtr uplo, BytePtr transa, BytePtr diag, IntPtr m, IntPtr n,
            VoidPtr alpha, VoidPtr a, IntPtr lda, VoidPtr b, IntPtr ldb);

    @Generated
    @CFunction
    public static native int ssyrk_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, FloatPtr alpha, FloatPtr a,
            IntPtr lda, FloatPtr beta, FloatPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int dsyrk_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, DoublePtr alpha, DoublePtr a,
            IntPtr lda, DoublePtr beta, DoublePtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int csyrk_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int zsyrk_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int cherk_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, FloatPtr alpha, VoidPtr a,
            IntPtr lda, FloatPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int zherk_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, DoublePtr alpha, VoidPtr a,
            IntPtr lda, DoublePtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int ssyr2k_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, FloatPtr alpha, FloatPtr a,
            IntPtr lda, FloatPtr b, IntPtr ldb, FloatPtr beta, FloatPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int dsyr2k_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, DoublePtr alpha, DoublePtr a,
            IntPtr lda, DoublePtr b, IntPtr ldb, DoublePtr beta, DoublePtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int csyr2k_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr b, IntPtr ldb, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int zsyr2k_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr b, IntPtr ldb, VoidPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int cher2k_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr b, IntPtr ldb, FloatPtr beta, VoidPtr c__, IntPtr ldc);

    @Generated
    @CFunction
    public static native int zher2k_(BytePtr uplo, BytePtr trans, IntPtr n, IntPtr k, VoidPtr alpha, VoidPtr a,
            IntPtr lda, VoidPtr b, IntPtr ldb, DoublePtr beta, VoidPtr c__, IntPtr ldc);

    /**
     * Create an embedding layer
     * <p>
     * See the description of BNNSLayerParametersEmbedding for a full explanation of this layer.
     *
     * @param layer_params  layer description
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @return A new non-NULL filter on success, and NULL on failure.
     * @see BNNSLayerParametersEmbedding
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSFilterCreateLayerEmbedding(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersEmbedding layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Apply a fused filter to several pairs of (input set, output) data
     * <p>
     * The filter is applied for each of the <tt>batch_size</tt> input set, and produces <tt>batch_size</tt> outputs.
     * <tt>in</tt> (resp. <tt>out</tt>) is expected to point to <tt>batch_size</tt> times the input (resp. output) object size defined when the filter was created.
     * <p>
     * Currently only fused arithmetic -> normalization configuration is supported.
     *
     * @param filter           Filter to apply
     * @param batch_size       Number of (input sets, output) pairs to process
     * @param number_of_inputs number of inputs for the arithmetic operation
     * @param in               pointer to an array of input pointers. in array size must be number_of_inputs.
     * @param in_stride        pointer to an array of input strides, each stride is an Increment (in values) between inputs in the batch for a corresponding input in the in array.
     * @param out              Pointer to the output data
     * @param out_stride       Increment (in values) between outputs
     * @param training         true if training, false if inference
     *                         -ignored if none of the filters is batchnorm
     *                         -see training flag information in BNNSNormalizationFilterApplyBatch
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFusedFilterApplyMultiInputBatch(VoidPtr filter, @NUInt long batch_size,
            @NUInt long number_of_inputs, Ptr<ConstVoidPtr> in, ConstNUIntPtr in_stride, VoidPtr out,
            @NUInt long out_stride, boolean training);

    /**
     * Direct Apply a Quantization filter
     * <p>
     * The Quantization layer converts higher precision tensors to lower precision tensors (Quantize) or lower precision tensors to higher precision tensors (Dequantize)
     *
     * @param layer_params  Quantizer layer parameters
     * @param filter_params Filter runtime parameters, may be NULL for default parameters
     * @param batch_size    Number of (input, output) pairs to process
     * @param input_stride  Increment (in values) between inputs
     * @param output_stride Increment (in values) between outputs
     * @return Zero on success, non-zero on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSDirectApplyQuantizer(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSLayerParametersQuantization layer_params,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params,
            @NUInt long batch_size, @NUInt long input_stride, @NUInt long output_stride);

    /**
     * Clip tensor values to a specified min and max
     * <p>
     * Given a tensor src, this operation writes to a tensor dest of the same type and shape as src with its values clipped to min_val and max_val.
     * <p>
     * [@returns] 0 on success, non-zero on failure
     *
     * @param dest    descriptor for the destination tensor
     * @param src     descriptor for the source tensor, must be of the same type and shape as the dest descriptor.
     * @param min_val The minimum value.
     * @param max_val The maximum value.
     */
    @Generated
    @CFunction
    public static native int BNNSClipByValue(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor dest,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor src,
            float min_val, float max_val);

    /**
     * Clip tensor values to a maximum L2-norm.
     * <p>
     * Given a tensor src, this operation writes to a tensor dest of the same type and shape as src with its values clipped such that the L2-norm does not
     * exceed max_norm.
     * <p>
     * [@returns] 0 on success, non-zero on failure
     *
     * @param dest       descriptor for the destination tensor
     * @param src        descriptor for the source tensor, must be of the same type and shape as the dest descriptor.
     * @param max_norm   The maximum L2-norm.
     * @param axis_flags The dimensions to use for computing the L2-norm. If 0, uses all dimensions.
     */
    @Generated
    @CFunction
    public static native int BNNSClipByNorm(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor dest,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor src,
            float max_norm, int axis_flags);

    /**
     * Clip values of a list of tensors by a maximum global L2-norm.
     * <p>
     * Given a list of tensors src, and a maximum global L2-norm, max_norm, this operation computes a list of clipped tensors.
     * If you already know the global norm of src, you can specify the global norm to use with use_norm.
     * <p>
     * [@returns] 0 on success, non-zero on failure
     *
     * @param dest     array of destination tensor descriptors
     * @param src      array of source tensor descriptors. Each descriptor data in the array must be the same size as its matching dest descriptor in the dest array.
     * @param count    number of descriptors in the dest and src arrays
     * @param max_norm maximum global L2-norm
     * @param use_norm The global norm to use. If zero, global norm is computed based on src.
     */
    @Generated
    @CFunction
    public static native int BNNSClipByGlobalNorm(Ptr<Ptr<BNNSNDArrayDescriptor>> dest,
            Ptr<ConstPtr<BNNSNDArrayDescriptor>> src, @NUInt long count, float max_norm, float use_norm);

    /**
     * Compute the norm of the input tensor.
     * <p>
     * Given a tensor src, this operation compute its specified norm along the specified axes.
     * <p>
     * [@returns] 0 on success, non-zero on failure
     *
     * @param dest       descriptor for the destination tensor. The dimensions in axis_flags are removed from the destination shape.
     *                   If axis_flags specifies all dimensions, destination descriptor must be BNNSDataLayoutVector with size[0] = 1.
     * @param src        descriptor for the source tensor.
     * @param norm_type  Type of the norm. Currently only L2-norm is supported.
     * @param axis_flags The dimensions to use for computing the L2-norm. If 0, uses all dimensions.
     */
    @Generated
    @CFunction
    public static native int BNNSComputeNorm(
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor dest,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor src,
            int norm_type, int axis_flags);

    /**
     * Backward path of norm computation to generate input delta.
     * <p>
     * The backward computation uses the output delta (dy) and the forward pass input (x) and output (y) to generate the input delta (dx).
     * <p>
     * [@returns] 0 on success, non-zero on failure
     *
     * @param in         Pointer to the forward pass input data
     * @param in_delta   Pointer to the input delta descriptor
     * @param out        Pointer to the forward pass output data
     * @param out_delta  Pointer to the output delta descriptor
     * @param norm_type  Type of the norm. Currently only L2-norm is supported.
     * @param axis_flags The dimensions to use for computing the L2-norm. If 0, uses all dimensions.
     */
    @Generated
    @CFunction
    public static native int BNNSComputeNormBackward(ConstVoidPtr in,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor in_delta,
            ConstVoidPtr out,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            int norm_type, int axis_flags);

    /**
     * Apply a fused filter backward to generate gradients.
     * <p>
     * similar to BNNSFilterApplyBackwardBatch, but computing gradients of a fused filter.
     * It is mandatory to compute all active parameter delta in a single function call. computation of input delta is not required in case the fused filter is the first layer in the network
     * <p>
     * Currently only fused arithmetic -> normalization configuration is supported.
     *
     * @param filter           Filter to apply backward
     * @param batch_size       Number of (input sets, output) pairs to process
     * @param number_of_inputs number of inputs for the arithmetic operation
     * @param in               pointer to an array of input pointers. in array size must be number_of_inputs.
     * @param in_stride        pointer to an array of input strides, each stride is an Increment (in values) between inputs in the batch for a corresponding input in the in array.
     * @param in_delta         pointer to an array of input delta pointers. in array size must be number_of_inputs.
     * @param in_delta_stride  pointer to an array of input delta strides, each stride is an Increment (in values) between inputs deltas in the batch for a corresponding input in the in_delta array.
     * @param out              Pointer to the forward pass output data (y)
     *                         - out is ignored if last filter activation is BNNSActivationFunctionIdentity
     * @param out_stride       Increment (in values) between outputs
     * @param out_delta        Pointer to the last filter output delta descriptor (dy)
     *                         - out delta may be modified to save memory when computing fused activation backward
     * @param out_delta_stride Increment (in values) between output deltas
     * @param delta_parameters a pointer to an array of parameter delta pointers
     *                         order of parameter must be first filter parameters followed by second filter parameters until reaching the last filter parameters
     *                         for each filter parameters, the parameter order must follow the same order as in the stand-alone filter backward apply api
     *                         all filter parameters must be provided, excluding input delta and output delta which are provided separately
     *                         null pointer must be used for each non active parameter
     *                         for example, if first filter is arithmetic and second filter is batchnorm, parameters could be extracted in the following way:
     *                         BNNSNDArrayDescriptor* beta_delta = delta_parameters[0]; //first batchnorm parameter in BNNSNormalizationFilterApplyBackwardBatch
     *                         BNNSNDArrayDescriptor* gamma_delta = delta_parameters[1]; //second batchnorm parameter in BNNSNormalizationFilterApplyBackwardBatch
     * @return 0 on success, and -1 on failure.
     */
    @Generated
    @CFunction
    public static native int BNNSFusedFilterApplyBackwardMultiInputBatch(VoidPtr filter, @NUInt long batch_size,
            @NUInt long number_of_inputs, Ptr<ConstVoidPtr> in, ConstNUIntPtr in_stride,
            Ptr<Ptr<BNNSNDArrayDescriptor>> in_delta, ConstNUIntPtr in_delta_stride, ConstVoidPtr out,
            @NUInt long out_stride,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor out_delta,
            @NUInt long out_delta_stride, Ptr<Ptr<BNNSNDArrayDescriptor>> delta_parameters);

    /**
     * Create a random number generator
     * <p>
     * Creates a BNNSRandomGenerator object that can be used to generate a stream of random numbers.
     * The generator will be intialized using an interally generated seed that will vary from call to call.
     * <p>
     * [@returns] On success, an BNNSRandomGenerator object describing the RNG state.
     * On failure, returns NULL.
     *
     * @param method        - method to be used for random number generation.
     * @param filter_params - options structure, if NULL, defaults are used.
     * @see BNNSCreateRandomGeneratorWithSeed
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSCreateRandomGenerator(int method,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Create a random number generator using the given seed
     * <p>
     * Creates a BNNSRandomGenerator object that can be used to generate a stream of random numbers.
     * <p>
     * [@returns] On success, an BNNSRandomGenerator object describing the RNG state.
     * On failure, returns NULL.
     *
     * @param method        - method to be used for random number generation.
     * @param seed          - random seed to be used when initializing generator.
     * @param filter_params - options structure, if NULL, defaults are used.
     * @see BNNSCreateRandomGenerator
     */
    @Generated
    @CFunction
    public static native VoidPtr BNNSCreateRandomGeneratorWithSeed(int method, long seed,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSFilterParameters filter_params);

    /**
     * Destroys a random number generator object
     * <p>
     * Frees memory allocated by BNNSCreateRandomGenerator
     *
     * @param generator - generator to be destroyed
     */
    @Generated
    @CFunction
    public static native void BNNSDestroyRandomGenerator(VoidPtr generator);

    /**
     * Get the state size in bytes for a RandomGenerator
     * <p>
     * This captures the state from a random generator object such that it can be copied or stored and used to restore the
     * generator at a later point.
     * <p>
     * [@returns] State size in bytes (0 on failure).
     *
     * @param generator - generator to be queried
     */
    @Generated
    @CFunction
    @NUInt
    public static native long BNNSRandomGeneratorStateSize(VoidPtr generator);

    /**
     * Get the state for a RandomGenerator
     * <p>
     * This captures the state from a random generator object such that it can be copied or stored and used to restore the
     * generator at a later point.
     * Note that if generator is used on multiple threads, usage is serialized through an internal lock. In this scenario we recommend
     * users create a different BNNSRandomGenerator object with a different seed for each thread to ensure consistency of output
     * on any replay usingBNNSRandomGeneratorGetState/ BNNSRandomGeneratorSetState.
     * <p>
     * [@returns] 0 on success, non-zero on error.
     *
     * @param generator  - generator to be queried
     * @param state_size - size of state buffer in bytes, must be at least as large as the value returned by BNNSRandomGeneratorStateSize.
     * @param state      - pointer to space of size returned by call to BNNSRandomGeneratorStateSize(generator)
     */
    @Generated
    @CFunction
    public static native int BNNSRandomGeneratorGetState(VoidPtr generator, @NUInt long state_size, VoidPtr state);

    /**
     * Set the state for a RandomGenerator
     * <p>
     * Restores the state for a RandomGenerator from one captured by a previous call to BNNSRandomGeneratorGetState().
     * Note that if generator is used on multiple threads, usage is serialized through an internal lock. In this scenario we recommend
     * users create a different BNNSRandomGenerator object with a different seed for each thread to ensure consistency of output
     * on any replay using BNNSRandomGeneratorGetState/BNNSRandomGeneratorSetState.
     * <p>
     * [@returns] 0 on success, non-zero on error.
     *
     * @param generator  - generator to be updated
     * @param state_size - size of state buffer in bytes, only the first BNNSRandomGeneratorStateSize() bytes are copied.
     * @param state      - pointer to space of size returned by call to BNNSRandomGeneratorStateSize(generator)
     */
    @Generated
    @CFunction
    public static native int BNNSRandomGeneratorSetState(VoidPtr generator, @NUInt long state_size, VoidPtr state);

    /**
     * Fill the supplied tensor with random float data using the supplied generator mapped to the Unif(a, b) distribution
     * <p>
     * We generate pseudo-random values from Unif(a, b).
     * Note that if generator is used on multiple threads, usage is serialized through an internal lock. In this scenario we recommend
     * users create a different BNNSRandomGenerator object with a different seed for each thread to ensure consistency of output
     * on any replay using BNNSRandomGeneratorGetState/BNNSRandomGeneratorSetState and to eliminate contention.
     * Should a or b be outside the range of representable values for the output descriptor's data type, they will be capped at the
     * closest finite value that is representable.
     *
     * @param generator - random generator to be used
     * @param desc      - tensor descriptor to be filled with random values, data type must be floating point
     * @param a         - lower bound of distribution (if desc.data_type is not BNNSDataTypeFloat32, a must be exact exactly representable in the requested precision)
     * @param b         - upper bound of distribution (if desc.data_type is not BNNSDataTypeFloat32, b must be exact exactly representable in the requested precision)
     */
    @Generated
    @CFunction
    public static native int BNNSRandomFillUniformFloat(VoidPtr generator,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor desc, float a,
            float b);

    /**
     * Fill the supplied tensor with random integer data using the supplied generator mapped to the Unif(a, b) distribution
     * <p>
     * We generate pseudo-random values from Unif(mean-variance, mean+variance).
     * Note that if generator is used on multiple threads, usage is serialized through an internal lock. In this scenario we recommend
     * users create a different BNNSRandomGenerator object with a different seed for each thread to ensure consistency of output
     * on any replay using BNNSRandomGeneratorGetState/BNNSRandomGeneratorSetState and to eliminate contention.
     * Should a or b be outside the range of representable values for the output descriptor's data type, they will be capped at the
     * closest value that is representable.
     *
     * @param generator - random generator to be used
     * @param desc      - tensor descriptor to be filled with random values, data type must be integer
     * @param a         - lower bound of distribution
     * @param b         - upper bound of distribution
     */
    @Generated
    @CFunction
    public static native int BNNSRandomFillUniformInt(VoidPtr generator,
            @UncertainArgument("Options: reference, array Fallback: reference") BNNSNDArrayDescriptor desc, long a,
            long b);
}
