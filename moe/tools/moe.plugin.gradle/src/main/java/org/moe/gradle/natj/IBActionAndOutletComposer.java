/*
Copyright (C) 2016 Migeran

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package org.moe.gradle.natj;

import org.apache.commons.lang3.StringUtils;
import org.gradle.api.GradleException;
import org.moe.gradle.utils.TaskUtils;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static org.objectweb.asm.Opcodes.ACC_STATIC;
import static org.objectweb.asm.Opcodes.ASM5;

/**
 * This class composes Objective-C source code from Java classes.
 */
public class IBActionAndOutletComposer {

    private final Map<String, ClassVisitor> classMap = new HashMap<>();

    private Consumer<String> infoLogger;

    public void setInfoLogger(Consumer<String> infoLogger) {
        this.infoLogger = infoLogger;
    }

    private void log(String message) {
        if (infoLogger != null) {
            infoLogger.accept(message);
        }
    }

    private Consumer<String> warnLogger;

    public void setWarnLogger(Consumer<String> warnLogger) {
        this.warnLogger = warnLogger;
    }

    private void warn(String message) {
        if (warnLogger != null) {
            warnLogger.accept(message);
        }
    }

    public void read(InputStream inputStream) {
        ClassVisitor visitor = new ClassVisitor();

        ClassReader reader;
        try {
            reader = new ClassReader(inputStream);
        } catch (IOException e) {
            throw new GradleException("an IOException occurred", e);
        }
        reader.accept(visitor.getInitializingVisitor(ASM5, clazz -> {
            log("Read " + clazz.getName());
            if (!clazz.hasObjcClassName() && !clazz.hasObjcClassBinding() && !clazz.hasObjcProtocolName()) {
                log("\n");
                return;
            }
            log(" -> IS_OBJC\n");
            classMap.put(clazz.getName(), clazz);
        }), 0);
    }

    public String compose() {
        log("\n-------------------------------\n\n");

        final StringBuilder builder = new StringBuilder();
        final StringBuilder headBuilder = new StringBuilder();
        headBuilder.append("/** THIS FILE IS GENERATED BY MULTI-OS ENGINE AND MAY BE OVERWRITTEN! **/\n\n");
        headBuilder.append("#if TARGET_INTERFACE_BUILDER\n\n");
        classMap.forEach((k, v) -> {
            if (!v.hasObjcClassName()) {
                return;
            }

            // Get class
            final String objcClassName = v.getObjcClassName();
            log("Generating interface for " + objcClassName + "\n");

            // Get super class
            final String objcSuperClassName = getObjCSuperClass(classMap, v.getSuperName());
            if (objcSuperClassName == null) {
                warn("Failed to locate superclass for " + objcClassName);
                return;
            }
            log("    Found superclass " + objcSuperClassName + "\n");

            // Get interfaces
            final Set<String> interfaces = TaskUtils.compute(() -> {
                final Set<String> itfs = new HashSet<>();

                // Add libraries from interface hierarchy
                for (String superItf : v.getSuperInterfaces()) {
                    ClassVisitor _v = classMap.get(superItf);
                    if (_v != null && _v.hasObjcProtocolName()) {
                        itfs.add(_v.getObjcProtocolName());
                    }
                }

                return itfs;
            });
            log("    Found interfaces " + interfaces + "\n");

            // Get libraries
            final Set<String> libraries = TaskUtils.compute(() -> {
                final Set<String> libs = new HashSet<>();

                // Add first library in class hierarchy
                ClassVisitor _v = v;
                do {
                    if (_v.hasLibrary()) {
                        libs.add(_v.getLibrary());
                        break;
                    }
                    _v = classMap.get(_v.getSuperName());
                } while (_v != null);

                // Add libraries from interface hierarchy
                for (String superItf : v.getSuperInterfaces()) {
                    _v = classMap.get(superItf);
                    while (_v != null) {
                        if (_v.hasLibrary()) {
                            libs.add(_v.getLibrary());
                            break;
                        }
                        _v = classMap.get(_v.getSuperName());
                    }
                }

                return libs;
            });
            log("    Found libraries " + libraries + "\n");

            // Generate imports
            libraries.forEach(x -> builder.append("@import ").append(x).append(";\n"));
            builder.append("\n");

            // Generate interface
            headBuilder.append("@class ").append(objcClassName).append(";\n");
            builder.append("@interface ").append(objcClassName).append(" : ").append(objcSuperClassName);
            if (interfaces.size() > 0) {
                builder.append(" <").append(interfaces.stream().collect(Collectors.joining(", "))).append(">");
            }
            builder.append("\n");
            v.methods.forEach(m -> {
                final Type methodType = Type.getMethodType(m.getDesc());

                // Generate properties
                if (m.isProperty()) {
                    log("    Generating property for " + m.getName() + m.getDesc() + "\n");
                    if (methodType.getArgumentTypes().length > 0) {
                        warn("Method " + m + " in class " + v.getName()
                                + " cannot have the @Property annotation and have arguments at the same time. Skipping");
                        return;
                    }
                    final Type returnType = methodType.getReturnType();
                    if (returnType.getSort() != Type.OBJECT) {
                        warn("Method " + m + " in class " + v.getName()
                                + " cannot have the @Property annotation and have a non-object return type. Skipping");
                        return;
                    }
                    final String internalName = returnType.getInternalName();
                    final ClassVisitor internalType = classMap.get(internalName);
                    builder.append("@property (strong) ");
                    if (m.isIBOutlet()) {
                        builder.append("IBOutlet ");
                    }
                    final int begin = builder.length();
                    if (internalType == null) {
                        builder.append("id ").append(m.getSel()).append(";\n");
                    } else if (internalType.hasObjcProtocolName()) {
                        builder.append("id<").append(internalType.getObjcProtocolName()).append("> ").append(m.getSel())
                                .append(";\n");
                    } else if (internalType.hasObjcClassName()) {
                        builder.append(internalType.getObjcClassName()).append(" *").append(m.getSel()).append(";\n");
                    } else if (internalType.hasObjcClassBinding()) {
                        builder.append(internalType.getObjcClassBinding()).append(" *").append(m.getSel())
                                .append(";\n");
                    } else {
                        builder.replace(begin, builder.length(), "");
                        warn("Unsupported return type for method " + m + " in class " + v.getName() + ": " + returnType
                                .getDescriptor() + ". Skipping");
                        return;
                    }
                    return;
                }

                // Generate actions
                if (m.isIBAction()) {
                    log("    Generating action for " + m.getName() + m.getDesc() + "\n");
                    final Type returnType = methodType.getReturnType();
                    if (returnType.getSort() != Type.VOID) {
                        warn("Method " + m + " in class " + v.getName()
                                + " cannot have the @IBAction annotation and have a non-void return type. Skipping");
                        return;
                    }

                    final int numArgs = methodType.getArgumentTypes().length;
                    if (numArgs == 0) {
                        builder.append("- (IBAction)").append(m.getSel()).append(";\n");
                        return;
                    }

                    final Type arg0 = methodType.getArgumentTypes()[0];
                    if (arg0.getSort() != Type.OBJECT) {
                        warn("Method " + m + " in class " + v.getName()
                                + " cannot have the @IBAction annotation, have 1 one or more arguments and have a "
                                + "non-object first argument type. Skipping");
                        return;
                    }
                    final String arg0InternalName = arg0.getInternalName();
                    final ClassVisitor arg0InternalType = classMap.get(arg0InternalName);

                    if (numArgs == 1) {
                        if (StringUtils.countMatches(m.getSel(), ":") != 1) {
                            warn("Malformed selector for method " + m + " in class " + v.getName()
                                    + ": expected one argument in selector. Skipping");
                            return;
                        }
                        if (!m.getSel().endsWith(":")) {
                            warn("Malformed selector for method " + m + " in class " + v.getName()
                                    + ": selector must end in ':'. Skipping");
                            return;
                        }
                        final int begin = builder.length();
                        builder.append("- (IBAction)").append(m.getSel()).append("(");
                        if (arg0InternalType == null) {
                            builder.append("id");
                        } else if (arg0InternalType.hasObjcProtocolName()) {
                            builder.append("id<").append(arg0InternalType.getObjcProtocolName()).append(">");
                        } else if (arg0InternalType.hasObjcClassName()) {
                            builder.append(arg0InternalType.getObjcClassName()).append(" *");
                        } else if (arg0InternalType.hasObjcClassBinding()) {
                            builder.append(arg0InternalType.getObjcClassBinding()).append(" *");
                        } else {
                            builder.replace(begin, builder.length(), "");
                            warn("Unsupported return type for method " + m + " in class " + v.getName() + ": "
                                    + returnType.getDescriptor() + ". Skipping");
                            return;
                        }
                        builder.append(")sender;\n");
                        return;
                    }

                    final Type arg1 = methodType.getArgumentTypes()[1];
                    if (arg1.getSort() != Type.OBJECT) {
                        warn("Method " + m + " in class " + v.getName()
                                + " cannot have the @IBAction annotation, have 2 one or more arguments and have a "
                                + "non UIEvent second argument type. Skipping");
                        return;
                    }
                    final String arg1InternalName = arg0.getInternalName();
                    final ClassVisitor arg1InternalType = classMap.get(arg1InternalName);
                    if (arg1InternalType == null || !"UIEvent".equals(arg1InternalType.getObjcClassBinding())) {
                        warn("Method " + m + " in class " + v.getName()
                                + " cannot have the @IBAction annotation, have 2 one or more arguments and have a "
                                + "non UIEvent second argument type. Skipping");
                        return;
                    }

                    if (numArgs == 2) {
                        if (StringUtils.countMatches(m.getSel(), ":") != 2) {
                            warn("Malformed selector for method " + m + " in class " + v.getName()
                                    + ": expected two arguments in selector. Skipping");
                            return;
                        }
                        if (!m.getSel().endsWith(":withEvent:")) {
                            warn("Malformed selector for method " + m + " in class " + v.getName()
                                    + ": selector must end in ':withEvent:'. Skipping");
                            return;
                        }
                        final int begin = builder.length();
                        builder.append("- (IBAction)").append(m.getSel()).append("(");
                        if (arg0InternalType == null) {
                            builder.append("id");
                        } else if (arg0InternalType.hasObjcProtocolName()) {
                            builder.append("id<").append(arg0InternalType.getObjcProtocolName()).append(">");
                        } else if (arg0InternalType.hasObjcClassName()) {
                            builder.append(arg0InternalType.getObjcClassName()).append(" *");
                        } else if (arg0InternalType.hasObjcClassBinding()) {
                            builder.append(arg0InternalType.getObjcClassBinding()).append(" *");
                        } else {
                            builder.replace(begin, builder.length(), "");
                            warn("Unsupported return type for method " + m + " in class " + v.getName() + ": "
                                    + returnType.getDescriptor() + ". Skipping");
                        }
                        builder.append(")sender withEvent:(UIEvent *)event;\n");
                    }

                    warn("Too many arguments for method " + m + " in class " + v.getName()
                            + ": expected zero, one or two arguments in selector. Skipping");
                    return;
                }

                log("    Skipping " + m.getName() + m.getDesc() + "\n");
            });

            // Generate close interface
            builder.append("@end\n\n");
        });

        // Generate footer
        builder.append("#endif\n");

        // Combine head and body
        headBuilder.append("\n").append(builder);
        return headBuilder.toString();
    }

    private static class ClassVisitor extends NatJClass<ClassVisitor> {

        private final List<NatJMethod> methods = new ArrayList<>();

        @Override
        public org.objectweb.asm.ClassVisitor getInitializingVisitor(int api, Consumer<ClassVisitor> consumer) {
            return new org.objectweb.asm.ClassVisitor(api, super.getInitializingVisitor(api, consumer)) {
                @Override
                public MethodVisitor visitMethod(int access, String name, String desc, String signature,
                        String[] exceptions) {
                    if (!hasObjcClassName() && !hasObjcClassBinding()) {
                        return null;
                    }
                    return new NatJMethod(name, desc, (access & ACC_STATIC) > 0).getInitializingVisitor(api, method -> {
                        if (method.hasSel() && (method.isProperty() || method.isIBAction() || method.isIBOutlet())) {
                            methods.add(method);
                        }
                    });
                }
            };
        }
    }

    private String getObjCSuperClass(Map<String, ClassVisitor> classMap, String superName) {
        final ClassVisitor superClass = classMap.get(superName);
        if (superClass == null) {
            return null;
        }
        if (superClass.hasObjcClassName()) {
            return superClass.getObjcClassName();
        }
        if (superClass.hasObjcClassBinding()) {
            return superClass.getObjcClassBinding();
        }
        return null;
    }
}
