/*
Copyright 2014-2016 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package org.moe.natj.processor;

import org.moe.natj.processor.cxx.CxxType;
import org.moe.natj.processor.cxx.ITypeResolverPlugin;
import org.apache.commons.cli.*;

import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.nio.file.FileSystems;
import java.nio.file.Path;

/**
 * Processor configuration.
 */
public class Config {

    /**
     * Processor mode.
     */
    public enum Mode {
        /**
         * C++ mode.
         */
        CXX;

        /**
         * Returns the Mode for the specified name.
         *
         * @param name Mode name
         * @return Mode
         */
        public static Mode forString(String name) {
            if (name == null) {
                throw new NullPointerException();
            }
            if ("c++".equals(name)) {
                return CXX;
            }
            throw new IllegalArgumentException("Unknown mode '" + name + "'");
        }
    }

    /**
     * Path to the inputs.
     */
    public final Path input;

    /**
     * Path to the outputs.
     */
    public final Path output;

    /**
     * Processing mode.
     */
    public final Mode mode;

    /**
     * Generated C++ source file's output path.
     */
    public final Path genCxxSource;

    /**
     * Generated C++ header file's output path.
     */
    public final Path genCxxHeader;

    /**
     * Generated class files bytecode version.
     */
    public final int bytecodeVersion;

    /**
     * Generate static_assert-s on types to check binding correctness.
     */
    public final boolean genCheckCxxTypeAnnotations;

    /**
     * Generated static_assert-s on method and function return types to check binding correctness.
     */
    public final boolean genCheckCxxReturnTypeCorrectness;

    /**
     * Create a new Config instance from the specified arguments.
     *
     * @param args Arguments
     */
    public Config(String[] args) {
        final Options options = new Options();
        options.addOption("h", "help", false, "Print this help info")
                .addOption("i", "input", true, "(Required) Input directory containing class files")
                .addOption("o", "output", true, "(Required) Output directory")
                .addOption("m", "mode", true, "(Required) Mode to run in [c++]")
                .addOption("gen_cxx_source", true, "(Required in c++ mode) Generated C++ source file path")
                .addOption("gen_cxx_header", true, "Generated C++ header file path")
                .addOption("gen_check_cxx_type_annotations", false, "Generate static_assert-s on types to check " +
                        "binding correctness")
                .addOption("gen_check_cxx_return_type_correctness", false, "Generated static_assert-s on method and " +
                        "function return types to check binding correctness")
                .addOption("dyn_type_resolvers", true, "Classes of the dynamic type resolvers (comma separated list)")
                .addOption("bv", "bytecode-version", true, "Generated bytecode version (0 = same as source)");
        final DefaultParser parser = new DefaultParser();
        final CommandLine commandLine;
        try {
            commandLine = parser.parse(options, args);
        } catch (UnrecognizedOptionException e) {
            System.err.println("Unrecognized option: " + e.getOption());
            System.exit(1);
            throw new RuntimeException(e);
        } catch (ParseException e) {
            System.err.println("Failed to parse arguments");
            throw new RuntimeException(e);
        }

        if (commandLine.hasOption("h")) {
            HelpFormatter formatter = new HelpFormatter();
            formatter.setWidth(Integer.MAX_VALUE);
            formatter.printHelp("java -jar natj-processor.jar [OPTION]...", options);
            System.exit(1);
        }

        // Setup input
        final String pInput = commandLine.getOptionValue("i");
        if (pInput == null) {
            throw new RuntimeException("Input was not set");
        } else {
            input = FileSystems.getDefault().getPath(pInput);
            final File file = input.toFile();
            if (!file.exists()) throw new RuntimeException("Input directory '" + file + "' does not exist");
            if (!file.isDirectory()) throw new RuntimeException("Input directory '" + file + "' is not a directory");
        }

        // Setup output
        final String pOutput = commandLine.getOptionValue("o");
        if (pOutput == null) {
            throw new RuntimeException("Output was not set");
        } else {
            output = FileSystems.getDefault().getPath(pOutput);
            final File file = output.toFile();
            if (!file.exists()) {
                if (!file.mkdirs()) throw new RuntimeException("Failed to create directory '" + file + "'");
            }
            if (!file.isDirectory()) throw new RuntimeException("Output directory '" + file + "' is not a directory");
        }

        // Setup mode
        final String pMode = commandLine.getOptionValue("m");
        if (pMode == null) {
            throw new RuntimeException("Mode was not set");
        } else {
            mode = Mode.forString(pMode);
        }

        // Setup generated C++ source
        final String pGenCxxSource = commandLine.getOptionValue("gen_cxx_source");
        if (pGenCxxSource == null) {
            if (mode == Mode.CXX) {
                throw new RuntimeException("Generated C++ source path was not set");
            }
            genCxxSource = null;
        } else {
            genCxxSource = FileSystems.getDefault().getPath(pGenCxxSource);
            final File file = genCxxSource.toFile();
            if (file.exists() && !file.isFile()) {
                throw new RuntimeException("Generated C++ source path exists and is not a file");
            }
        }

        // Setup generated C++ header
        final String pGenCxxHeader = commandLine.getOptionValue("gen_cxx_header");
        if (pGenCxxHeader == null) {
            genCxxHeader = null;
        } else {
            genCxxHeader = FileSystems.getDefault().getPath(pGenCxxHeader);
            final File file = genCxxHeader.toFile();
            if (file.exists() && !file.isFile()) {
                throw new RuntimeException("Generated C++ header path exists and is not a file");
            }
        }

        // Setup generate C++ type annotation checks flag
        genCheckCxxTypeAnnotations = commandLine.hasOption("gen_check_cxx_type_annotations");

        // Setup generate C++ return type correctness checks flag.
        genCheckCxxReturnTypeCorrectness = commandLine.hasOption("gen_check_cxx_return_type_correctness");

        // Setup dynamic type resolvers
        final String pDynTypeResolvers = commandLine.getOptionValue("dyn_type_resolvers");
        if (pDynTypeResolvers != null) {
            final String[] resolvers = pDynTypeResolvers.split(",");
            for (String resolver : resolvers) {
                String clsName = resolver.trim();
                if (clsName.length() == 0) continue;
                System.out.println("Registering type resolver class: " + clsName);
                Class<?> cls;
                try {
                    cls = Class.forName(clsName);
                } catch (ClassNotFoundException e) {
                    throw new RuntimeException(e);
                }
                final Constructor<?> constructor;
                try {
                    constructor = cls.getConstructor();
                } catch (NoSuchMethodException e) {
                    throw new RuntimeException(e);
                }
                final ITypeResolverPlugin instance;
                try {
                    instance = (ITypeResolverPlugin) constructor.newInstance();
                } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
                    throw new RuntimeException(e);
                }
                CxxType.registerPlugin(instance);
            }
        }

        // Setup bytecode version
        final String pBytecodeVersionStr = commandLine.getOptionValue("bv", "0");
        final int pBytecodeVersion;
        try {
            pBytecodeVersion = Integer.parseInt(pBytecodeVersionStr);
        } catch (NumberFormatException ex) {
            throw new RuntimeException("Bytecode version parameter is not a number");
        }
        if (pBytecodeVersion != 0 && (pBytecodeVersion < 50 || pBytecodeVersion > 52)) {
            throw new RuntimeException("Bytecode version can only be 0 (Same as source), 50 (Java 6), 51 (Java 7) or 52 (Java 8)");
        }
        bytecodeVersion = pBytecodeVersion;
    }
}
